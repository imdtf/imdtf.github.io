<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.43" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-v2-demo.mrhope.site/interview/Redis.html"><meta property="og:site_name" content="DTF's blog"><meta property="og:title" content="Redis 篇"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-06-08T15:47:48.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-06-08T15:47:48.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>Redis 篇 | DTF's blog</title><meta name="description" content="我的学习记录博客">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.af58f80f.css">
    <link rel="modulepreload" href="/assets/app.597ce2f2.js"><link rel="modulepreload" href="/assets/Redis.html.c5915ac6.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/Redis.html.b201ad05.js"><link rel="prefetch" href="/assets/index.html.e173ef83.js"><link rel="prefetch" href="/assets/ElasticSearch.html.279e5d7b.js"><link rel="prefetch" href="/assets/MQ.html.9d040945.js"><link rel="prefetch" href="/assets/MySQL.html.d1ae2d1e.js"><link rel="prefetch" href="/assets/design-patterns.html.733535fa.js"><link rel="prefetch" href="/assets/dubbo.html.c776d990.js"><link rel="prefetch" href="/assets/git.html.72b47aa0.js"><link rel="prefetch" href="/assets/java-base.html.db5311da.js"><link rel="prefetch" href="/assets/jvm.html.53d34a5d.js"><link rel="prefetch" href="/assets/linux.html.65017b81.js"><link rel="prefetch" href="/assets/maven.html.ceec6571.js"><link rel="prefetch" href="/assets/multi-thread.html.3652cc7f.js"><link rel="prefetch" href="/assets/mybatis.html.cb44fe5a.js"><link rel="prefetch" href="/assets/network.html.b1609fd9.js"><link rel="prefetch" href="/assets/nginx.html.9ca67d3a.js"><link rel="prefetch" href="/assets/soft-power.html.508fb44f.js"><link rel="prefetch" href="/assets/spring-boot.html.e888e4e7.js"><link rel="prefetch" href="/assets/spring-cloud.html.57c2b0d4.js"><link rel="prefetch" href="/assets/spring.html.94b261f5.js"><link rel="prefetch" href="/assets/tomcat.html.dc4aea03.js"><link rel="prefetch" href="/assets/zookeeper.html.75896320.js"><link rel="prefetch" href="/assets/分布式.html.6e369ff9.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.58f6dba8.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.04b85b76.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.116abb6a.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.1d83f138.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.40f6f1e4.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.900bda42.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.3492d336.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.dcc88998.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.7239f150.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.6199feb4.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.57624587.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.d99caa1b.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.cabd308f.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.c89015fe.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.6b8e9ff0.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.e1e4da4a.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.697b9a23.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.9000e742.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.4d12fb46.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.48d80708.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.da9eab5a.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.95150d1c.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.b9bda91b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.bb805e63.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.514eb232.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.4cfc99f3.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.1561ec1a.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.11ef8b3e.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.ef765715.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.50f4f1d6.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.60a1c908.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.b6c6ee60.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.0fa73bd5.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.bfe213be.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.e0558584.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.3087bc74.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.c5df5f6e.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.b9edc687.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.9906de00.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.4b8670c8.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.b78f67d4.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b762f081.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.e5ec66c1.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.f9b4c2c6.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.d4daa082.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.1f616fc4.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.25fe22f4.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.8bb53047.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.63f53d07.js"><link rel="prefetch" href="/assets/00-Introduction.html.aed5c856.js"><link rel="prefetch" href="/assets/00-Preface.html.feee9db3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.ab6ea8b6.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.0224a9bf.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.bea55af9.js"><link rel="prefetch" href="/assets/04-Operators.html.35525abf.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.c4cd86f5.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.b5c2b268.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.399ae58f.js"><link rel="prefetch" href="/assets/08-Reuse.html.0ab07e65.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.89443cf5.js"><link rel="prefetch" href="/assets/10-Interfaces.html.4948bb7b.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.b8f6a196.js"><link rel="prefetch" href="/assets/12-Collections.html.52f2a06b.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.db50a84d.js"><link rel="prefetch" href="/assets/14-Streams.html.9308751d.js"><link rel="prefetch" href="/assets/15-Exceptions.html.40e68d98.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.3edda5f0.js"><link rel="prefetch" href="/assets/17-Files.html.e87e7c99.js"><link rel="prefetch" href="/assets/18-Strings.html.a2842b17.js"><link rel="prefetch" href="/assets/19-Type-Information.html.12cc605b.js"><link rel="prefetch" href="/assets/20-Generics.html.3e4b17f6.js"><link rel="prefetch" href="/assets/21-Arrays.html.67720723.js"><link rel="prefetch" href="/assets/22-Enumerations.html.ab50f89b.js"><link rel="prefetch" href="/assets/23-Annotations.html.747faef3.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.5b9841aa.js"><link rel="prefetch" href="/assets/25-Patterns.html.10af6fe7.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.13f6de18.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.4774ac79.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.fec6d369.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.fe3a1870.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.35950f4f.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.54af4f5f.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.bb07240e.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.8f39ad15.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.39836314.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.ee52b83c.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.68302b50.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.9b5edd63.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.c8a5f6e1.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.34dcd815.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.8c0a6980.js"><link rel="prefetch" href="/assets/GLOSSARY.html.af317d6f.js"><link rel="prefetch" href="/assets/index.html.859506fe.js"><link rel="prefetch" href="/assets/404.html.61bcede7.js"><link rel="prefetch" href="/assets/index.html.6eefb2c9.js"><link rel="prefetch" href="/assets/index.html.276bb6b8.js"><link rel="prefetch" href="/assets/index.html.6c49b0c9.js"><link rel="prefetch" href="/assets/index.html.938faca6.js"><link rel="prefetch" href="/assets/index.html.234dfb8d.js"><link rel="prefetch" href="/assets/index.html.02cffa46.js"><link rel="prefetch" href="/assets/index.html.c70b19c7.js"><link rel="prefetch" href="/assets/index.html.e9ae5772.js"><link rel="prefetch" href="/assets/index.html.43ef8dd6.js"><link rel="prefetch" href="/assets/index.html.0319d1c3.js"><link rel="prefetch" href="/assets/ElasticSearch.html.1822d360.js"><link rel="prefetch" href="/assets/MQ.html.257a1eec.js"><link rel="prefetch" href="/assets/MySQL.html.12265bed.js"><link rel="prefetch" href="/assets/design-patterns.html.4dff82bc.js"><link rel="prefetch" href="/assets/dubbo.html.70900b5c.js"><link rel="prefetch" href="/assets/git.html.9f0ce8a6.js"><link rel="prefetch" href="/assets/java-base.html.f9b49957.js"><link rel="prefetch" href="/assets/jvm.html.7b42d915.js"><link rel="prefetch" href="/assets/linux.html.9f1e7d55.js"><link rel="prefetch" href="/assets/maven.html.f848fc43.js"><link rel="prefetch" href="/assets/multi-thread.html.5d323dfe.js"><link rel="prefetch" href="/assets/mybatis.html.868f5463.js"><link rel="prefetch" href="/assets/network.html.347740e9.js"><link rel="prefetch" href="/assets/nginx.html.acf44958.js"><link rel="prefetch" href="/assets/soft-power.html.fa4cc2bb.js"><link rel="prefetch" href="/assets/spring-boot.html.eb446c44.js"><link rel="prefetch" href="/assets/spring-cloud.html.5a2e7953.js"><link rel="prefetch" href="/assets/spring.html.e5d334fa.js"><link rel="prefetch" href="/assets/tomcat.html.1edb1280.js"><link rel="prefetch" href="/assets/zookeeper.html.d47f6f3b.js"><link rel="prefetch" href="/assets/分布式.html.8362b544.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.e0b3e691.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.73dedd46.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.a7a61510.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.19af1cfc.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.078c9131.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.3da35573.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.ee1e2ba2.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.5796a618.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.26f3a028.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.cbc4b5ad.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.d79a5425.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.8dab2c77.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.f8e03fcd.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.f1c1f80f.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.a0b4da7e.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.8cf5825d.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.63173a34.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.a51cc121.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.55632279.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.aa190da2.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.c311f962.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.bef20aad.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.54dcb84b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.baae2fb3.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.de07d445.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.d8703177.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.93feb431.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.14ad8743.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.2e4d7d89.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.ebe6ec2f.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.a1a0d482.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.7353d51d.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.b546fd0e.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.fa14f195.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.ddaebd47.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.9f503937.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.95f81089.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.354471cd.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.c9d4ab47.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.9b369837.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.93069f29.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b6a68508.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.4cda471b.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.fec20cbf.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.46eb93f8.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.70884000.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.16cc56b7.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.0f6a9d34.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.ced5f781.js"><link rel="prefetch" href="/assets/00-Introduction.html.2b1f0852.js"><link rel="prefetch" href="/assets/00-Preface.html.e516d7c3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.86c4af1e.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.88cddd12.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.4da53003.js"><link rel="prefetch" href="/assets/04-Operators.html.f9d313c6.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.ecf81ffe.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.c35ecf1b.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.396e0a6f.js"><link rel="prefetch" href="/assets/08-Reuse.html.8c7c4047.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.2150cc57.js"><link rel="prefetch" href="/assets/10-Interfaces.html.6ee853fa.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.ae7b89c4.js"><link rel="prefetch" href="/assets/12-Collections.html.0483e4dd.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.63412e72.js"><link rel="prefetch" href="/assets/14-Streams.html.7e7cce42.js"><link rel="prefetch" href="/assets/15-Exceptions.html.c186f23a.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.b3313ffc.js"><link rel="prefetch" href="/assets/17-Files.html.7a9ad498.js"><link rel="prefetch" href="/assets/18-Strings.html.46e57539.js"><link rel="prefetch" href="/assets/19-Type-Information.html.b68894bf.js"><link rel="prefetch" href="/assets/20-Generics.html.3993804b.js"><link rel="prefetch" href="/assets/21-Arrays.html.4d150e5c.js"><link rel="prefetch" href="/assets/22-Enumerations.html.87d060f0.js"><link rel="prefetch" href="/assets/23-Annotations.html.0c455464.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.8485a02c.js"><link rel="prefetch" href="/assets/25-Patterns.html.4f5781b0.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.4e7ecda3.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.1a18282e.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.ec4969df.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.c956724d.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.ac5ea88b.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.26db6884.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.80dbdde9.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.613e991c.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.de90320b.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.1f3841f2.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.a3de1972.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.28579d58.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.aae5a747.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.4bf49d65.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.9d9599c8.js"><link rel="prefetch" href="/assets/GLOSSARY.html.d812823c.js"><link rel="prefetch" href="/assets/index.html.d25b0535.js"><link rel="prefetch" href="/assets/404.html.0c8252b8.js"><link rel="prefetch" href="/assets/index.html.d5cc08ad.js"><link rel="prefetch" href="/assets/index.html.1331f6ca.js"><link rel="prefetch" href="/assets/index.html.da6c3a69.js"><link rel="prefetch" href="/assets/index.html.1174fbbd.js"><link rel="prefetch" href="/assets/index.html.c73d2264.js"><link rel="prefetch" href="/assets/index.html.1e315145.js"><link rel="prefetch" href="/assets/index.html.514b72a3.js"><link rel="prefetch" href="/assets/index.html.b19f5086.js"><link rel="prefetch" href="/assets/index.html.1ac6115e.js"><link rel="prefetch" href="/assets/404.3a5fd86b.js"><link rel="prefetch" href="/assets/Layout.42785ec5.js"><link rel="prefetch" href="/assets/Slide.5e14cdfb.js"><link rel="prefetch" href="/assets/Blog.f29d76d0.js"><link rel="prefetch" href="/assets/auto.esm.15d52109.js"><link rel="prefetch" href="/assets/index.1842ee54.js"><link rel="prefetch" href="/assets/mermaid.esm.min.f71f1464.js"><link rel="prefetch" href="/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/assets/photoswipe.esm.92018b73.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="DTF&#39;s blog"><!----><span class="site-name hide-in-pad">DTF&#39;s blog</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guide/" class="nav-link" aria-label="使用指南"><i class="icon iconfont icon-creative"></i>使用指南<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/imdtf/blog" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" aria-labelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewbox="0 0 1024 1024" aria-labelledby="outlook"><title id="outlook" lang="en">outlook icon</title><g fill="currentColor"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></g></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-guide"></i><span class="title">语言</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-markdown"></i><span class="title">数据库</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-question"></i><span class="title">面试题</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/interview/java-base.html" class="nav-link sidebar-link sidebar-page" aria-label="基础篇"><!---->基础篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/jvm.html" class="nav-link sidebar-link sidebar-page" aria-label="JVM 篇"><!---->JVM 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/multi-thread.html" class="nav-link sidebar-link sidebar-page" aria-label="多线程&amp;并发篇"><!---->多线程&amp;并发篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring.html" class="nav-link sidebar-link sidebar-page" aria-label="Spring 篇"><!---->Spring 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-boot.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringBoot 篇"><!---->SpringBoot 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-cloud.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringCloud 篇"><!---->SpringCloud 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/dubbo.html" class="nav-link sidebar-link sidebar-page" aria-label="Dubbo 篇"><!---->Dubbo 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/mybatis.html" class="nav-link sidebar-link sidebar-page" aria-label="MyBatis 篇"><!---->MyBatis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MySQL.html" class="nav-link sidebar-link sidebar-page" aria-label="MySQL 篇"><!---->MySQL 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/nginx.html" class="nav-link sidebar-link sidebar-page" aria-label="Nginx 篇"><!---->Nginx 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MQ.html" class="nav-link sidebar-link sidebar-page" aria-label="MQ 篇"><!---->MQ 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/linux.html" class="nav-link sidebar-link sidebar-page" aria-label="Linux 篇"><!---->Linux 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/zookeeper.html" class="nav-link sidebar-link sidebar-page" aria-label="Zookeeper 篇"><!---->Zookeeper 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/interview/Redis.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Redis 篇"><!---->Redis 篇<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_1、为什么要用缓存" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1、为什么要用缓存"><!---->1、为什么要用缓存<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_2、使用-redis-具有那些好处" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2、使用 Redis 具有那些好处？"><!---->2、使用 Redis 具有那些好处？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_3、什么是-redis" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3、什么是 Redis？"><!---->3、什么是 Redis？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_4、为什么使用-redis-而不是用-memcache-呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4、为什么使用 Redis 而不是用 Memcache 呢？"><!---->4、为什么使用 Redis 而不是用 Memcache 呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_5、为什么redis单线程模型效率也能那么高" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5、为什么Redis单线程模型效率也能那么高？"><!---->5、为什么Redis单线程模型效率也能那么高？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_6、说说-redis-的线程模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6、说说 Redis 的线程模型"><!---->6、说说 Redis 的线程模型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_7、为什么-redis-需要把所有数据放到内存中" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7、为什么 Redis 需要把所有数据放到内存中？"><!---->7、为什么 Redis 需要把所有数据放到内存中？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_8、redis-的同步机制了解是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8、Redis 的同步机制了解是什么？"><!---->8、Redis 的同步机制了解是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_9、pipeline-有什么好处-为什么要用-pipeline" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9、pipeline 有什么好处，为什么要用 pipeline？"><!---->9、pipeline 有什么好处，为什么要用 pipeline？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_10、说一下-redis-有什么优点和缺点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10、说一下 Redis 有什么优点和缺点"><!---->10、说一下 Redis 有什么优点和缺点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_11、redis-缓存刷新策略有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11、Redis 缓存刷新策略有哪些？"><!---->11、Redis 缓存刷新策略有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_12、redis-持久化方式有哪些-以及有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12、Redis 持久化方式有哪些？以及有什么区别？"><!---->12、Redis 持久化方式有哪些？以及有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_13、持久化有两种-那应该怎么选择呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="13、持久化有两种，那应该怎么选择呢？"><!---->13、持久化有两种，那应该怎么选择呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_14、怎么使用-redis-实现消息队列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="14、怎么使用 Redis 实现消息队列？"><!---->14、怎么使用 Redis 实现消息队列？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_15、说说你对redis事务的理解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15、说说你对Redis事务的理解"><!---->15、说说你对Redis事务的理解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_16、redis-为什么设计成单线程的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="16、Redis 为什么设计成单线程的？"><!---->16、Redis 为什么设计成单线程的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_17、什么是-bigkey-会存在什么影响" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17、什么是 bigkey？会存在什么影响？"><!---->17、什么是 bigkey？会存在什么影响？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_18、熟悉哪些-redis-集群模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18、熟悉哪些 Redis 集群模式？"><!---->18、熟悉哪些 Redis 集群模式？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_19、是否使用过-redis-cluster-集群-集群的原理是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="19、是否使用过 Redis Cluster 集群，集群的原理是什么？"><!---->19、是否使用过 Redis Cluster 集群，集群的原理是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_20、redis-cluster-集群方案什么情况下会导致整个集群不可" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="20、Redis Cluster 集群方案什么情况下会导致整个集群不可"><!---->20、Redis Cluster 集群方案什么情况下会导致整个集群不可<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_21、redis-集群架构模式有哪几种" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="21、Redis 集群架构模式有哪几种？"><!---->21、Redis 集群架构模式有哪几种？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_22、说说-redis-哈希槽的概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="22、说说 Redis 哈希槽的概念？"><!---->22、说说 Redis 哈希槽的概念？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_23、redis-常见性能问题和解决方案有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="23、Redis 常见性能问题和解决方案有哪些？"><!---->23、Redis 常见性能问题和解决方案有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_24、假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="24、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><!---->24、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_25、如果有大量的-key-需要设置同一时间过期-一般需要注意什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="25、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"><!---->25、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_26、什么情况下可能会导致-redis-阻塞" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="26、什么情况下可能会导致 Redis 阻塞？"><!---->26、什么情况下可能会导致 Redis 阻塞？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_27、缓存和数据库谁先更新呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="27、缓存和数据库谁先更新呢？"><!---->27、缓存和数据库谁先更新呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_28、怎么提高缓存命中率" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="28、怎么提高缓存命中率？"><!---->28、怎么提高缓存命中率？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_29、redis-如何解决-key-冲突" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="29、Redis 如何解决 key 冲突？"><!---->29、Redis 如何解决 key 冲突？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_30、redis-报内存不足怎么处理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="30、Redis 报内存不足怎么处理？"><!---->30、Redis 报内存不足怎么处理？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_31、说说redis持久化机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="31、说说Redis持久化机制"><!---->31、说说Redis持久化机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_32、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="32、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题"><!---->32、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_33、热点数据和冷数据是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="33、热点数据和冷数据是什么"><!---->33、热点数据和冷数据是什么<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_34、memcache-与-redis-的区别都有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="34、Memcache 与 Redis 的区别都有哪些？"><!---->34、Memcache 与 Redis 的区别都有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_35、单线程的-redis-为什么这么快" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="35、单线程的 Redis 为什么这么快"><!---->35、单线程的 Redis 为什么这么快<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_36、redis-的数据类型-以及每种数据类型的使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="36、Redis 的数据类型，以及每种数据类型的使用场景"><!---->36、Redis 的数据类型，以及每种数据类型的使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_37、redis-的过期策略以及内存淘汰机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="37、Redis 的过期策略以及内存淘汰机制"><!---->37、Redis 的过期策略以及内存淘汰机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_38、redis-为什么是单线程的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="38、Redis 为什么是单线程的"><!---->38、Redis 为什么是单线程的<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_39、redis-常见性能问题和解决方案" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="39、Redis 常见性能问题和解决方案？"><!---->39、Redis 常见性能问题和解决方案？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_40、为什么redis的操作是原子性的-怎么保证原子性的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="40、为什么Redis的操作是原子性的，怎么保证原子性的？"><!---->40、为什么Redis的操作是原子性的，怎么保证原子性的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_41、了解redis的事务吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="41、了解Redis的事务吗？"><!---->41、了解Redis的事务吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/Redis.html#_42、redis-的数据类型及使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="42、Redis 的数据类型及使用场景"><!---->42、Redis 的数据类型及使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/interview/%E5%88%86%E5%B8%83%E5%BC%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="分布式篇"><!---->分布式篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/network.html" class="nav-link sidebar-link sidebar-page" aria-label="网络篇"><!---->网络篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/design-patterns.html" class="nav-link sidebar-link sidebar-page" aria-label="设计模式"><!---->设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/maven.html" class="nav-link sidebar-link sidebar-page" aria-label="maven 篇"><!---->maven 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/ElasticSearch.html" class="nav-link sidebar-link sidebar-page" aria-label="ElasticSearch 篇"><!---->ElasticSearch 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/tomcat.html" class="nav-link sidebar-link sidebar-page" aria-label="tomcat 篇"><!---->tomcat 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/git.html" class="nav-link sidebar-link sidebar-page" aria-label="Git 篇"><!---->Git 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/soft-power.html" class="nav-link sidebar-link sidebar-page" aria-label="软实力篇"><!---->软实力篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Redis 篇</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" aria-labelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://github.com/imdtf" target="_blank" rel="noopener noreferrer">DTF</a></span><span property="author" content="DTF"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" aria-labelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年6月8日</span><meta property="datePublished" content="2022-06-08T15:47:48.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" aria-labelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 41 分钟</span><meta property="timeRequired" content="PT41M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_1、为什么要用缓存" class="router-link-active router-link-exact-active toc-link level2">1、为什么要用缓存</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_2、使用-redis-具有那些好处" class="router-link-active router-link-exact-active toc-link level2">2、使用 Redis 具有那些好处？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_3、什么是-redis" class="router-link-active router-link-exact-active toc-link level2">3、什么是 Redis？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_4、为什么使用-redis-而不是用-memcache-呢" class="router-link-active router-link-exact-active toc-link level2">4、为什么使用 Redis 而不是用 Memcache 呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_5、为什么redis单线程模型效率也能那么高" class="router-link-active router-link-exact-active toc-link level2">5、为什么Redis单线程模型效率也能那么高？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_6、说说-redis-的线程模型" class="router-link-active router-link-exact-active toc-link level2">6、说说 Redis 的线程模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_7、为什么-redis-需要把所有数据放到内存中" class="router-link-active router-link-exact-active toc-link level2">7、为什么 Redis 需要把所有数据放到内存中？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_8、redis-的同步机制了解是什么" class="router-link-active router-link-exact-active toc-link level2">8、Redis 的同步机制了解是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_9、pipeline-有什么好处-为什么要用-pipeline" class="router-link-active router-link-exact-active toc-link level2">9、pipeline 有什么好处，为什么要用 pipeline？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_10、说一下-redis-有什么优点和缺点" class="router-link-active router-link-exact-active toc-link level2">10、说一下 Redis 有什么优点和缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_11、redis-缓存刷新策略有哪些" class="router-link-active router-link-exact-active toc-link level2">11、Redis 缓存刷新策略有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_12、redis-持久化方式有哪些-以及有什么区别" class="router-link-active router-link-exact-active toc-link level2">12、Redis 持久化方式有哪些？以及有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_13、持久化有两种-那应该怎么选择呢" class="router-link-active router-link-exact-active toc-link level2">13、持久化有两种，那应该怎么选择呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_14、怎么使用-redis-实现消息队列" class="router-link-active router-link-exact-active toc-link level2">14、怎么使用 Redis 实现消息队列？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_15、说说你对redis事务的理解" class="router-link-active router-link-exact-active toc-link level2">15、说说你对Redis事务的理解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_16、redis-为什么设计成单线程的" class="router-link-active router-link-exact-active toc-link level2">16、Redis 为什么设计成单线程的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_17、什么是-bigkey-会存在什么影响" class="router-link-active router-link-exact-active toc-link level2">17、什么是 bigkey？会存在什么影响？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_18、熟悉哪些-redis-集群模式" class="router-link-active router-link-exact-active toc-link level2">18、熟悉哪些 Redis 集群模式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_19、是否使用过-redis-cluster-集群-集群的原理是什么" class="router-link-active router-link-exact-active toc-link level2">19、是否使用过 Redis Cluster 集群，集群的原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_20、redis-cluster-集群方案什么情况下会导致整个集群不可" class="router-link-active router-link-exact-active toc-link level2">20、Redis Cluster 集群方案什么情况下会导致整个集群不可</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_21、redis-集群架构模式有哪几种" class="router-link-active router-link-exact-active toc-link level2">21、Redis 集群架构模式有哪几种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_22、说说-redis-哈希槽的概念" class="router-link-active router-link-exact-active toc-link level2">22、说说 Redis 哈希槽的概念？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_23、redis-常见性能问题和解决方案有哪些" class="router-link-active router-link-exact-active toc-link level2">23、Redis 常见性能问题和解决方案有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_24、假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" class="router-link-active router-link-exact-active toc-link level2">24、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_25、如果有大量的-key-需要设置同一时间过期-一般需要注意什么" class="router-link-active router-link-exact-active toc-link level2">25、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_26、什么情况下可能会导致-redis-阻塞" class="router-link-active router-link-exact-active toc-link level2">26、什么情况下可能会导致 Redis 阻塞？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_27、缓存和数据库谁先更新呢" class="router-link-active router-link-exact-active toc-link level2">27、缓存和数据库谁先更新呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_28、怎么提高缓存命中率" class="router-link-active router-link-exact-active toc-link level2">28、怎么提高缓存命中率？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_29、redis-如何解决-key-冲突" class="router-link-active router-link-exact-active toc-link level2">29、Redis 如何解决 key 冲突？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_30、redis-报内存不足怎么处理" class="router-link-active router-link-exact-active toc-link level2">30、Redis 报内存不足怎么处理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_31、说说redis持久化机制" class="router-link-active router-link-exact-active toc-link level2">31、说说Redis持久化机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_32、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题" class="router-link-active router-link-exact-active toc-link level2">32、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_33、热点数据和冷数据是什么" class="router-link-active router-link-exact-active toc-link level2">33、热点数据和冷数据是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_34、memcache-与-redis-的区别都有哪些" class="router-link-active router-link-exact-active toc-link level2">34、Memcache 与 Redis 的区别都有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_35、单线程的-redis-为什么这么快" class="router-link-active router-link-exact-active toc-link level2">35、单线程的 Redis 为什么这么快</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_36、redis-的数据类型-以及每种数据类型的使用场景" class="router-link-active router-link-exact-active toc-link level2">36、Redis 的数据类型，以及每种数据类型的使用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_37、redis-的过期策略以及内存淘汰机制" class="router-link-active router-link-exact-active toc-link level2">37、Redis 的过期策略以及内存淘汰机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_38、redis-为什么是单线程的" class="router-link-active router-link-exact-active toc-link level2">38、Redis 为什么是单线程的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_39、redis-常见性能问题和解决方案" class="router-link-active router-link-exact-active toc-link level2">39、Redis 常见性能问题和解决方案？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_40、为什么redis的操作是原子性的-怎么保证原子性的" class="router-link-active router-link-exact-active toc-link level2">40、为什么Redis的操作是原子性的，怎么保证原子性的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_41、了解redis的事务吗" class="router-link-active router-link-exact-active toc-link level2">41、了解Redis的事务吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/Redis.html#_42、redis-的数据类型及使用场景" class="router-link-active router-link-exact-active toc-link level2">42、Redis 的数据类型及使用场景</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h1 id="redis-篇" tabindex="-1"><a class="header-anchor" href="#redis-篇" aria-hidden="true">#</a> Redis 篇</h1><h2 id="_1、为什么要用缓存" tabindex="-1"><a class="header-anchor" href="#_1、为什么要用缓存" aria-hidden="true">#</a> 1、为什么要用缓存</h2><p>使用缓存的目的就是提升读写性能。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，带来更高的并发量。 Redis 的读写性能比 Mysql 好的多，我们就可以把 Mysql 中的热点数据缓存到 Redis 中，提升读取性能，同时也减轻了 Mysql 的读取压力。</p><h2 id="_2、使用-redis-具有那些好处" tabindex="-1"><a class="header-anchor" href="#_2、使用-redis-具有那些好处" aria-hidden="true">#</a> 2、使用 Redis 具有那些好处？</h2><ul><li>读取速度快，因为数据存在内存中，所以数据获取快；</li><li>支持多种数据结构，包括字符串、列表、集合、有序集合、哈希等；</li><li>支持事务，且操作遵守原子性，即对数据的操作要么都执行，要么都不支持；还拥有其他丰富的功能，队列、</li><li>主从复制、集群、数据持久化等功能。</li></ul><h2 id="_3、什么是-redis" tabindex="-1"><a class="header-anchor" href="#_3、什么是-redis" aria-hidden="true">#</a> 3、什么是 Redis？</h2><p>Redis 是一个开源（BSD 许可）、基于内存、支持多种数据结构的存储系统，可以作为数据库、缓存和消息中间件。它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合 （sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（geospatial ）索引半径查询等功能。</p><p>它内置了复制（Replication）、LUA 脚本（Lua scripting）、LRU 驱动事件（LRU eviction）、事务Transactions）和不同级别的磁盘持久化（persistence）功能，并通过 Redis 哨兵（哨兵）和集群（Cluster）保证缓存的高可用性（High availability）。</p><h2 id="_4、为什么使用-redis-而不是用-memcache-呢" tabindex="-1"><a class="header-anchor" href="#_4、为什么使用-redis-而不是用-memcache-呢" aria-hidden="true">#</a> 4、为什么使用 Redis 而不是用 Memcache 呢？</h2><ul><li><p>Redis 和 Memcache 都是将数据存放在内存中，都是内存数据库。不过 Memcache 还可用于缓存其他东西，例如图片、视频等等。</p></li><li><p>Memcache 仅支持 key-value 结构的数据类型，Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，hash 等数据结构的存储。</p></li><li><p>虚拟内存</p><p>Redis 当物理内存用完时，可以将一些很久没用到的 value 交换到磁盘</p></li><li><p>分布式</p><p>设定 Memcache 集群，利用 magent 做一主多从; Redis 可以做一主多从。都可以一主一丛</p></li><li><p>存储数据安全</p><p>Memcache 挂掉后，数据没了； Redis 可以定期保存到磁盘（持久化）</p></li><li><p>Memcache 的单个 value 最大 1m , Redis 的单个 value 最大 512m 。</p></li><li><p>灾难恢复</p><p>Memcache 挂掉后，数据不可恢复; Redis 数据丢失后可以通过 aof 恢复</p></li><li><p>Redis 原生就支持集群模式, Redis3.0版本中，官方便能支持 Cluster 模式了, Memcache 没有原生的集群模式，需要依赖客户端来实现，然后往集群中分片写入数据。</p></li><li><p>Memcached 网络 IO 模型是多线程，非阻塞 IO 复用的网络模型，原型上接近于 nignx 。而 Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现类 epoll，kqueue 和 select ，更接近于 Apache 早期的模式。</p></li></ul><h2 id="_5、为什么redis单线程模型效率也能那么高" tabindex="-1"><a class="header-anchor" href="#_5、为什么redis单线程模型效率也能那么高" aria-hidden="true">#</a> 5、为什么Redis单线程模型效率也能那么高？</h2><ol><li><p>C 语言实现，效率高</p></li><li><p>纯内存操作</p></li><li><p>基于非阻塞的 IO 复用模型机制</p></li><li><p>单线程的话就能避免多线程的频繁上下文切换问题</p></li><li><p>丰富的数据结构（全称采用 hash 结构，读取速度非常快，对数据存储进行了一些优化，比如亚索表，跳表等）</p></li></ol><h2 id="_6、说说-redis-的线程模型" tabindex="-1"><a class="header-anchor" href="#_6、说说-redis-的线程模型" aria-hidden="true">#</a> 6、说说 Redis 的线程模型</h2><p>这问题是因为前面回答问题的时候提到了 Redis 是基于非阻塞的 IO 复用模型。</p><p>Redis 内部使用<strong>文件事件处理器</strong> file event handler ，这个文件事件处理器是<strong>单线程的</strong>，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket ，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ol><li><p>多个 socket 。</p></li><li><p>IO 多路复用程序。</p></li><li><p>文件事件分派器。</p></li><li><p>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。</p></li></ol><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p>来看客户端与 Redis 的一次通信过程：</p><p>// TODO image</p><p>下面来大致说一下这个图：</p><ol><li>客户端 Socket01 向 Redis 的 Server Socket 请求建立连接，此时 Server Socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的Socket01，并将该Socket01的 AE_READABLE 事件与命令请求处理器关联。</li><li>假设此时客户端发送了一个 set key value 请求，此时 Redis 中的会产生 AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面的Socket01的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 Socket01 的 set key value 并在自己内存中完成 set key value 的设置。操作完成后，它会将Socket01的AE_WRITABLE事件与令回复处理器关联。</li><li>如果此时客户端准备好接收返回结果了，那么 Redis 中的Socket01会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对输入本次操作的一个结果，比如 ok ，之后解除的Socket01的AE_WRITABLE 事件与命令回复处理器的关联。</li></ol><p>这样便完成了一次通信。 不要怕这段文字，结合图看，一遍不行两遍，实在不行可以网上查点资料结合着看，一定要搞清楚，否则前面吹的牛逼就白费了。</p><h2 id="_7、为什么-redis-需要把所有数据放到内存中" tabindex="-1"><a class="header-anchor" href="#_7、为什么-redis-需要把所有数据放到内存中" aria-hidden="true">#</a> 7、为什么 Redis 需要把所有数据放到内存中？</h2><p>Redis 将数据放在内存中有一个好处，那就是可以实现最快的对数据读取，如果数据存储在硬盘中，磁盘 I/O 会严重影响 Redis 的性能。而且 Redis 还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响。其次现在硬件越来越便宜的情况下，Redis 的使用也被应用得越来越多，使得它拥有很大的优势。</p><h2 id="_8、redis-的同步机制了解是什么" tabindex="-1"><a class="header-anchor" href="#_8、redis-的同步机制了解是什么" aria-hidden="true">#</a> 8、Redis 的同步机制了解是什么？</h2><p>Redis 支持主从同步、从从同步。如果是第一次进行主从同步，主节点需要使用 bgsave 命令，再将后续修改操作记录到内存的缓冲区，等 RDB 文件全部同步到复制节点，复制节点接受完成后将 RDB 镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。</p><h2 id="_9、pipeline-有什么好处-为什么要用-pipeline" tabindex="-1"><a class="header-anchor" href="#_9、pipeline-有什么好处-为什么要用-pipeline" aria-hidden="true">#</a> 9、pipeline 有什么好处，为什么要用 pipeline？</h2><p>使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系。</p><p>用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。</p><h2 id="_10、说一下-redis-有什么优点和缺点" tabindex="-1"><a class="header-anchor" href="#_10、说一下-redis-有什么优点和缺点" aria-hidden="true">#</a> 10、说一下 Redis 有什么优点和缺点</h2><ul><li><p>优点</p><ul><li>速度快：因为数据存在内存中，类似于 HashMap , HashMap 的优势就是查找和操作的时间复杂度都是 O (1) 。</li><li>支持丰富的数据结构：支持 String ，List，Set，Sorted Set，Hash 五种基础的数据结构。</li><li>持久化存储：Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉</li><li>高可用：内置 Redis Sentinel ，提供高可用方案，实现主从故障自动转移。 内置 Redis Cluster ，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。</li><li>丰富的特性：Key 过期、计数、分布式锁、消息队列等。</li></ul></li><li><p>缺点</p><ul><li>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</li><li>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis 2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</li><li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中, Redis 不能提供服务。</li></ul></li></ul><h2 id="_11、redis-缓存刷新策略有哪些" tabindex="-1"><a class="header-anchor" href="#_11、redis-缓存刷新策略有哪些" aria-hidden="true">#</a> 11、Redis 缓存刷新策略有哪些？</h2><h2 id="_12、redis-持久化方式有哪些-以及有什么区别" tabindex="-1"><a class="header-anchor" href="#_12、redis-持久化方式有哪些-以及有什么区别" aria-hidden="true">#</a> 12、Redis 持久化方式有哪些？以及有什么区别？</h2><p>Redis 提供两种持久化机制 RDB 和 AOF 机制:</p><ul><li><p><strong>RDB 持久化方式</strong> 是指用数据集快照的方式半持久化模式)记录 Redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p><ul><li><p>优点：</p><ol><li>只有一个dump.rdb文件 , 方便持久化 。</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能)</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ol></li><li><p>缺点： 数据安全性低。 RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</p></li></ul></li><li><p><strong>AOF=Append-only file 持久化方式</strong></p><p>是指所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储，保存为 AOF 文件。</p><ul><li><strong>优点：</strong><ol><li>数据安全, AOF 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 AOF 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 Redis-check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 rewrite 模式。 AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall)</li></ol></li><li>缺点： <ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 RDB 启动效率低。</li></ol></li></ul></li></ul><h2 id="_13、持久化有两种-那应该怎么选择呢" tabindex="-1"><a class="header-anchor" href="#_13、持久化有两种-那应该怎么选择呢" aria-hidden="true">#</a> 13、持久化有两种，那应该怎么选择呢？</h2><ol><li>不要仅仅使用 RDB ，因为那样会导致你丢失很多数据。</li><li>也不要仅仅使用 AOF ，因为那样有两个问题，第一，你通过 AOF 做冷备没有 RDB 做冷备的恢复速度更快; 第二, RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</li><li>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</li><li>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。 Redis</li></ol><h2 id="_14、怎么使用-redis-实现消息队列" tabindex="-1"><a class="header-anchor" href="#_14、怎么使用-redis-实现消息队列" aria-hidden="true">#</a> 14、怎么使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列, rpush 生产消息, lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p><ul><li>面试官可能会问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</li><li>面试官可能还问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</li><li>面试官可能还问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</li><li>面试官可能还问 Redis 如何<strong>实现延时队列</strong>？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li><li>很多面试官上来就直接这么问： Redis 如何实现延时队列？</li></ul><h2 id="_15、说说你对redis事务的理解" tabindex="-1"><a class="header-anchor" href="#_15、说说你对redis事务的理解" aria-hidden="true">#</a> 15、说说你对Redis事务的理解</h2><ul><li><p>什么是 Redis 事务？原理是什么？</p><p>Redis 中的事务是一组命令的集合，是 Redis 的最小执行单位。它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。</p><p>它的原理是先将属于一个事务的命令发送给 Redis，然后依次执行这些命令。</p></li><li><p>Redis 事务的注意点有哪些？</p><ul><li>Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；</li><li>Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。</li></ul></li><li><p>Redis 事务为什么不支持回滚？</p><p>Redis 的事务不支持回滚，但是执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。</p></li></ul><h2 id="_16、redis-为什么设计成单线程的" tabindex="-1"><a class="header-anchor" href="#_16、redis-为什么设计成单线程的" aria-hidden="true">#</a> 16、Redis 为什么设计成单线程的？</h2><p>多线程处理会涉及到锁，并且多线程处理会涉及到线程切···换而消耗 CPU。采用单线程，避免了不必要的上下文切换和竞争条件。其次 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。</p><h2 id="_17、什么是-bigkey-会存在什么影响" tabindex="-1"><a class="header-anchor" href="#_17、什么是-bigkey-会存在什么影响" aria-hidden="true">#</a> 17、什么是 bigkey？会存在什么影响？</h2><p>bigkey 是指键值占用内存空间非常大的 key。例如一个字符串 a 存储了 200M 的数据。</p><p>bigkey 的主要影响有：</p><ul><li>网络阻塞；获取 bigkey 时，传输的数据量比较大，会增加带宽的压力。</li><li>超时阻塞；因为 bigkey 占用的空间比较大，所以操作起来效率会比较低，导致出现阻塞的可能性增加。</li><li>导致内存空间不平衡；一个 bigkey 存储数据量比较大，同一个 key 在同一个节点或服务器中存储，会造成一定影响。</li></ul><h2 id="_18、熟悉哪些-redis-集群模式" tabindex="-1"><a class="header-anchor" href="#_18、熟悉哪些-redis-集群模式" aria-hidden="true">#</a> 18、熟悉哪些 Redis 集群模式？</h2><ul><li><p>Redis Sentinel</p><p>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</p></li><li><p>Redis Cluster Redis 官方提供的集群化方案，体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p></li><li><p>Twemprox</p><p>Twemprox 是 Twtter 开源的一个 Redis 和 Memcached 代理服务器，主要用于管理 Redis 和 Memcached 集群，减少与 Cache 服务器直接连接的数量。</p></li><li><p>Codis</p><p>Codis 是一个代理中间件，当客户端向 Codis 发送指令时, Codis 负责将指令转发到后面的 Redis 来执行，并将结果返回给客户端。一个 Codis 实例可以连接多个 Redis 实例，也可以启动多个 Codis 实例来支撑，每个 Codis 节点都是对等的，这样可以增加整体的 QPS 需求，还能起到容灾功能。</p></li><li><p>客户端分片</p><p>在 Redis Cluster 还没出现之前使用较多，现在基本很少热你使用了，在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p></li></ul><h2 id="_19、是否使用过-redis-cluster-集群-集群的原理是什么" tabindex="-1"><a class="header-anchor" href="#_19、是否使用过-redis-cluster-集群-集群的原理是什么" aria-hidden="true">#</a> 19、是否使用过 Redis Cluster 集群，集群的原理是什么？</h2><ul><li>所有的节点相互连接</li><li>集群消息通信通过集群总线通信，集群总线端口大小为客户端服务端口 + 10000（固定值）</li><li>节点与节点之间通过二进制协议进行通信</li><li>客户端和集群节点之间通信和通常一样，通过文本协议进行</li><li>集群节点不会代理查询</li><li>数据按照 Slot 存储分布在多个 Redis 实例上</li><li>集群节点挂掉会自动故障转移</li><li>可以相对平滑扩/缩容节点</li></ul><p>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，Redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0~16383 之间的哈希槽，Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。</p><h2 id="_20、redis-cluster-集群方案什么情况下会导致整个集群不可" tabindex="-1"><a class="header-anchor" href="#_20、redis-cluster-集群方案什么情况下会导致整个集群不可" aria-hidden="true">#</a> 20、Redis Cluster 集群方案什么情况下会导致整个集群不可</h2><p>Redis 没有使用哈希一致性算法，而是使用哈希槽。Redis 中的哈希槽一共有 16384 个，计算给定密钥的哈希槽，我们只需要对密钥的 CRC16 取摸 16384。假设集群中有 A、B、C 三个集群节点，不存在复制模式下，每个集群的节点包含的哈希槽如下：</p><ul><li>节点 A 包含从 0 到 5500 的哈希槽；</li><li>节点 B 包含从 5501 到 11000 的哈希槽；</li><li>节点 C 包含从 11001 到 16383 的哈希槽；</li></ul><p>这时，如果节点 B 出现故障，整个集群就会出现缺少 5501 到 11000 的哈希槽范围而不可用。</p><h2 id="_21、redis-集群架构模式有哪几种" tabindex="-1"><a class="header-anchor" href="#_21、redis-集群架构模式有哪几种" aria-hidden="true">#</a> 21、Redis 集群架构模式有哪几种？</h2><p>Redis 集群架构是支持单节点单机模式的，也支持一主多从的主从结构，还支持带有哨兵的集群部署模式。</p><h2 id="_22、说说-redis-哈希槽的概念" tabindex="-1"><a class="header-anchor" href="#_22、说说-redis-哈希槽的概念" aria-hidden="true">#</a> 22、说说 Redis 哈希槽的概念？</h2><p>Redis 集群并没有使用一致性 hash，而是引入了哈希槽的概念。Redis 集群有 16384（2^14）个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><h2 id="_23、redis-常见性能问题和解决方案有哪些" tabindex="-1"><a class="header-anchor" href="#_23、redis-常见性能问题和解决方案有哪些" aria-hidden="true">#</a> 23、Redis 常见性能问题和解决方案有哪些？</h2><p>Redis 常见性能问题和解决方案如下：</p><ul><li>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件；</li><li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次；</li><li>为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内；</li><li>尽量避免在压力很大的主库上增加从库；</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3….；这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。</li></ul><h2 id="_24、假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" tabindex="-1"><a class="header-anchor" href="#_24、假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" aria-hidden="true">#</a> 24、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>我们可以使用 keys 命令和 scan 命令，但是会发现使用 scan 更好。</p><ul><li><p>使用 <strong>keys</strong> 命令</p><p>直接使用 keys 命令查询，但是如果是在生产环境下使用会出现一个问题，keys 命令是遍历查询的，查询的时间复杂度为 O(n)，数据量越大查询时间越长。而且 Redis 是单线程，keys 指令会导致线程阻塞一段时间，会导致线上 Redis 停顿一段时间，直到 keys 执行完毕才能恢复。这在生产环境是不允许的。除此之外，需要注意的是，这个命令没有分页功能，会一次性查询出所有符合条件的 key 值，会发现查询结果非常大，输出的信息非常多。所以不推荐使用这个命令。</p></li><li><p>使用 <strong>scan</strong> 命令</p><p>scan 命令可以实现和 keys 一样的匹配功能，但是 scan 命令在执行的过程不会阻塞线程，并且查找的数据可能存在重复，需要客户端操作去重。因为 scan 是通过游标方式查询的，所以不会导致 Redis 出现假死的问题。Redis 查询过程中会把游标返回给客户端，单次返回空值且游标不为 0，则说明遍历还没结束，客户端继续遍历查询。scan 在检索的过程中，被删除的元素是不会被查询出来的，但是如果在迭代过程中有元素被修改，scan 不能保证查询出对应元素。相对来说，scan 指令查找花费的时间会比 keys 指令长。</p></li></ul><h2 id="_25、如果有大量的-key-需要设置同一时间过期-一般需要注意什么" tabindex="-1"><a class="header-anchor" href="#_25、如果有大量的-key-需要设置同一时间过期-一般需要注意什么" aria-hidden="true">#</a> 25、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果有大量的 key 在同一时间过期，那么可能同一秒都从数据库获取数据，给数据库造成很大的压力，导致数据库崩溃，系统出现 502 问题。也有可能同时失效，那一刻不用都访问数据库，压力不够大的话，那么 Redis 会出现短暂的卡顿问题。所以为了预防这种问题的发生，最好给数据的过期时间加一个随机值，让过期时间更加分散。</p><h2 id="_26、什么情况下可能会导致-redis-阻塞" tabindex="-1"><a class="header-anchor" href="#_26、什么情况下可能会导致-redis-阻塞" aria-hidden="true">#</a> 26、什么情况下可能会导致 Redis 阻塞？</h2><p>Redis 产生阻塞的原因主要有内部和外部两个原因导致：</p><ul><li><strong>内部原因</strong><ul><li>如果 Redis 主机的 CPU 负载过高，也会导致系统崩溃；</li><li>数据持久化占用资源过多；</li><li>对 Redis 的 API 或指令使用不合理，导致 Redis 出现问题。</li></ul></li><li><strong>外部原因</strong> 外部原因主要是服务器的原因，例如服务器的 CPU 线程在切换过程中竞争过大，内存出现问题、网络问题等。</li></ul><h2 id="_27、缓存和数据库谁先更新呢" tabindex="-1"><a class="header-anchor" href="#_27、缓存和数据库谁先更新呢" aria-hidden="true">#</a> 27、缓存和数据库谁先更新呢？</h2><p><strong>解决方案</strong></p><ol><li>写请求过来，将写请求缓存到缓存队列中，并且开始执行写请求的具体操作（删除缓存中的数据，更新数据库，更新缓存）。</li><li>如果在更新数据库过程中，又来了个读请求，将读请求再次存入到缓存队列（可以搞 n 个队列，采用 key 的 hash 值进行队列个数取模 hash%n，落到对应的队列中，队列需要保证顺序性）中，顺序性保证等待队列前的写请求执行完成，才会执行读请求之前的写请求删除缓存失败，直接返回，此时数据库中的数据是旧值，并且与缓存中的数据是一致的，不会出现缓存一致性的问题。</li><li>写请求删除缓存成功，则更新数据库，如果更新数据库失败，则直接返回，写请求结束，此时数据库中的值依旧是旧值，读请求过来后，发现缓存中没有数据, 则会直接向数据库中请求，同时将数据写入到缓存中，此时也不会出现数据一致性的问题。</li><li>更新数据成功之后，再更新缓存，如果此时更新缓存失败，则缓存中没有数据，数据库中是新值 ，写请求结束，此时读请求还是一样，发现缓存中没有数据，同样会从数据库中读取数据，并且存入到缓存中，其实这里不管更新缓存成功还是失败, 都不会出现数据一致性的问题。 上面这方案解决了数据不一致的问题，主要是使用了串行化，每次操作进来必须按照顺序进行。如果某个队列元素积压太多，可以针对读请求进行过滤，提示用户刷新页面，重新请求。</li></ol><ul><li><p><strong>潜在的问题</strong></p><p>留给大家自己去想吧，因为这个问题属于发散性。</p><ol><li>请求时间过长，大量的写请求堆压在队列中，一个读请求来得等都写完了才可以获取到数据。</li><li>读请求并发高</li><li>热点数据路由问题，导致请求倾斜。</li></ol></li></ul><h2 id="_28、怎么提高缓存命中率" tabindex="-1"><a class="header-anchor" href="#_28、怎么提高缓存命中率" aria-hidden="true">#</a> 28、怎么提高缓存命中率？</h2><p>主要常用的手段有：</p><ul><li>提前加载数据到缓存中；</li><li>增加缓存的存储空间，提高缓存的数据；</li><li>调整缓存的存储数据类型；</li><li>提升缓存的更新频率。</li></ul><h2 id="_29、redis-如何解决-key-冲突" tabindex="-1"><a class="header-anchor" href="#_29、redis-如何解决-key-冲突" aria-hidden="true">#</a> 29、Redis 如何解决 key 冲突？</h2><p>Redis 如果 key 相同，后一个 key 会覆盖前一个 key。如果要解决 key 冲突，最好给 key 取好名区分开，可以按业务名和参数区分开取名，避免重复 key 导致的冲突。</p><h2 id="_30、redis-报内存不足怎么处理" tabindex="-1"><a class="header-anchor" href="#_30、redis-报内存不足怎么处理" aria-hidden="true">#</a> 30、Redis 报内存不足怎么处理？</h2><p>Redis 内存不足可以这样处理：</p><ul><li>修改配置文件 Redis.conf 的 maxmemory 参数，增加 Redis 可用内存；</li><li>设置缓存淘汰策略，提高内存的使用效率；</li><li>使用 Redis 集群模式，提高存储量。</li></ul><h2 id="_31、说说redis持久化机制" tabindex="-1"><a class="header-anchor" href="#_31、说说redis持久化机制" aria-hidden="true">#</a> 31、说说Redis持久化机制</h2><p>Redis 是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当 Redis 重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。 实现：单独创建 fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p><p>RDB 是 Redis 默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即 Snapshot 快照存储，对应产生的数据文件为 dump.rdb，通过配置文件中的 save 参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。） AOF：Redis 会将每一个收到的写命令都通过 Write 函数追加到文件最后，类似于 MySQL 的 binlog。当 Redis 重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 当两种方式同时开启时，数据恢复 Redis 会优先选择 AOF 恢复。</p><h2 id="_32、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题" tabindex="-1"><a class="header-anchor" href="#_32、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题" aria-hidden="true">#</a> 32、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</h2><ul><li><p><strong>缓存雪崩</strong></p><p>我们可以简单的理解为：由于原有缓存失效，新缓存未到期间 (例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。 <strong>解决办法：</strong> 大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</p></li><li><p><strong>缓存穿透</strong></p><ul><li><p>描述</p><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p></li><li><p>解决办法:</p><p>最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。 另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这 种办法最简单粗暴。 5TB 的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些 32bit 大小的数据该如何解决？如果是 64bit 的呢？</p><p>对于空间的利用到达了一种极致，那就是 Bitmap 和布隆过滤器(Bloom Filter)。 Bitmap： 典型的就是哈希表缺点是，Bitmap 对于每个元素只能记录 1bit 信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p><p><strong>布隆过滤器（推荐）</strong> 就是引入了 k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 Bloom-Filter 算法的核心思想就是利用多个不同的 Hash 函数来解决“冲突”。 Hash 存在一个冲突（碰撞）的问题，用同一个 Hash 得到的两个 URL 的值有可能相同。为了减少冲突，我们可以多引入几个 Hash，如果通过其中的一个 Hash 值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的 Hash 函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是 Bloom-Filter 的基本思想。 Bloom-Filter 一般用于在大数据量的集合中判定某元素是否存在。</p></li></ul></li><li><p><strong>缓存预热</strong></p><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决思路：</p><ol><li>直接写个缓存刷新页面，上线时手工操作下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存；</li></ol></li><li><p><strong>缓存更新</strong></p><p>除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><ol><li>定时去清理过期的缓存；</li><li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</li></ol></li><li><p><strong>缓存降级</strong></p><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>以参考日志级别设置预案：</p><ol><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在 95~100%之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于 90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ol><p>服务降级的目的，是为了防止 Redis 服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis 出现问题，不去数据库查询，而是直接返回默认值给用户。</p></li></ul><h2 id="_33、热点数据和冷数据是什么" tabindex="-1"><a class="header-anchor" href="#_33、热点数据和冷数据是什么" aria-hidden="true">#</a> 33、热点数据和冷数据是什么</h2><p><strong>热点数据，缓存才有价值</strong></p><p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。 对于热点数据，比如我们的某 IM 产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。</p><p><strong>数据更新前至少读取两次</strong> ,缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。 那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到 Redis 缓存，减少数据库压力。</p><h2 id="_34、memcache-与-redis-的区别都有哪些" tabindex="-1"><a class="header-anchor" href="#_34、memcache-与-redis-的区别都有哪些" aria-hidden="true">#</a> 34、Memcache 与 Redis 的区别都有哪些？</h2><ol><li>存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis 有部份存在硬盘上，Redis 可以持久化其数据</li><li>数据支持类型 memcached 所有的值均是简单的字符串，Redis 作为其替代者，支持更为丰富的数据类型 ，提供 list，set，zset，hash 等数据结构的存储</li><li>使用底层模型不同它们之间底层实现方式以及与客户端之间通信的应用协议不一 样。 Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。</li><li>Redis 的速度比 memcached 快很多</li><li>Redis 支持数据的备份，即 master-slave 模式的数据备份。</li></ol><h2 id="_35、单线程的-redis-为什么这么快" tabindex="-1"><a class="header-anchor" href="#_35、单线程的-redis-为什么这么快" aria-hidden="true">#</a> 35、单线程的 Redis 为什么这么快</h2><ol><li>纯内存操作</li><li>单线程操作，避免了频繁的上下文切换</li><li>采用了非阻塞 I/O 多路复用机制</li></ol><h2 id="_36、redis-的数据类型-以及每种数据类型的使用场景" tabindex="-1"><a class="header-anchor" href="#_36、redis-的数据类型-以及每种数据类型的使用场景" aria-hidden="true">#</a> 36、Redis 的数据类型，以及每种数据类型的使用场景</h2><ul><li><p>String</p><p>这个其实没啥好说的，最常规的 set/get 操作，value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。</p></li><li><p>hash</p><p>这里 value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以 cookieId 作为 key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 session 的效果。</p></li><li><p>list</p><p>List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST 可以很好的完成排队，先进先出的原则。</p></li><li><p>set</p><p>因为 set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用 JVM 自带的 Set 进行去重？因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p></li><li><p>sorted set</p><p>sorted set 多了一个权重参数 score,集合中的元素能够按 score 进行排列。可以做排行榜应用，取 TOP N 操作。</p></li></ul><h2 id="_37、redis-的过期策略以及内存淘汰机制" tabindex="-1"><a class="header-anchor" href="#_37、redis-的过期策略以及内存淘汰机制" aria-hidden="true">#</a> 37、Redis 的过期策略以及内存淘汰机制</h2><p>Redis 采用的是<strong>定期删除</strong> +<strong>惰性删除策略</strong> 。</p><ul><li><p>为什么不用定时删除策略?</p><p>定时删除,用一个定时器来负责监视 key,过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 key,因此没有采用这一策略.</p></li><li><p>定期删除+惰性删除是如何工作的呢?</p><p>定期删除，Redis 默认每个 100ms 检查，是否有过期的 key,有过期 key 则删除。需要说明的是， Redis 不是每个 100ms 将所有的 key 检查一次，而是随机抽取进行检查(如果每隔 100ms,全部 key 进行检查，Redis 岂不是卡死)。因此，如果只采用定期删除策略，会导致很多 key 到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个 key 的时候，Redis 会检查一下，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 采用定期删除+惰性删除就没其他问题了么?不是的，如果定期删除没删除 key。然后你也没即时去请求 key，也就是说惰性删除也没生效。这样，Redis 的内存会越来越高。那么就应该采用内存淘汰机制。 在 Redis.conf 中有一行配置</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>maxmemory-policy volatile-lru
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</p><ul><li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru</strong>：从数据集 （server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-enviction</strong>（驱逐）：禁止驱逐数据，新写入操作会报错</li></ul><p>ps：如果没有设置 expire 的 key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p></li></ul><h2 id="_38、redis-为什么是单线程的" tabindex="-1"><a class="header-anchor" href="#_38、redis-为什么是单线程的" aria-hidden="true">#</a> 38、Redis 为什么是单线程的</h2><p>官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis 利用队列技术将并发访问变为串行访问 1）绝大部分请求是纯粹的内存操作（非常快速）2）采用单线程,避免了不必要的上下文切换和竞争条件 3）非阻塞 IO 优点：</p><ul><li>速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)</li><li>支持丰富数据类型，支持 string，list，set，sorted set，hash</li><li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除如何解决 Redis 的并发竞争 key 问题</li></ul><p>同时有多个子系统去 set 一个 key。这个时候要注意什么呢？</p><p>不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。你一个事务中有涉及到多个 key 操作的时候，这多个 key 不一定都存储在同一个 Redis-server 上。因此，Redis 的事务机制，十分鸡肋。</p><ol><li>如果对这个 key 操作，不要求顺序： 准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可</li><li>如果对这个 key 操作，要求顺序： 分布式锁+时间戳。 假设这会系统 B 先抢到锁，将 key1 设置为 {valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了。以此类推。</li><li>利用队列，将 set 方法变成串行访问也可以 Redis 遇到高并发，如果保证读写 key 的一致性对 Redis 的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,Redis 内部已经帮你处理好并发的问题了。</li></ol><h2 id="_39、redis-常见性能问题和解决方案" tabindex="-1"><a class="header-anchor" href="#_39、redis-常见性能问题和解决方案" aria-hidden="true">#</a> 39、Redis 常见性能问题和解决方案？</h2><p>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件 (2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次 (3) 为了主从复制的速度和连接的稳定性, Master 和 Slave 最好在同一个局域网内 (4) 尽量避免在压力很大的主库上增加从库 (5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master &lt;- Slave1 &lt;- Slave2 &lt;-Slave3…</p><h2 id="_40、为什么redis的操作是原子性的-怎么保证原子性的" tabindex="-1"><a class="header-anchor" href="#_40、为什么redis的操作是原子性的-怎么保证原子性的" aria-hidden="true">#</a> 40、为什么Redis的操作是原子性的，怎么保证原子性的？</h2><p>对于 Redis 而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。 Redis 的操作之所以是原子性的，是因为 Redis 是单线程的。 Redis 本身提供的所有 API 都是原子操作，Redis 中的事务其实是要保证批量操作的原子性。 多个命令在并发中也是原子性的吗？ 不一定, 将 get 和 set 改成单命令操作，incr 。使用 Redis 的事务，或者使用 Redis+Lua==的方式实现.</p><h2 id="_41、了解redis的事务吗" tabindex="-1"><a class="header-anchor" href="#_41、了解redis的事务吗" aria-hidden="true">#</a> 41、了解Redis的事务吗？</h2><p>Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的 Redis 会将一个事务中的所有命令序列化，然后按顺序执行。 1.Redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”, 所以 Redis 的内部可以保持简单且快速。 2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 3.如果在一个事务中出现运行错误，那么正确的命令会被执行。</p><ol><li>MULTI 命令用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。</li><li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</li><li>通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务, 并且客户端会从事务状态中退出。</li><li>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令。</li></ol><h2 id="_42、redis-的数据类型及使用场景" tabindex="-1"><a class="header-anchor" href="#_42、redis-的数据类型及使用场景" aria-hidden="true">#</a> 42、Redis 的数据类型及使用场景</h2><ul><li>String 最常规的 set/get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。</li><li>Hash 这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。</li><li>List 使用 List 的数据结构，可以做简单的消息队列的功能。另外，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。</li><li>Set 因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。我们的系统一般都是集群部署，使用 JVM 自带的 Set 比较麻烦。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</li><li>Sorted Set Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP(N) 操作。Sorted Set 可以用来做延时任务。</li></ul><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/imdtf/blog/edit/main/docs/interview/Redis.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" aria-labelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/6/8 23:47:48</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: imdtf@qq.com">DTF</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/interview/zookeeper.html" class="nav-link prev" aria-label="Zookeeper 篇"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->Zookeeper 篇</div></a><a href="/interview/%E5%88%86%E5%B8%83%E5%BC%8F.html" class="nav-link next" aria-label="分布式篇"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">分布式篇<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2022 DTF</div></footer><!--]--></div><!--]--><!----><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewbox="0 0 1024 1024" aria-labelledby="close"><title id="close" lang="en">close icon</title><g fill="currentColor"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></g></svg></button><div class="logo"><!----><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!----><!----></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button class="install-button">安装<span></span></button><button class="cancel-button">取消</button></div></div></div></div><!--]--></div>
    <script type="module" src="/assets/app.597ce2f2.js" defer></script>
  </body>
</html>
