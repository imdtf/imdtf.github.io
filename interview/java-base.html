<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.43" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-v2-demo.mrhope.site/interview/java-base.html"><meta property="og:site_name" content="DTF's blog"><meta property="og:title" content="基础篇"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-05-17T15:50:18.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-05-17T15:50:18.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>基础篇 | DTF's blog</title><meta name="description" content="我的学习记录博客">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.af58f80f.css">
    <link rel="modulepreload" href="/assets/app.597ce2f2.js"><link rel="modulepreload" href="/assets/java-base.html.f9b49957.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/java-base.html.db5311da.js"><link rel="prefetch" href="/assets/index.html.e173ef83.js"><link rel="prefetch" href="/assets/ElasticSearch.html.279e5d7b.js"><link rel="prefetch" href="/assets/MQ.html.9d040945.js"><link rel="prefetch" href="/assets/MySQL.html.d1ae2d1e.js"><link rel="prefetch" href="/assets/Redis.html.b201ad05.js"><link rel="prefetch" href="/assets/design-patterns.html.733535fa.js"><link rel="prefetch" href="/assets/dubbo.html.c776d990.js"><link rel="prefetch" href="/assets/git.html.72b47aa0.js"><link rel="prefetch" href="/assets/jvm.html.53d34a5d.js"><link rel="prefetch" href="/assets/linux.html.65017b81.js"><link rel="prefetch" href="/assets/maven.html.ceec6571.js"><link rel="prefetch" href="/assets/multi-thread.html.3652cc7f.js"><link rel="prefetch" href="/assets/mybatis.html.cb44fe5a.js"><link rel="prefetch" href="/assets/network.html.b1609fd9.js"><link rel="prefetch" href="/assets/nginx.html.9ca67d3a.js"><link rel="prefetch" href="/assets/soft-power.html.508fb44f.js"><link rel="prefetch" href="/assets/spring-boot.html.e888e4e7.js"><link rel="prefetch" href="/assets/spring-cloud.html.57c2b0d4.js"><link rel="prefetch" href="/assets/spring.html.94b261f5.js"><link rel="prefetch" href="/assets/tomcat.html.dc4aea03.js"><link rel="prefetch" href="/assets/zookeeper.html.75896320.js"><link rel="prefetch" href="/assets/分布式.html.6e369ff9.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.58f6dba8.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.04b85b76.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.116abb6a.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.1d83f138.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.40f6f1e4.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.900bda42.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.3492d336.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.dcc88998.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.7239f150.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.6199feb4.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.57624587.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.d99caa1b.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.cabd308f.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.c89015fe.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.6b8e9ff0.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.e1e4da4a.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.697b9a23.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.9000e742.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.4d12fb46.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.48d80708.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.da9eab5a.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.95150d1c.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.b9bda91b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.bb805e63.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.514eb232.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.4cfc99f3.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.1561ec1a.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.11ef8b3e.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.ef765715.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.50f4f1d6.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.60a1c908.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.b6c6ee60.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.0fa73bd5.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.bfe213be.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.e0558584.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.3087bc74.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.c5df5f6e.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.b9edc687.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.9906de00.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.4b8670c8.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.b78f67d4.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b762f081.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.e5ec66c1.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.f9b4c2c6.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.d4daa082.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.1f616fc4.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.25fe22f4.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.8bb53047.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.63f53d07.js"><link rel="prefetch" href="/assets/00-Introduction.html.aed5c856.js"><link rel="prefetch" href="/assets/00-Preface.html.feee9db3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.ab6ea8b6.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.0224a9bf.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.bea55af9.js"><link rel="prefetch" href="/assets/04-Operators.html.35525abf.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.c4cd86f5.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.b5c2b268.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.399ae58f.js"><link rel="prefetch" href="/assets/08-Reuse.html.0ab07e65.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.89443cf5.js"><link rel="prefetch" href="/assets/10-Interfaces.html.4948bb7b.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.b8f6a196.js"><link rel="prefetch" href="/assets/12-Collections.html.52f2a06b.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.db50a84d.js"><link rel="prefetch" href="/assets/14-Streams.html.9308751d.js"><link rel="prefetch" href="/assets/15-Exceptions.html.40e68d98.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.3edda5f0.js"><link rel="prefetch" href="/assets/17-Files.html.e87e7c99.js"><link rel="prefetch" href="/assets/18-Strings.html.a2842b17.js"><link rel="prefetch" href="/assets/19-Type-Information.html.12cc605b.js"><link rel="prefetch" href="/assets/20-Generics.html.3e4b17f6.js"><link rel="prefetch" href="/assets/21-Arrays.html.67720723.js"><link rel="prefetch" href="/assets/22-Enumerations.html.ab50f89b.js"><link rel="prefetch" href="/assets/23-Annotations.html.747faef3.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.5b9841aa.js"><link rel="prefetch" href="/assets/25-Patterns.html.10af6fe7.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.13f6de18.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.4774ac79.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.fec6d369.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.fe3a1870.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.35950f4f.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.54af4f5f.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.bb07240e.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.8f39ad15.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.39836314.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.ee52b83c.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.68302b50.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.9b5edd63.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.c8a5f6e1.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.34dcd815.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.8c0a6980.js"><link rel="prefetch" href="/assets/GLOSSARY.html.af317d6f.js"><link rel="prefetch" href="/assets/index.html.859506fe.js"><link rel="prefetch" href="/assets/404.html.61bcede7.js"><link rel="prefetch" href="/assets/index.html.6eefb2c9.js"><link rel="prefetch" href="/assets/index.html.276bb6b8.js"><link rel="prefetch" href="/assets/index.html.6c49b0c9.js"><link rel="prefetch" href="/assets/index.html.938faca6.js"><link rel="prefetch" href="/assets/index.html.234dfb8d.js"><link rel="prefetch" href="/assets/index.html.02cffa46.js"><link rel="prefetch" href="/assets/index.html.c70b19c7.js"><link rel="prefetch" href="/assets/index.html.e9ae5772.js"><link rel="prefetch" href="/assets/index.html.43ef8dd6.js"><link rel="prefetch" href="/assets/index.html.0319d1c3.js"><link rel="prefetch" href="/assets/ElasticSearch.html.1822d360.js"><link rel="prefetch" href="/assets/MQ.html.257a1eec.js"><link rel="prefetch" href="/assets/MySQL.html.12265bed.js"><link rel="prefetch" href="/assets/Redis.html.c5915ac6.js"><link rel="prefetch" href="/assets/design-patterns.html.4dff82bc.js"><link rel="prefetch" href="/assets/dubbo.html.70900b5c.js"><link rel="prefetch" href="/assets/git.html.9f0ce8a6.js"><link rel="prefetch" href="/assets/jvm.html.7b42d915.js"><link rel="prefetch" href="/assets/linux.html.9f1e7d55.js"><link rel="prefetch" href="/assets/maven.html.f848fc43.js"><link rel="prefetch" href="/assets/multi-thread.html.5d323dfe.js"><link rel="prefetch" href="/assets/mybatis.html.868f5463.js"><link rel="prefetch" href="/assets/network.html.347740e9.js"><link rel="prefetch" href="/assets/nginx.html.acf44958.js"><link rel="prefetch" href="/assets/soft-power.html.fa4cc2bb.js"><link rel="prefetch" href="/assets/spring-boot.html.eb446c44.js"><link rel="prefetch" href="/assets/spring-cloud.html.5a2e7953.js"><link rel="prefetch" href="/assets/spring.html.e5d334fa.js"><link rel="prefetch" href="/assets/tomcat.html.1edb1280.js"><link rel="prefetch" href="/assets/zookeeper.html.d47f6f3b.js"><link rel="prefetch" href="/assets/分布式.html.8362b544.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.e0b3e691.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.73dedd46.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.a7a61510.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.19af1cfc.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.078c9131.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.3da35573.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.ee1e2ba2.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.5796a618.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.26f3a028.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.cbc4b5ad.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.d79a5425.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.8dab2c77.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.f8e03fcd.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.f1c1f80f.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.a0b4da7e.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.8cf5825d.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.63173a34.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.a51cc121.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.55632279.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.aa190da2.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.c311f962.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.bef20aad.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.54dcb84b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.baae2fb3.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.de07d445.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.d8703177.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.93feb431.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.14ad8743.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.2e4d7d89.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.ebe6ec2f.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.a1a0d482.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.7353d51d.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.b546fd0e.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.fa14f195.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.ddaebd47.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.9f503937.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.95f81089.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.354471cd.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.c9d4ab47.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.9b369837.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.93069f29.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b6a68508.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.4cda471b.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.fec20cbf.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.46eb93f8.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.70884000.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.16cc56b7.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.0f6a9d34.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.ced5f781.js"><link rel="prefetch" href="/assets/00-Introduction.html.2b1f0852.js"><link rel="prefetch" href="/assets/00-Preface.html.e516d7c3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.86c4af1e.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.88cddd12.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.4da53003.js"><link rel="prefetch" href="/assets/04-Operators.html.f9d313c6.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.ecf81ffe.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.c35ecf1b.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.396e0a6f.js"><link rel="prefetch" href="/assets/08-Reuse.html.8c7c4047.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.2150cc57.js"><link rel="prefetch" href="/assets/10-Interfaces.html.6ee853fa.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.ae7b89c4.js"><link rel="prefetch" href="/assets/12-Collections.html.0483e4dd.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.63412e72.js"><link rel="prefetch" href="/assets/14-Streams.html.7e7cce42.js"><link rel="prefetch" href="/assets/15-Exceptions.html.c186f23a.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.b3313ffc.js"><link rel="prefetch" href="/assets/17-Files.html.7a9ad498.js"><link rel="prefetch" href="/assets/18-Strings.html.46e57539.js"><link rel="prefetch" href="/assets/19-Type-Information.html.b68894bf.js"><link rel="prefetch" href="/assets/20-Generics.html.3993804b.js"><link rel="prefetch" href="/assets/21-Arrays.html.4d150e5c.js"><link rel="prefetch" href="/assets/22-Enumerations.html.87d060f0.js"><link rel="prefetch" href="/assets/23-Annotations.html.0c455464.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.8485a02c.js"><link rel="prefetch" href="/assets/25-Patterns.html.4f5781b0.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.4e7ecda3.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.1a18282e.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.ec4969df.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.c956724d.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.ac5ea88b.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.26db6884.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.80dbdde9.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.613e991c.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.de90320b.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.1f3841f2.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.a3de1972.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.28579d58.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.aae5a747.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.4bf49d65.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.9d9599c8.js"><link rel="prefetch" href="/assets/GLOSSARY.html.d812823c.js"><link rel="prefetch" href="/assets/index.html.d25b0535.js"><link rel="prefetch" href="/assets/404.html.0c8252b8.js"><link rel="prefetch" href="/assets/index.html.d5cc08ad.js"><link rel="prefetch" href="/assets/index.html.1331f6ca.js"><link rel="prefetch" href="/assets/index.html.da6c3a69.js"><link rel="prefetch" href="/assets/index.html.1174fbbd.js"><link rel="prefetch" href="/assets/index.html.c73d2264.js"><link rel="prefetch" href="/assets/index.html.1e315145.js"><link rel="prefetch" href="/assets/index.html.514b72a3.js"><link rel="prefetch" href="/assets/index.html.b19f5086.js"><link rel="prefetch" href="/assets/index.html.1ac6115e.js"><link rel="prefetch" href="/assets/404.3a5fd86b.js"><link rel="prefetch" href="/assets/Layout.42785ec5.js"><link rel="prefetch" href="/assets/Slide.5e14cdfb.js"><link rel="prefetch" href="/assets/Blog.f29d76d0.js"><link rel="prefetch" href="/assets/auto.esm.15d52109.js"><link rel="prefetch" href="/assets/index.1842ee54.js"><link rel="prefetch" href="/assets/mermaid.esm.min.f71f1464.js"><link rel="prefetch" href="/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/assets/photoswipe.esm.92018b73.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="DTF&#39;s blog"><!----><span class="site-name hide-in-pad">DTF&#39;s blog</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guide/" class="nav-link" aria-label="使用指南"><i class="icon iconfont icon-creative"></i>使用指南<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/imdtf/blog" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" aria-labelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewbox="0 0 1024 1024" aria-labelledby="outlook"><title id="outlook" lang="en">outlook icon</title><g fill="currentColor"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></g></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-guide"></i><span class="title">语言</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-markdown"></i><span class="title">数据库</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-question"></i><span class="title">面试题</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/interview/java-base.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="基础篇"><!---->基础篇<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_1、-java-语言有哪些特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1、 Java 语言有哪些特点"><!---->1、 Java 语言有哪些特点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_2、面向对象和面向过程的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2、面向对象和面向过程的区别"><!---->2、面向对象和面向过程的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_3、八种基本数据类型的大小-以及他们的封装类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3、八种基本数据类型的大小，以及他们的封装类"><!---->3、八种基本数据类型的大小，以及他们的封装类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_4、标识符的命名规则。" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4、标识符的命名规则。"><!---->4、标识符的命名规则。<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_5、instanceof-关键字的作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5、instanceof 关键字的作用"><!---->5、instanceof 关键字的作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_6、java-自动装箱与拆箱" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6、Java 自动装箱与拆箱"><!---->6、Java 自动装箱与拆箱<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_7、重载和重写的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7、重载和重写的区别"><!---->7、重载和重写的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_8、-equals-与-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8、 equals 与==的区别"><!---->8、 equals 与==的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_9、-hashcode-的作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9、 Hashcode 的作用"><!---->9、 Hashcode 的作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_10、string、string-stringbuffer-和-stringbuilder-的区别是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10、String、String StringBuﬀer 和 StringBuilder 的区别是什么?"><!---->10、String、String StringBuﬀer 和 StringBuilder 的区别是什么?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_11、arraylist-和-linkedlist-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11、ArrayList 和 linkedList 的区别"><!---->11、ArrayList 和 linkedList 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_12、-hashmap-和-hashtable-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12、 HashMap 和 HashTable 的区别"><!---->12、 HashMap 和 HashTable 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_13、-collection-包结构-与-collections-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="13、 Collection 包结构，与 Collections 的区别"><!---->13、 Collection 包结构，与 Collections 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_14、-java-的四种引用-强弱软虚" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="14、 Java 的四种引用，强弱软虚"><!---->14、 Java 的四种引用，强弱软虚<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_15、-泛型常用特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15、 泛型常用特点"><!---->15、 泛型常用特点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_16、java-创建对象有几种方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="16、Java 创建对象有几种方式？"><!---->16、Java 创建对象有几种方式？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_17、有没有可能两个不相等的对象有相同的-hashcode" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17、有没有可能两个不相等的对象有相同的 hashcode"><!---->17、有没有可能两个不相等的对象有相同的 hashcode<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_18、深拷贝和浅拷贝的区别是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18、深拷贝和浅拷贝的区别是什么?"><!---->18、深拷贝和浅拷贝的区别是什么?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_19、final-有哪些用法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="19、ﬁnal 有哪些用法?"><!---->19、ﬁnal 有哪些用法?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_20、static-都有哪些用法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="20、static 都有哪些用法?"><!---->20、static 都有哪些用法?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_21、3-0-1-0-3-返回值是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="21、3*0.1 == 0.3 返回值是什么"><!---->21、3*0.1 == 0.3 返回值是什么<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_22、a-a-b-与-a-b-有什么区别吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="22、a=a+b 与 a+=b 有什么区别吗?"><!---->22、a=a+b 与 a+=b 有什么区别吗?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_23、try-catch-finally-try-里有-return-finally-还执行么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="23、try catch ﬁnally，try 里有 return，ﬁnally 还执行么？"><!---->23、try catch ﬁnally，try 里有 return，ﬁnally 还执行么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_24、-excption-与-error-包结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="24、 Excption 与 Error 包结构"><!---->24、 Excption 与 Error 包结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_25、oom-你遇到过哪些情况-sof-你遇到过哪些情况" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="25、OOM 你遇到过哪些情况，SOF 你遇到过哪些情况"><!---->25、OOM 你遇到过哪些情况，SOF 你遇到过哪些情况<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_26、-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"><!---->26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_27、java-序列化中如果有些字段不想进行序列化-怎么办" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="27、Java 序列化中如果有些字段不想进行序列化，怎么办？"><!---->27、Java 序列化中如果有些字段不想进行序列化，怎么办？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_28、说说-java-中-io-流" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="28、说说 Java 中 IO 流"><!---->28、说说 Java 中 IO 流<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_29、-java-io-与-nio-的区别-补充" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="29、 Java IO 与 NIO 的区别（补充）"><!---->29、 Java IO 与 NIO 的区别（补充）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_30、java-反射的作用于原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="30、java 反射的作用于原理"><!---->30、java 反射的作用于原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_31、说说-list-set-map-三者的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="31、说说 List,Set,Map 三者的区别？"><!---->31、说说 List,Set,Map 三者的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_32-、object-有哪些常用方法-大致说一下每个方法的含义" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="32.、Object 有哪些常用方法？大致说一下每个方法的含义"><!---->32.、Object 有哪些常用方法？大致说一下每个方法的含义<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_33、java-创建对象有几种方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="33、Java 创建对象有几种方式？"><!---->33、Java 创建对象有几种方式？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_34、获取一个类-class-对象的方式有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="34、获取一个类 Class 对象的方式有哪些？"><!---->34、获取一个类 Class 对象的方式有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_35、arraylist-和-linkedlist-的区别有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="35、ArrayList 和 LinkedList 的区别有哪些？"><!---->35、ArrayList 和 LinkedList 的区别有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_36、用过-arraylist-吗-说一下它有什么特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="36、用过 ArrayList 吗？说一下它有什么特点？"><!---->36、用过 ArrayList 吗？说一下它有什么特点？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_37、有数组了为什么还要搞个-arraylist-呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="37、有数组了为什么还要搞个 ArrayList 呢？"><!---->37、有数组了为什么还要搞个 ArrayList 呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_38、说说什么是-fail-fast" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="38、说说什么是 fail-fast？"><!---->38、说说什么是 fail-fast？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_39、说说-hashtable-与-hashmap-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="39、说说 Hashtable 与 HashMap 的区别"><!---->39、说说 Hashtable 与 HashMap 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_40、hashmap-中的-key-我们可以使用任何类作为-key-吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="40、HashMap 中的 key 我们可以使用任何类作为 key 吗？"><!---->40、HashMap 中的 key 我们可以使用任何类作为 key 吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_41、hashmap-的长度为什么是-2-的-n-次方呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="41、HashMap 的长度为什么是 2 的 N 次方呢？"><!---->41、HashMap 的长度为什么是 2 的 N 次方呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_42、hashmap-与-concurrenthashmap-的异同" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="42、HashMap 与 ConcurrentHashMap 的异同"><!---->42、HashMap 与 ConcurrentHashMap 的异同<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_43、红黑树有哪几个特征" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="43、红黑树有哪几个特征？"><!---->43、红黑树有哪几个特征？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_44、说说你平时是怎么处理-java-异常的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="44、说说你平时是怎么处理 Java 异常的"><!---->44、说说你平时是怎么处理 Java 异常的<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/java-base.html#_45、说说深拷贝和浅拷贝" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="45、说说深拷贝和浅拷贝？"><!---->45、说说深拷贝和浅拷贝？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/interview/jvm.html" class="nav-link sidebar-link sidebar-page" aria-label="JVM 篇"><!---->JVM 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/multi-thread.html" class="nav-link sidebar-link sidebar-page" aria-label="多线程&amp;并发篇"><!---->多线程&amp;并发篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring.html" class="nav-link sidebar-link sidebar-page" aria-label="Spring 篇"><!---->Spring 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-boot.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringBoot 篇"><!---->SpringBoot 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-cloud.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringCloud 篇"><!---->SpringCloud 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/dubbo.html" class="nav-link sidebar-link sidebar-page" aria-label="Dubbo 篇"><!---->Dubbo 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/mybatis.html" class="nav-link sidebar-link sidebar-page" aria-label="MyBatis 篇"><!---->MyBatis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MySQL.html" class="nav-link sidebar-link sidebar-page" aria-label="MySQL 篇"><!---->MySQL 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/nginx.html" class="nav-link sidebar-link sidebar-page" aria-label="Nginx 篇"><!---->Nginx 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MQ.html" class="nav-link sidebar-link sidebar-page" aria-label="MQ 篇"><!---->MQ 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/linux.html" class="nav-link sidebar-link sidebar-page" aria-label="Linux 篇"><!---->Linux 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/zookeeper.html" class="nav-link sidebar-link sidebar-page" aria-label="Zookeeper 篇"><!---->Zookeeper 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/Redis.html" class="nav-link sidebar-link sidebar-page" aria-label="Redis 篇"><!---->Redis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/%E5%88%86%E5%B8%83%E5%BC%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="分布式篇"><!---->分布式篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/network.html" class="nav-link sidebar-link sidebar-page" aria-label="网络篇"><!---->网络篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/design-patterns.html" class="nav-link sidebar-link sidebar-page" aria-label="设计模式"><!---->设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/maven.html" class="nav-link sidebar-link sidebar-page" aria-label="maven 篇"><!---->maven 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/ElasticSearch.html" class="nav-link sidebar-link sidebar-page" aria-label="ElasticSearch 篇"><!---->ElasticSearch 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/tomcat.html" class="nav-link sidebar-link sidebar-page" aria-label="tomcat 篇"><!---->tomcat 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/git.html" class="nav-link sidebar-link sidebar-page" aria-label="Git 篇"><!---->Git 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/soft-power.html" class="nav-link sidebar-link sidebar-page" aria-label="软实力篇"><!---->软实力篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->基础篇</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" aria-labelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://github.com/imdtf" target="_blank" rel="noopener noreferrer">DTF</a></span><span property="author" content="DTF"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" aria-labelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年5月17日</span><meta property="datePublished" content="2022-05-17T15:50:18.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" aria-labelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 45 分钟</span><meta property="timeRequired" content="PT45M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_1、-java-语言有哪些特点" class="router-link-active router-link-exact-active toc-link level2">1、 Java 语言有哪些特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_2、面向对象和面向过程的区别" class="router-link-active router-link-exact-active toc-link level2">2、面向对象和面向过程的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_3、八种基本数据类型的大小-以及他们的封装类" class="router-link-active router-link-exact-active toc-link level2">3、八种基本数据类型的大小，以及他们的封装类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_4、标识符的命名规则。" class="router-link-active router-link-exact-active toc-link level2">4、标识符的命名规则。</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_5、instanceof-关键字的作用" class="router-link-active router-link-exact-active toc-link level2">5、instanceof 关键字的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_6、java-自动装箱与拆箱" class="router-link-active router-link-exact-active toc-link level2">6、Java 自动装箱与拆箱</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_7、重载和重写的区别" class="router-link-active router-link-exact-active toc-link level2">7、重载和重写的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_8、-equals-与-的区别" class="router-link-active router-link-exact-active toc-link level2">8、 equals 与==的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_9、-hashcode-的作用" class="router-link-active router-link-exact-active toc-link level2">9、 Hashcode 的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_10、string、string-stringbuffer-和-stringbuilder-的区别是什么" class="router-link-active router-link-exact-active toc-link level2">10、String、String StringBuﬀer 和 StringBuilder 的区别是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_11、arraylist-和-linkedlist-的区别" class="router-link-active router-link-exact-active toc-link level2">11、ArrayList 和 linkedList 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_12、-hashmap-和-hashtable-的区别" class="router-link-active router-link-exact-active toc-link level2">12、 HashMap 和 HashTable 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_13、-collection-包结构-与-collections-的区别" class="router-link-active router-link-exact-active toc-link level2">13、 Collection 包结构，与 Collections 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_14、-java-的四种引用-强弱软虚" class="router-link-active router-link-exact-active toc-link level2">14、 Java 的四种引用，强弱软虚</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_15、-泛型常用特点" class="router-link-active router-link-exact-active toc-link level2">15、 泛型常用特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_16、java-创建对象有几种方式" class="router-link-active router-link-exact-active toc-link level2">16、Java 创建对象有几种方式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_17、有没有可能两个不相等的对象有相同的-hashcode" class="router-link-active router-link-exact-active toc-link level2">17、有没有可能两个不相等的对象有相同的 hashcode</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_18、深拷贝和浅拷贝的区别是什么" class="router-link-active router-link-exact-active toc-link level2">18、深拷贝和浅拷贝的区别是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_19、final-有哪些用法" class="router-link-active router-link-exact-active toc-link level2">19、ﬁnal 有哪些用法?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_20、static-都有哪些用法" class="router-link-active router-link-exact-active toc-link level2">20、static 都有哪些用法?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_21、3-0-1-0-3-返回值是什么" class="router-link-active router-link-exact-active toc-link level2">21、3*0.1 == 0.3 返回值是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_22、a-a-b-与-a-b-有什么区别吗" class="router-link-active router-link-exact-active toc-link level2">22、a=a+b 与 a+=b 有什么区别吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_23、try-catch-finally-try-里有-return-finally-还执行么" class="router-link-active router-link-exact-active toc-link level2">23、try catch ﬁnally，try 里有 return，ﬁnally 还执行么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_24、-excption-与-error-包结构" class="router-link-active router-link-exact-active toc-link level2">24、 Excption 与 Error 包结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_25、oom-你遇到过哪些情况-sof-你遇到过哪些情况" class="router-link-active router-link-exact-active toc-link level2">25、OOM 你遇到过哪些情况，SOF 你遇到过哪些情况</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_26、-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="router-link-active router-link-exact-active toc-link level2">26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_27、java-序列化中如果有些字段不想进行序列化-怎么办" class="router-link-active router-link-exact-active toc-link level2">27、Java 序列化中如果有些字段不想进行序列化，怎么办？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_28、说说-java-中-io-流" class="router-link-active router-link-exact-active toc-link level2">28、说说 Java 中 IO 流</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_29、-java-io-与-nio-的区别-补充" class="router-link-active router-link-exact-active toc-link level2">29、 Java IO 与 NIO 的区别（补充）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_30、java-反射的作用于原理" class="router-link-active router-link-exact-active toc-link level2">30、java 反射的作用于原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_31、说说-list-set-map-三者的区别" class="router-link-active router-link-exact-active toc-link level2">31、说说 List,Set,Map 三者的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_32-、object-有哪些常用方法-大致说一下每个方法的含义" class="router-link-active router-link-exact-active toc-link level2">32.、Object 有哪些常用方法？大致说一下每个方法的含义</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_33、java-创建对象有几种方式" class="router-link-active router-link-exact-active toc-link level2">33、Java 创建对象有几种方式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_34、获取一个类-class-对象的方式有哪些" class="router-link-active router-link-exact-active toc-link level2">34、获取一个类 Class 对象的方式有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_35、arraylist-和-linkedlist-的区别有哪些" class="router-link-active router-link-exact-active toc-link level2">35、ArrayList 和 LinkedList 的区别有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_36、用过-arraylist-吗-说一下它有什么特点" class="router-link-active router-link-exact-active toc-link level2">36、用过 ArrayList 吗？说一下它有什么特点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_37、有数组了为什么还要搞个-arraylist-呢" class="router-link-active router-link-exact-active toc-link level2">37、有数组了为什么还要搞个 ArrayList 呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_38、说说什么是-fail-fast" class="router-link-active router-link-exact-active toc-link level2">38、说说什么是 fail-fast？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_39、说说-hashtable-与-hashmap-的区别" class="router-link-active router-link-exact-active toc-link level2">39、说说 Hashtable 与 HashMap 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_40、hashmap-中的-key-我们可以使用任何类作为-key-吗" class="router-link-active router-link-exact-active toc-link level2">40、HashMap 中的 key 我们可以使用任何类作为 key 吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_41、hashmap-的长度为什么是-2-的-n-次方呢" class="router-link-active router-link-exact-active toc-link level2">41、HashMap 的长度为什么是 2 的 N 次方呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_42、hashmap-与-concurrenthashmap-的异同" class="router-link-active router-link-exact-active toc-link level2">42、HashMap 与 ConcurrentHashMap 的异同</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_43、红黑树有哪几个特征" class="router-link-active router-link-exact-active toc-link level2">43、红黑树有哪几个特征？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_44、说说你平时是怎么处理-java-异常的" class="router-link-active router-link-exact-active toc-link level2">44、说说你平时是怎么处理 Java 异常的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/java-base.html#_45、说说深拷贝和浅拷贝" class="router-link-active router-link-exact-active toc-link level2">45、说说深拷贝和浅拷贝？</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h1 id="基础篇" tabindex="-1"><a class="header-anchor" href="#基础篇" aria-hidden="true">#</a> 基础篇</h1><h2 id="_1、-java-语言有哪些特点" tabindex="-1"><a class="header-anchor" href="#_1、-java-语言有哪些特点" aria-hidden="true">#</a> 1、 Java 语言有哪些特点</h2><p>1、简单易学、有丰富的类库</p><p>2、面向对象（Java 最重要的特性，让程序耦合度更低，内聚性更高）</p><p>3、与平台无关性（JVM 是 Java 跨平台使用的根本）</p><p>4、可靠安全</p><p>5、支持多线程</p><h2 id="_2、面向对象和面向过程的区别" tabindex="-1"><a class="header-anchor" href="#_2、面向对象和面向过程的区别" aria-hidden="true">#</a> 2、面向对象和面向过程的区别</h2><ul><li><p>面向过程：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p></li><li><p>面向对象：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。但是性能上来说，比面向过程要低。</p></li></ul><h2 id="_3、八种基本数据类型的大小-以及他们的封装类" tabindex="-1"><a class="header-anchor" href="#_3、八种基本数据类型的大小-以及他们的封装类" aria-hidden="true">#</a> 3、八种基本数据类型的大小，以及他们的封装类</h2><table><thead><tr><th>基本类型</th><th>大小（字节）</th><th>默认值</th><th>封装类</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>(byte)0</td><td>Byte</td></tr><tr><td>short</td><td>2</td><td>(short)0</td><td>Short</td></tr><tr><td>int</td><td>4</td><td>0</td><td>Integer</td></tr><tr><td>long</td><td>8</td><td>0L</td><td>Long</td></tr><tr><td>ﬂoat</td><td>4</td><td>0.0f</td><td>Float</td></tr><tr><td>double</td><td>8</td><td>0.0d</td><td>Double</td></tr><tr><td>boolean</td><td>-</td><td>false</td><td>Boolean</td></tr><tr><td>char</td><td>2</td><td>\u0000(null)</td><td>Character</td></tr></tbody></table><p>注：</p><ol><li>int 是基本数据类型，Integer 是 int 的封装类，是引用类型。int 默认值是 0，而 Integer 默认值是 null，所以 Integer 能区分出 0 和 null 的情况。一旦 java 看到 null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li><li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。虽然定义了 boolean 这种数据类型，但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供 boolean 值专用的字节码指令，Java 语言表达式所操作的 boolean 值，在编译之后都使用 Java 虚拟机中的 int 数据类型来代替，而 boolean 数组将会被编码成 Java 虚拟机的 byte 数组，每个元素 boolean 元素占 8 位。这样我们可以得出 boolean 类型占了单独使用是 4 个字节，在数组中又是 1 个字节。使用 int 的原因是，对于当下 32 位的处理器（CPU）来说，一次处理数据是 32 位（这里不是指的是 32/64 位系统，而是指 CPU 硬件层面），具有高效存取的特点。</li></ol><h2 id="_4、标识符的命名规则。" tabindex="-1"><a class="header-anchor" href="#_4、标识符的命名规则。" aria-hidden="true">#</a> 4、标识符的命名规则。</h2><p><strong>标识符的含义</strong>： 是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。</p><p><strong>命名规则：（硬性要求）</strong> 标识符可以包含英文字母，0-9 的数字，$以及_ 标识符不能以数字开头标识符不是关键字</p><p><strong>命名规范：（非硬性要求）</strong> 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。方法名规范：同变量名。</p><h2 id="_5、instanceof-关键字的作用" tabindex="-1"><a class="header-anchor" href="#_5、instanceof-关键字的作用" aria-hidden="true">#</a> 5、instanceof 关键字的作用</h2><p>instanceof 严格来说是 Java 中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> result <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Class</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果 result 都返回 true，否则返回 false。</p><p>注意：编译器会检查 obj 是否能转换成右边的 class 类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 编译不通过 i 必须是引用类型，不能是基本类型</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 编译不通过</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integer <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// false ,在 JavaSE 规范中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_6、java-自动装箱与拆箱" tabindex="-1"><a class="header-anchor" href="#_6、java-自动装箱与拆箱" aria-hidden="true">#</a> 6、Java 自动装箱与拆箱</h2><p><strong>装箱就是自动将基本数据类型转换为包装器类型（int--&gt;Integer）；调用方法：Integer 的 valueOf(int) 方法</strong><strong>拆箱就是自动将包装器类型转换为基本数据类型（Integer--&gt;int）。调用方法：Integer 的 intValue 方法</strong></p><p>在 Java SE5 之前，如果要生成一个数值为 10 的 Integer 对象，必须这样进行：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>而在从 Java SE5 开始就提供了自动装箱的特性，如果要生成一个数值为 10 的 Integer 对象，只需要这样就可以了：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>面试题 1： 以下代码会输出什么？</strong></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
            <span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
            <span class="token class-name">Integer</span> i3 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
            <span class="token class-name">Integer</span> i4 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>运行结果：</strong></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token boolean">true</span>
<span class="token boolean">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>为什么会出现这样的结果？输出结果表明 i1 和 i2 指向的是同一个对象，而 i3 和 i4 指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是 Integer 的 valueOf 方法的具体实现：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token operator">-</span><span class="token number">128</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>
          	<span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>其中 IntegerCache 类的实现为：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>

        <span class="token comment">// high value may be configured by property int h = 127;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Use Long.decode here to avoid invoking methods that</span>
            <span class="token comment">// require Integer&#39;s autoboxing cache to be initialized</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// Maximum array size is Integer.MAX_VALUE</span>
            h <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        high <span class="token operator">=</span> h<span class="token punctuation">;</span>
        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
            cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>从这 2 段代码可以看出，在通过 valueOf 方法创建 Integer 对象的时候，如果数值在[-128,127]之间，便返回指向 IntegerCache.cache 中已经存在的对象的引用；否则创建一个新的 Integer 对象。</p><p>上面的代码中 i1 和 i2 的数值为 100，因此会直接从 cache 中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。</p><p><strong>面试题 2：以下代码输出什么</strong></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Double</span> i1 <span class="token operator">=</span> <span class="token number">100.0</span><span class="token punctuation">;</span>
        <span class="token class-name">Double</span> i2 <span class="token operator">=</span> <span class="token number">100.0</span><span class="token punctuation">;</span>
        <span class="token class-name">Double</span> i3 <span class="token operator">=</span> <span class="token number">200.0</span><span class="token punctuation">;</span>
        <span class="token class-name">Double</span> i4 <span class="token operator">=</span> <span class="token number">200.0</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>运行结果：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token boolean">false</span>
<span class="token boolean">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p><h2 id="_7、重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#_7、重载和重写的区别" aria-hidden="true">#</a> 7、重载和重写的区别</h2><p><strong>重写(Override)</strong>:</p><p>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下, 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token class-name">Son</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// TODO Auto-generated method stub System.out.println(&quot;hello by &quot;);</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>重写总结：</strong></p><ol><li>发生在父类与子类之间</li><li>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</li><li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li></ol><p><strong>重载（Overload</strong>）</p><p>在一个类中，同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同甚至是参数顺序不同</strong>）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<strong>不能通过返回类型是否相同来判断重载</strong>。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token class-name">Father</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">&quot;wintershii&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>重载总结：</strong></p><ol><li>重载 Overload 是一个类中多态性的一种表现</li><li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li><li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li></ol><h2 id="_8、-equals-与-的区别" tabindex="-1"><a class="header-anchor" href="#_8、-equals-与-的区别" aria-hidden="true">#</a> 8、 equals 与==的区别</h2><ul><li><p><strong>== ：</strong> == 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。</p><ol><li>比较的是操作符两端的操作数是否是同一个对象。</li><li>两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为 true，如： int a=10 与 long b=10L 与 double c=10.0 都是相同的（为 true），因为他们都指向地址为 10 的堆。</li></ol></li><li><p><strong>equals：</strong> equals 用来比较的是两个对象的内容是否相等，由于所有的类都是继承自 java.lang.Object 类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的却是==的判断。 <strong>总结</strong>： 所有比较是否相等时，都是用 equals 并且在对常量相比较时，把常量写在前面，因为使用 object 的 equals object 可能为 null 则空指针</p></li></ul><p>在阿里的代码规范中只使用 equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“==”，替换成 equals</p><h2 id="_9、-hashcode-的作用" tabindex="-1"><a class="header-anchor" href="#_9、-hashcode-的作用" aria-hidden="true">#</a> 9、 Hashcode 的作用</h2><p>java 的集合有两类，一类是 List，还有一类是 Set。前者有序可重复，后者无序不重复。当我们在 set 中插入的时候怎么判断是否已经存在该元素呢，可以通过 equals 方法。但是如果元素太多，用这样的方法就会比较满。</p><p>于是有人发明了哈希算法来提高集合中查找元素的效率。这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。</p><p>hashCode 方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用 equals 方法的次数就大大降低了，几乎只需要一两次。</p><h2 id="_10、string、string-stringbuffer-和-stringbuilder-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_10、string、string-stringbuffer-和-stringbuilder-的区别是什么" aria-hidden="true">#</a> 10、String、String StringBuﬀer 和 StringBuilder 的区别是什么?</h2><p>String 是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个 ﬁnal 类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对 String 的操作都会生成新的 String 对象。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>每次+操作 ： 隐式在堆上 new 了一个跟原字符串相同的 StringBuilder 对象，再调用 append 方法拼接+后面的字符。</p><p>StringBuﬀer 和 StringBuilder 他们两都继承了 AbstractStringBuilder 抽象类，从 AbstractStringBuilder 抽象类中我们可以看到</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
* The value is used for character storage.
*/</span>
<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用 StringBuﬀer 和 StringBuilder 来进行操作。另外 StringBuﬀer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><h2 id="_11、arraylist-和-linkedlist-的区别" tabindex="-1"><a class="header-anchor" href="#_11、arraylist-和-linkedlist-的区别" aria-hidden="true">#</a> 11、ArrayList 和 linkedList 的区别</h2><p><strong>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。</strong></p><p>Array 获取数据的时间复杂度是 O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据, (因为删除数据以后, 需要把后面所有的数据前移)</p><p><strong>缺点</strong>: 数组初始化必须指定初始化的长度, 否则报错</p><p>例如:</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//推介使用 int[] 这种方式初始化</span>
<span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">56</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//长度：4，索引范围：[0,3]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>List 是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承 Collection。</p><p>List 有两个重要的实现类：ArrayList 和 LinkedList</p><ul><li>ArrayList: 可以看作是能够自动增长容量的数组 ArrayList 的 toArray 方法返回一个数组 ArrayList 的 asList 方法返回一个列表 ArrayList 底层的实现是 Array, 数组扩容实现</li><li>LinkList 是一个双链表,在添加和删除元素时具有比 ArrayList 更好的性能.但在 get 与 set 方面弱于 ArrayList 当然,这些对比都是指数据量很大或者操作很频繁。</li></ul><h2 id="_12、-hashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#_12、-hashmap-和-hashtable-的区别" aria-hidden="true">#</a> 12、 HashMap 和 HashTable 的区别</h2><ol><li><p><strong>两者父类不同</strong></p><p>HashMap 是继承自 AbstractMap 类，而 Hashtable 是继承自 Dictionary 类。不过它们都实现了同时实现了 map、Cloneable（可复制）、Serializable（可序列化）这三个接口。</p></li><li><p><strong>对外提供的接口不同</strong></p><p>Hashtable 比 HashMap 多提供了 elments() 和 contains() 两个方法。elments() 方法继承自 Hashtable 的父类 Dictionnary。elements() 方法用于返回此 Hashtable 中的 value 的枚举。</p><p>contains()方法判断该 Hashtable 是否包含传入的 value。它的作用与 containsValue()一致。事实上，contansValue() 就只是调用了一下 contains() 方法。</p></li><li><p><strong>对 null 的支持不同</strong></p><p>Hashtable：key 和 value 都不能为 null 。HashMap：key 可以为 null，但是这样的 key 只能有一个，因为须保证 key 的唯一性； 可以有多个 key 值对应的 value 为 null。</p></li><li><p><strong>安全性不同</strong></p><p>HashMap 是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。</p><p>Hashtable 是线程安全的，它的每个方法上都有 synchronized 关键字，因此可直接用于多线程中。</p><p>虽然 HashMap 是线程不安全的，但是它的效率远远高于 Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的 ConcurrentHashMap。</p><p>ConcurrentHashMap 虽然也是线程安全的，但是它的效率比 Hashtable 要高好多倍。因为 ConcurrentHashMap 使用了分段锁，并不对整个数据进行锁定。</p></li><li><p><strong>初始容量大小和每次扩充容量大小不同</strong></p></li><li><p><strong>计算 hash 值的方法不同</strong></p></li></ol><h2 id="_13、-collection-包结构-与-collections-的区别" tabindex="-1"><a class="header-anchor" href="#_13、-collection-包结构-与-collections-的区别" aria-hidden="true">#</a> 13、 Collection 包结构，与 Collections 的区别</h2><ul><li><p>Collection 是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、 Set；</p></li><li><p>Collections 是集合类的一个帮助类, 它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</p></li></ul><h2 id="_14、-java-的四种引用-强弱软虚" tabindex="-1"><a class="header-anchor" href="#_14、-java-的四种引用-强弱软虚" aria-hidden="true">#</a> 14、 Java 的四种引用，强弱软虚</h2><p><strong>强引用</strong></p><p>强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>软引用</strong></p><p>软引用在程序内存不足时，会被回收，使用方式：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 注意：wrf 这个引用也是强引用，它是指向 SoftReference 这个对象的，</span>
<span class="token comment">// 这里的软引用指的是指向 new String(&quot;str&quot;)的引用，也就是 SoftReference 类中 T</span>
<span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> wrf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM 就会回收早先创建的对象。</p><p><strong>弱引用</strong></p><p>弱引用就是只要 JVM 垃圾回收器发现了它，就会将之回收，使用方式：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> wrf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>可用场景 ：</strong> Java 源码中的中<code>java.util.WeakHashMap</code>的 key 就是使用弱引用 , 我的理解就是 ，一旦我不需要某个引用，JVM 会自动帮我处理它，这样我就不需要做其它操作。</p><p><strong>虚引用</strong></p><p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意哦，其它引用是被 JVM 回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> prf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>可用场景</strong>： 对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效 上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用(SoftReference 等)。</p><h2 id="_15、-泛型常用特点" tabindex="-1"><a class="header-anchor" href="#_15、-泛型常用特点" aria-hidden="true">#</a> 15、 泛型常用特点</h2><p>泛型是 Java SE 1.5 之后的特性, 《Java 核心技术》中对泛型的定义是：</p><blockquote><p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。</p></blockquote><p>“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的 ArrayList 就是个泛型类，ArrayList 作为集合可以存放各种元素，如 Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放 Integer 类型的元素，如</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> iniData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>使用泛型的好处？</p><p>以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了 Object 即可，添加的数据全部都可向上转型为 Object。更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。</p><h2 id="_16、java-创建对象有几种方式" tabindex="-1"><a class="header-anchor" href="#_16、java-创建对象有几种方式" aria-hidden="true">#</a> 16、Java 创建对象有几种方式？</h2><p>java 中提供了以下四种创建对象的方式:</p><ol><li>new 创建新对象</li><li>通过反射机制</li><li>采用 clone 机制</li><li>通过序列化机制</li></ol><h2 id="_17、有没有可能两个不相等的对象有相同的-hashcode" tabindex="-1"><a class="header-anchor" href="#_17、有没有可能两个不相等的对象有相同的-hashcode" aria-hidden="true">#</a> 17、有没有可能两个不相等的对象有相同的 hashcode</h2><p>有可能.在产生 hash 冲突时,两个不相等的对象就会有相同的 hashcode 值.当 hash 冲突产生时,一般有以下几种方式来处理:</p><ul><li>拉链法:每个哈希表节点都有一个 next 指针,多个哈希表节点可以用 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</li><li>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入</li><li>再哈希:又叫双哈希法,有多个不同的 Hash 函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.</li></ul><h2 id="_18、深拷贝和浅拷贝的区别是什么" tabindex="-1"><a class="header-anchor" href="#_18、深拷贝和浅拷贝的区别是什么" aria-hidden="true">#</a> 18、深拷贝和浅拷贝的区别是什么?</h2><ul><li><strong>浅拷贝</strong> :被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.</li><li><strong>深拷贝</strong> :被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.</li></ul><h2 id="_19、final-有哪些用法" tabindex="-1"><a class="header-anchor" href="#_19、final-有哪些用法" aria-hidden="true">#</a> 19、ﬁnal 有哪些用法?</h2><p>ﬁnal 也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下 5 点就不错了:</p><ul><li>被 ﬁnal 修饰的类不可以被继承</li><li>被 ﬁnal 修饰的方法不可以被重写</li><li>被 ﬁnal 修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.被 ﬁnal 修饰的方法</li><li>JVM 会尝试将其内联,以提高运行效率</li><li>被 ﬁnal 修饰的常量,在编译阶段会存入常量池中.</li></ul><p>除此之外,编译器对 ﬁnal 域要遵守的两个重排序规则更好:</p><p>在构造函数内对一个 ﬁnal 域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序初次读一个包含 ﬁnal 域的对象的引用,与随后初次读这个 ﬁnal 域,这两个操作之间不能重排序。</p><h2 id="_20、static-都有哪些用法" tabindex="-1"><a class="header-anchor" href="#_20、static-都有哪些用法" aria-hidden="true">#</a> 20、static 都有哪些用法?</h2><p>所有的人都知道 static 关键字这两个基本的用法:静态变量和静态方法.也就是被 static 所修饰的变量/方法都属于类的静态资源,类实例所共享。</p><p>除了静态变量和静态方法之外,static 也用于静态块,多用于初始化操作:</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PreCache</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行相关操作</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>此外 static 也多用于修饰内部类,此时称之为静态内部类.</p><p>最后一种用法就是静态导包,即 import static .import static 是在 JDK 1.5 之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//System.out.println(Math.sin(20));传统做法</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_21、3-0-1-0-3-返回值是什么" tabindex="-1"><a class="header-anchor" href="#_21、3-0-1-0-3-返回值是什么" aria-hidden="true">#</a> 21、3*0.1 == 0.3 返回值是什么</h2><p>false,因为有些浮点数不能完全精确的表示出来.</p><h2 id="_22、a-a-b-与-a-b-有什么区别吗" tabindex="-1"><a class="header-anchor" href="#_22、a-a-b-与-a-b-有什么区别吗" aria-hidden="true">#</a> 22、a=a+b 与 a+=b 有什么区别吗?</h2><p>+= 操作符会进行隐式自动类型转换,此处 a+=b 隐式的将加操作的结果类型强制转换为持有结果的类型,而 a=a+b 则不会自动进行类型转换.如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">byte</span> a <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span> b <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// 报编译错误:cannot convert from int to byte</span>
b <span class="token operator">+=</span> a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>以下代码是否有错,有的话怎么改？</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">short</span> s1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
s1 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>有错误.short 类型在进行运算时会自动提升为 int 类型,也就是说 s1+1 的运算结果是 int 类型,而 s1 是 short 类型,此时编译器会报错.</p><p><strong>正确写法</strong> ：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">short</span> s1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
s1 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>+=操作符会对右边的表达式结果强转匹配左边的数据类型,所以没错.</p><h2 id="_23、try-catch-finally-try-里有-return-finally-还执行么" tabindex="-1"><a class="header-anchor" href="#_23、try-catch-finally-try-里有-return-finally-还执行么" aria-hidden="true">#</a> 23、try catch ﬁnally，try 里有 return，ﬁnally 还执行么？</h2><p>执行，并且 ﬁnally 的执行早于 try 里面的 return</p><p><strong>结论</strong> ：</p><ol><li>不管有木有出现异常，ﬁnally 块中代码都会执行；</li><li>当 try 和 catch 中有 return 时，ﬁnally 仍然会执行；</li><li>ﬁnally 是在 return 后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管 ﬁnally 中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在 ﬁnally 执行前确定的；</li><li>ﬁnally 中最好不要包含 return，否则程序会提前退出，返回值不是 try 或 catch 中保存的返回值。</li></ol><h2 id="_24、-excption-与-error-包结构" tabindex="-1"><a class="header-anchor" href="#_24、-excption-与-error-包结构" aria-hidden="true">#</a> 24、 Excption 与 Error 包结构</h2><p>Java 可抛出(Throwable)的结构分为三种类型：被检查的异常(CheckedException)，运行时异常(RuntimeException)，错误(Error)。</p><ol><li><p>运行时异常</p><p><strong>定义</strong> :RuntimeException 及其子类都被称为运行时异常。</p><p><strong>特点</strong> :Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既&quot;没有通过 throws 声明抛出它&quot;，也&quot;没有用 try-catch 语句捕获它&quot;，还是会编译通过。例如，除数为零时产生的 ArithmeticException 异常，数组越界时产生的 IndexOutOfBoundsException 异常，fail-fast 机制产生的 ConcurrentModiﬁcationException 异常（java.util 包下面的所有的集合类都是快速失败的，“快速失败”也就是 fail-fast，它是 Java 集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModiﬁcationException 异常，从而产生 fail-fast 机制，这个错叫并发修改异常。Fail- safe，java.util.concurrent 包下面的所有的类都是安全失败的，在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出 ConcurrentModiﬁcationException 异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是 ConcurrentHashMap 迭代器弱一致的表现。ConcurrentHashMap 的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与 Hashtable 和同步的 HashMap 一样了。）等，都属于运行时异常。</p><p>常见的五种运行时异常：</p><ul><li>ClassCastException（类转换异常）</li><li>IndexOutOfBoundsException（数组越界）</li><li>NullPointerException（空指针异常）</li><li>ArrayStoreException（数据存储异常，操作数组是类型不一致）</li><li>BuﬀerOverﬂowException（缓冲区溢出异常）</li></ul></li><li><p>被检查异常</p><p><strong>定义</strong> :Exception 类本身，以及 Exception 的子类中除了&quot;运行时异常&quot;之外的其它子类都属于被检查异常。</p><p><strong>特点</strong> : Java 编译器会检查它。此类异常，要么通过 throws 进行声明抛出，要么通过 try-catch 进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException 就属于被检查异常。当通过 clone()接口去克隆一个对象，而该对象对应的类没有实现 Cloneable 接口，就会抛出 CloneNotSupportedException 异常。被检查异常通常都是可以恢复的。如：IOException FileNotFoundException SQLException 被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的 FileNotFoundException。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象 NullPointerException 引用时没有确保对象非空而引起的 。</p></li><li><p>错误</p><p><strong>定义</strong> : Error 类及其子类。</p><p><strong>特点</strong> : 和运行时异常一样，编译器也不会对错误进行检查。</p><p>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError 就属于错误。出现这种错误会导致程序终止运行。OutOfMemoryError、ThreadDeath。</p><p>Java 虚拟机规范规定 JVM 的内存分为了好几块，比如堆，栈，程序计数器，方法区等</p></li></ol><h2 id="_25、oom-你遇到过哪些情况-sof-你遇到过哪些情况" tabindex="-1"><a class="header-anchor" href="#_25、oom-你遇到过哪些情况-sof-你遇到过哪些情况" aria-hidden="true">#</a> 25、OOM 你遇到过哪些情况，SOF 你遇到过哪些情况</h2><ul><li><p><strong>OOM</strong> (OutOfMemoryError 异常)</p><p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemoryError(OOM)异常的可能。</p><ol><li><p>Java Heap 溢出：</p><p>一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。</p><p>java 堆用于存储对象实例，我们只要不断的创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p><p>出现这种异常，一般手段是先通过内存映像分析工具(如 Eclipse Memory Analyzer)对 dump 出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overﬂow)。</p><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GCRoots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。</p><p>如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx 与-Xms)的设置是否适当。</p></li><li><p>虚拟机栈和本地方法栈溢出</p><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverﬂowError 异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常</p><p>这里需要注意当栈的大小越大可分配的线程数就越少。</p></li><li><p>运行时常量池溢出</p><p>异常信息：java.lang.OutOfMemoryError:PermGenspace</p><p>如果要向运行时常量池中添加内容，最简单的做法就是使用 String.intern()这个 Native 方法。该方法的作用是：如果池中已经包含一个等于此 String 的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize 和-XX:MaxPermSize 限制方法区的大小，从而间接限制其中常量池的容量。</p></li><li><p>方法区溢出 方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的 class 对象没有被及时回收掉或者 class 信息占用的内存超过了我们配置。 异常信息：java.lang.OutOfMemoryError:PermGenspace 方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量 Class 的应用中，要特别注意这点。</p></li></ol></li><li><p><strong>SOF</strong>（堆栈溢出 StackOverﬂow）： StackOverﬂowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。</p><p>因为栈一般默认为 1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过 1m 而导致溢出。</p><p>栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map 数据过大。</p></li></ul><h2 id="_26、-简述线程、程序、进程的基本概念。以及他们之间关系是什么" tabindex="-1"><a class="header-anchor" href="#_26、-简述线程、程序、进程的基本概念。以及他们之间关系是什么" aria-hidden="true">#</a> 26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p><strong>线程</strong> 与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>程序</strong> 是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h2 id="_27、java-序列化中如果有些字段不想进行序列化-怎么办" tabindex="-1"><a class="header-anchor" href="#_27、java-序列化中如果有些字段不想进行序列化-怎么办" aria-hidden="true">#</a> 27、Java 序列化中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用 <code>transient </code>关键字修饰。</p><p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p><h2 id="_28、说说-java-中-io-流" tabindex="-1"><a class="header-anchor" href="#_28、说说-java-中-io-流" aria-hidden="true">#</a> 28、说说 Java 中 IO 流</h2><p><strong>Java 中 IO 流分为几种?</strong></p><ul><li><p>按照流的流向分，可以分为输入流和输出流；</p></li><li><p>按照操作单元划分，可以划分为字节流和字符流；</p></li><li><p>按照流的角色划分为节点流和处理流。</p></li></ul><p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系，Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p>// TODO image</p><p>按操作对象分类结构图：</p><p>// TODO image</p><h2 id="_29、-java-io-与-nio-的区别-补充" tabindex="-1"><a class="header-anchor" href="#_29、-java-io-与-nio-的区别-补充" aria-hidden="true">#</a> 29、 Java IO 与 NIO 的区别（补充）</h2><p>NIO 即 New IO，这个库是在 JDK1.4 中才引入的。NIO 和 IO 有相同的作用和目的，但实现方式不同, NIO 主要用到的是块，所以 NIO 的效率要比 IO 高很多。在 Java API 中提供了两套 NIO，一套是针对标准输入输出 NIO，另一套就是网络编程 NIO。</p><h2 id="_30、java-反射的作用于原理" tabindex="-1"><a class="header-anchor" href="#_30、java-反射的作用于原理" aria-hidden="true">#</a> 30、java 反射的作用于原理</h2><ol><li><p>定义：</p><p>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在 java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。 这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p></li><li><p>哪里会用到反射机制？ jdbc 就是典型的反射</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>&#39;<span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span></span>Driver</span><span class="token punctuation">.</span><span class="token keyword">class</span>&#39;<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加载 MySQL 的驱动类</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这就是反射。如 hibernate，struts 等框架使用反射实现的。</p></li><li><p>反射的实现方式：</p><p>第一步：获取 Class 对象，有 4 中方法： 1）Class.forName(“类的路径”)； 2）类名.class 3）对象名.getClass() 4）基本类型的包装类，可以调用包装类的 Type 属性来获得该包装类的 Class 对象</p></li><li><p>实现 Java 反射的类：</p><ul><li>Class：表示正在运行的 Java 应用程序中的类和接口注意： 所有获取对象的信息都需要 Class 类来实现。</li><li>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</li><li>Constructor：提供关于类的单个构造方法的信息以及它的访问权限</li><li>Method：提供类或接口中某个方法的信息</li></ul></li><li><p>反射机制的优缺点：</p><p><strong>优点：</strong></p><ul><li><p>能够运行时动态获取类的实例，提高灵活性；</p></li><li><p>与动态编译结合</p><p><strong>缺点：</strong></p></li><li><p>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</p><p>解决方案：</p><ul><li>通过 setAccessible(true)关闭 JDK 的安全检查来提升反射速度；</li><li>多次创建一个类的实例时，有缓存会快很多</li><li>ReﬂectASM 工具类，通过字节码生成的方式加快反射速度</li></ul></li><li><p>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</p></li></ul></li></ol><h2 id="_31、说说-list-set-map-三者的区别" tabindex="-1"><a class="header-anchor" href="#_31、说说-list-set-map-三者的区别" aria-hidden="true">#</a> 31、说说 List,Set,Map 三者的区别？</h2><ul><li><strong>List</strong>(对付顺序的好帮手)： List 接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li><strong>Set</strong> (注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map</strong>(用 Key 来搜索的专家): 使用键值对存储。Map 会维护与 Key 有关联的值。两个 Key 可以引用相同的对象，但 Key 不能重复，典型的 Key 是 String 类型，但也可以是任何对象。</li></ul><h2 id="_32-、object-有哪些常用方法-大致说一下每个方法的含义" tabindex="-1"><a class="header-anchor" href="#_32-、object-有哪些常用方法-大致说一下每个方法的含义" aria-hidden="true">#</a> 32.、Object 有哪些常用方法？大致说一下每个方法的含义</h2><p>java.lang.Object</p><ol><li><p><strong>clone</strong> 方法</p><p>保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常，深拷贝也需要实现 Cloneable，同时其成员变量为引用类型的也需要实现 Cloneable，然后重写 clone 方法。</p></li><li><p><strong>ﬁnalize</strong> 方法</p><p>该方法和垃圾收集器有关系，判断一个对象是否可以被回收的最后一步就是判断是否重写了此方法。</p></li><li><p><strong>equals</strong> 方法</p><p>该方法使用频率非常高。一般 equals 和 == 是不一样的，但是在 Object 中两者是一样的。子类一般都要重写这个方法。</p></li><li><p><strong>hashCode</strong> 方法</p><p>该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法，这个方法在一些具有哈希功能的 Collection 中用到。</p><p>一般必须满足<code>obj1.equals(obj2)==true</code> 。可以推出 <code>obj1.hashCode()==obj2.hashCode() </code>, 但是 hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p><ul><li>JDK 1.6、1.7 默认是返回随机数；</li><li>JDK 1.8 默认是通过和当前线程有关的一个随机数 + 三个确定值，运用 Marsaglia’s xorshift scheme 随机数算法得到的一个随机数。</li></ul></li><li><p><strong>wait</strong> 方法</p><p>配合 synchronized 使用，wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait() 方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p><p>调用该方法后当前线程进入睡眠状态，直到以下事件。</p><ul><li>其他线程调用了该对象的 notify 方法；</li><li>其他线程调用了该对象的 notifyAll 方法；</li><li>其他线程调用了 interrupt 中断该线程；</li><li>时间间隔到了。</li></ul><p>此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。</p></li><li><p><strong>notify</strong> 方法</p><p>配合 synchronized 使用，该方法唤醒在该对象上<strong>等待队列</strong>中的某个线程（同步队列中的线程是给抢占 CPU 的线程，等待队列中的线程指的是等待唤醒的线程）。</p></li><li><p><strong>notifyAll</strong> 方法</p><p>配合 synchronized 使用，该方法唤醒在该对象上等待队列中的所有线程。</p></li></ol><p><strong>总结</strong></p><p>只要把上面几个方法熟悉就可以了，toString 和 getClass 方法可以不用去讨论它们。该题目考察的是对 Object 的熟悉程度，平时用的很多方法并没看其定义但是也在用，比如说：wait() 方法，equals() 方法等。</p><blockquote><p>Class Object is the root of the class hierarchy.Every class has Object as a superclass. All objects, including arrays, implement the methods of this class.</p></blockquote><p>大致意思：Object 是所有类的根，是所有类的父类，所有对象包括数组都实现了 Object 的方法。</p><h2 id="_33、java-创建对象有几种方式" tabindex="-1"><a class="header-anchor" href="#_33、java-创建对象有几种方式" aria-hidden="true">#</a> 33、Java 创建对象有几种方式？</h2><p>这题目看似简单，要好好回答起来还是有点小复杂的，我们来看看，到底有哪些方式可以创建对象？</p><ul><li>使用 <strong>new</strong> 关键字，这也是我们平时使用的最多的创建对象的方式，示例：</li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">User</span> user<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><strong>使用反射方式创建对象</strong>，使用 newInstance()，但是得处理两个异常 InstantiationException、 llegalAccessException：</li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">User</span> user<span class="token operator">=</span><span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> object<span class="token operator">=</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;java.lang.Object&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><strong>使用 clone 方法</strong>，前面题目中 clone 是 Object 的方法，所以所有对象都有这个方法。</li><li><strong>使用反序列化创建对象</strong>，调用 ObjectInputStream 类的 readObject() 方法。 反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造函数。一个对象实现了 Serializable 接口，就可以把对象写入到文件中，并通过读取文件来创建对象。</li></ul><p><strong>总结</strong></p><p>创建对象的方式关键字：new、反射、clone 拷贝、反序列化。</p><h2 id="_34、获取一个类-class-对象的方式有哪些" tabindex="-1"><a class="header-anchor" href="#_34、获取一个类-class-对象的方式有哪些" aria-hidden="true">#</a> 34、获取一个类 Class 对象的方式有哪些？</h2><p>搞清楚类对象和实例对象，但都是对象。</p><ul><li><p>第一种：通过类对象的 getClass() 方法获取，细心点的都知道，这个 getClass 是 Object 类里面的方法。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">User</span> user<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//clazz 就是一个 User 的类对象</span>
<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token operator">=</span>user<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>第二种：通过类的静态成员表示，每个类都有隐含的静态成员 class。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//clazz 就是一个 User 的类对象</span>
 <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token operator">=</span><span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p>第三种：通过 Class 类的静态方法 forName() 方法获取。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;com.tian.User&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ul><h2 id="_35、arraylist-和-linkedlist-的区别有哪些" tabindex="-1"><a class="header-anchor" href="#_35、arraylist-和-linkedlist-的区别有哪些" aria-hidden="true">#</a> 35、ArrayList 和 LinkedList 的区别有哪些？</h2><p><strong>ArrayList</strong></p><ul><li><strong>优点</strong>：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</li><li><strong>缺点</strong>：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</li></ul><p><strong>LinkedList</strong></p><ul><li><strong>优点</strong>：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</li><li><strong>缺点</strong>：因为 LinkedList 要移动指针，所以查询操作性能比较低。</li></ul><p><strong>适用场景分析</strong></p><ul><li><p>当需要对数据进行对随机访问的时候，选用 ArrayList。</p></li><li><p>当需要对数据进行多次增加删除修改时，采用 LinkedList。</p></li><li><p>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList。</p></li></ul><p>当然，绝大数业务的场景下，使用 ArrayList 就够了，但需要注意避免 ArrayList 的扩容，以及非顺序的插入。</p><h2 id="_36、用过-arraylist-吗-说一下它有什么特点" tabindex="-1"><a class="header-anchor" href="#_36、用过-arraylist-吗-说一下它有什么特点" aria-hidden="true">#</a> 36、用过 ArrayList 吗？说一下它有什么特点？</h2><p>只要是搞 Java 的肯定都会回答“用过”。所以，回答题目的后半部分——ArrayList 的特点。可以从这几个方面去回答：</p><p>Java 集合框架中的一种存放相同类型的元素数据，是一种变长的集合类，基于定长数组实现，当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小。</p><p>底层是使用数组实现，添加元素。</p><ul><li>如果 add(o)，添加到的是数组的尾部，如果要增加的数据量很大，应该使用 ensureCapacity() 方法，该方法的作用是预先设置 ArrayList 的大小，这样可以大大提高初始化速度。</li><li>如果使用 add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制。</li></ul><p>高并发的情况下，线程不安全。多个线程同时操作 ArrayList，会引发不可预知的异常或错误。</p><p>ArrayList 实现了 Cloneable 接口，标识着它可以被复制。注意：ArrayList 里面的 clone() 复制其实是浅复制。</p><h2 id="_37、有数组了为什么还要搞个-arraylist-呢" tabindex="-1"><a class="header-anchor" href="#_37、有数组了为什么还要搞个-arraylist-呢" aria-hidden="true">#</a> 37、有数组了为什么还要搞个 ArrayList 呢？</h2><p>通常我们在使用的时候，如果在不明确要插入多少数据的情况下，普通数组就很尴尬了，因为你不知道需要初始化数组大小为多少，而 ArrayList 可以使用默认的大小，当元素个数到达一定程度后，会自动扩容。</p><p>可以这么来理解：我们常说的数组是定死的数组，ArrayList 却是动态数组。</p><h2 id="_38、说说什么是-fail-fast" tabindex="-1"><a class="header-anchor" href="#_38、说说什么是-fail-fast" aria-hidden="true">#</a> 38、说说什么是 fail-fast？</h2><p>fail-fast 机制是 Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。</p><p>例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModiﬁcationException 异常，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。</p><p>解决办法：建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。</p><p>可以这么理解：在遍历之前，把 modCount 记下来 expectModCount，后面 expectModCount 去和 modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出 ConcurrentModiﬁcationException 异常。</p><h2 id="_39、说说-hashtable-与-hashmap-的区别" tabindex="-1"><a class="header-anchor" href="#_39、说说-hashtable-与-hashmap-的区别" aria-hidden="true">#</a> 39、说说 Hashtable 与 HashMap 的区别</h2><p>本来不想这么写标题的，但是无奈，面试官都喜欢这么问 HashMap。</p><ol><li>出生的版本不一样，Hashtable 出生于 Java 发布的第一版本 JDK 1.0，HashMap 出生于 JDK1.2。</li><li>都实现了 Map、Cloneable、Serializable（当前 JDK 版本 1.8）。</li><li>HashMap 继承的是 AbstractMap，并且 AbstractMap 也实现了 Map 接口。Hashtable 继承 Dictionary。</li><li>Hashtable 中大部分 public 修饰普通方法都是 synchronized 字段修饰的，是线程安全的，HashMap 是非线程安全的。</li><li>Hashtable 的 key 不能为 null，value 也不能为 null，这个可以从 Hashtable 源码中的 put 方法看到，判断如果 value 为 null 就直接抛出空指针异常，在 put 方法中计算 key 的 hash 值之前并没有判断 key 为 null 的情况，那说明，这时候如果 key 为空，照样会抛出空指针异常。</li><li>HashMap 的 key 和 value 都可以为 null。在计算 hash 值的时候，有判断，如果<code>key==null</code>，则其 hash=0；至于 value 是否为 null，根本没有判断过。</li><li>Hashtable 直接使用对象的 hash 值。hash 值是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap 为了提高计算效率，将哈希表的大小固定为了 2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</li><li>Hashtable、HashMap 都使用了 Iterator。而由于历史原因，Hashtable 还使用了 Enumeration 的方式。</li><li>默认情况下，初始容量不同，Hashtable 的初始长度是 11，之后每次扩充容量变为之前的 2n+1（n 为上一次的长度）而 HashMap 的初始长度为 16，之后每次扩充变为原来的两倍。</li></ol><p>另外在 Hashtable 源码注释中有这么一句话：</p><blockquote><p>Hashtable is synchronized. If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable . If a thread-safe highly- concurrent implementation is desired, then it is recommended to use ConcurrentHashMap in place of Hashtable.</p></blockquote><p>大致意思：Hashtable 是线程安全，推荐使用 HashMap 代替 Hashtable；如果需要线程安全高并发的话，推荐使用 ConcurrentHashMap 代替 Hashtable。</p><p>这个回答完了，面试官可能会继续问：HashMap 是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？</p><p>这里最好的选择就是 ConcurrentHashMap 了，但面试官肯定会叫你继续说一下 ConcurrentHashMap 数据结构以及底层原理等。</p><h2 id="_40、hashmap-中的-key-我们可以使用任何类作为-key-吗" tabindex="-1"><a class="header-anchor" href="#_40、hashmap-中的-key-我们可以使用任何类作为-key-吗" aria-hidden="true">#</a> 40、HashMap 中的 key 我们可以使用任何类作为 key 吗？</h2><p>平时可能大家使用的最多的就是使用 String 作为 HashMap 的 key，但是现在我们想使用某个自定义类作为 HashMap 的 key，那就需要注意以下几点：</p><ul><li>如果类重写了 equals 方法，它也应该重写 hashCode 方法。</li><li>类的所有实例需要遵循与 equals 和 hashCode 相关的规则。</li><li>如果一个类没有使用 equals，你不应该在 hashCode 中使用它。</li><li>咱们自定义 key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h2 id="_41、hashmap-的长度为什么是-2-的-n-次方呢" tabindex="-1"><a class="header-anchor" href="#_41、hashmap-的长度为什么是-2-的-n-次方呢" aria-hidden="true">#</a> 41、HashMap 的长度为什么是 2 的 N 次方呢？</h2><p>为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。</p><p>我们首先可能会想到 % 取模的操作来实现。下面是回答的重点哟：</p><p><strong>取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说 hash % length == hash &amp;(length - 1)的前提是 length 是 2 的 n 次方）。并且，采用二进制位操作 &amp; ，相对于 % 能够提高运算效率。</strong></p><p>这就是为什么 HashMap 的长度需要 2 的 N 次方了。</p><h2 id="_42、hashmap-与-concurrenthashmap-的异同" tabindex="-1"><a class="header-anchor" href="#_42、hashmap-与-concurrenthashmap-的异同" aria-hidden="true">#</a> 42、HashMap 与 ConcurrentHashMap 的异同</h2><ol><li>都是 key-value 形式的存储数据；</li><li>HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；</li><li>HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑树。当链表中元素个数达到 8 的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；</li><li>HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 * 数组大小的方式进行扩容；</li><li>ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry， Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，采用 Node + CAS + Synchronized 来保证并发安全进行实现。</li></ol><h2 id="_43、红黑树有哪几个特征" tabindex="-1"><a class="header-anchor" href="#_43、红黑树有哪几个特征" aria-hidden="true">#</a> 43、红黑树有哪几个特征？</h2><p>紧接上个问题，面试官很有可能会问红黑树，下面把红黑树的几个特征列出来：</p><h2 id="_44、说说你平时是怎么处理-java-异常的" tabindex="-1"><a class="header-anchor" href="#_44、说说你平时是怎么处理-java-异常的" aria-hidden="true">#</a> 44、说说你平时是怎么处理 Java 异常的</h2><p>try-catch-ﬁnally</p><ul><li><p>try 块负责监控可能出现异常的代码</p></li><li><p>catch 块负责捕获可能出现的异常，并进行处理</p></li><li><p>ﬁnally 块负责清理各种资源，不管是否出现异常都会执行</p></li><li><p>其中 try 块是必须的，catch 和 ﬁnally 至少存在一个标准异常处理流程</p><blockquote><p>抛出异常 → 捕获异常 → 捕获成功（当 catch 的异常类型与抛出的异常类型匹配时，捕获成功）→ 异常被处理，程序继续运行抛出异常 → 捕获异常 → 捕获失败（当 catch 的异常类型与抛出异常类型不匹配时，捕获失败）→ 异常未被处理，程序中断运行</p></blockquote></li></ul><p>在开发过程中会使用到自定义异常，在通常情况下，程序很少会自己抛出异常，因为异常的类名通常也包含了该异常的有用信息，所以在选择抛出异常的时候，应该选择合适的异常类，从而可以明确地描述该异常情况，所以这时候往往都是自定义异常。</p><p>自定义异常通常是通过继承 java.lang.Exception 类，如果想自定义 Runtime 异常的话，可以继承 java.lang.RuntimeException 类，实现一个无参构造和一个带字符串参数的有参构造方法。</p><p>在业务代码里，可以针对性的使用自定义异常。比如说：该用户不具备某某权限、余额不足等。</p><h2 id="_45、说说深拷贝和浅拷贝" tabindex="-1"><a class="header-anchor" href="#_45、说说深拷贝和浅拷贝" aria-hidden="true">#</a> 45、说说深拷贝和浅拷贝？</h2><p><strong>浅拷贝</strong>（shallowCopy）只是增加了一个指针指向已存在的内存地址</p><p><strong>深拷贝</strong>（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存</p><p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p><p>最好是结合克隆已经原型模式联系在一起哈，记得复习的时候，把这几个联系起来的。</p><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/imdtf/blog/edit/main/docs/interview/java-base.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" aria-labelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/5/17 23:50:18</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: imdtf@qq.com">DTF</span><!--]--><!--]--></div></footer><nav class="page-nav"><!----><a href="/interview/jvm.html" class="nav-link next" aria-label="JVM 篇"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">JVM 篇<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2022 DTF</div></footer><!--]--></div><!--]--><!----><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewbox="0 0 1024 1024" aria-labelledby="close"><title id="close" lang="en">close icon</title><g fill="currentColor"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></g></svg></button><div class="logo"><!----><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!----><!----></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button class="install-button">安装<span></span></button><button class="cancel-button">取消</button></div></div></div></div><!--]--></div>
    <script type="module" src="/assets/app.597ce2f2.js" defer></script>
  </body>
</html>
