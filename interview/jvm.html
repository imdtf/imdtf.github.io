<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.43" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-v2-demo.mrhope.site/interview/jvm.html"><meta property="og:site_name" content="DTF's blog"><meta property="og:title" content="JVM 篇"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-05-18T15:27:14.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-05-18T15:27:14.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>JVM 篇 | DTF's blog</title><meta name="description" content="我的学习记录博客">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.af58f80f.css">
    <link rel="modulepreload" href="/assets/app.597ce2f2.js"><link rel="modulepreload" href="/assets/jvm.html.7b42d915.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/jvm.html.53d34a5d.js"><link rel="prefetch" href="/assets/index.html.e173ef83.js"><link rel="prefetch" href="/assets/ElasticSearch.html.279e5d7b.js"><link rel="prefetch" href="/assets/MQ.html.9d040945.js"><link rel="prefetch" href="/assets/MySQL.html.d1ae2d1e.js"><link rel="prefetch" href="/assets/Redis.html.b201ad05.js"><link rel="prefetch" href="/assets/design-patterns.html.733535fa.js"><link rel="prefetch" href="/assets/dubbo.html.c776d990.js"><link rel="prefetch" href="/assets/git.html.72b47aa0.js"><link rel="prefetch" href="/assets/java-base.html.db5311da.js"><link rel="prefetch" href="/assets/linux.html.65017b81.js"><link rel="prefetch" href="/assets/maven.html.ceec6571.js"><link rel="prefetch" href="/assets/multi-thread.html.3652cc7f.js"><link rel="prefetch" href="/assets/mybatis.html.cb44fe5a.js"><link rel="prefetch" href="/assets/network.html.b1609fd9.js"><link rel="prefetch" href="/assets/nginx.html.9ca67d3a.js"><link rel="prefetch" href="/assets/soft-power.html.508fb44f.js"><link rel="prefetch" href="/assets/spring-boot.html.e888e4e7.js"><link rel="prefetch" href="/assets/spring-cloud.html.57c2b0d4.js"><link rel="prefetch" href="/assets/spring.html.94b261f5.js"><link rel="prefetch" href="/assets/tomcat.html.dc4aea03.js"><link rel="prefetch" href="/assets/zookeeper.html.75896320.js"><link rel="prefetch" href="/assets/分布式.html.6e369ff9.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.58f6dba8.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.04b85b76.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.116abb6a.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.1d83f138.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.40f6f1e4.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.900bda42.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.3492d336.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.dcc88998.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.7239f150.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.6199feb4.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.57624587.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.d99caa1b.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.cabd308f.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.c89015fe.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.6b8e9ff0.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.e1e4da4a.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.697b9a23.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.9000e742.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.4d12fb46.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.48d80708.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.da9eab5a.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.95150d1c.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.b9bda91b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.bb805e63.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.514eb232.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.4cfc99f3.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.1561ec1a.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.11ef8b3e.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.ef765715.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.50f4f1d6.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.60a1c908.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.b6c6ee60.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.0fa73bd5.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.bfe213be.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.e0558584.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.3087bc74.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.c5df5f6e.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.b9edc687.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.9906de00.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.4b8670c8.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.b78f67d4.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b762f081.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.e5ec66c1.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.f9b4c2c6.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.d4daa082.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.1f616fc4.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.25fe22f4.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.8bb53047.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.63f53d07.js"><link rel="prefetch" href="/assets/00-Introduction.html.aed5c856.js"><link rel="prefetch" href="/assets/00-Preface.html.feee9db3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.ab6ea8b6.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.0224a9bf.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.bea55af9.js"><link rel="prefetch" href="/assets/04-Operators.html.35525abf.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.c4cd86f5.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.b5c2b268.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.399ae58f.js"><link rel="prefetch" href="/assets/08-Reuse.html.0ab07e65.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.89443cf5.js"><link rel="prefetch" href="/assets/10-Interfaces.html.4948bb7b.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.b8f6a196.js"><link rel="prefetch" href="/assets/12-Collections.html.52f2a06b.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.db50a84d.js"><link rel="prefetch" href="/assets/14-Streams.html.9308751d.js"><link rel="prefetch" href="/assets/15-Exceptions.html.40e68d98.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.3edda5f0.js"><link rel="prefetch" href="/assets/17-Files.html.e87e7c99.js"><link rel="prefetch" href="/assets/18-Strings.html.a2842b17.js"><link rel="prefetch" href="/assets/19-Type-Information.html.12cc605b.js"><link rel="prefetch" href="/assets/20-Generics.html.3e4b17f6.js"><link rel="prefetch" href="/assets/21-Arrays.html.67720723.js"><link rel="prefetch" href="/assets/22-Enumerations.html.ab50f89b.js"><link rel="prefetch" href="/assets/23-Annotations.html.747faef3.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.5b9841aa.js"><link rel="prefetch" href="/assets/25-Patterns.html.10af6fe7.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.13f6de18.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.4774ac79.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.fec6d369.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.fe3a1870.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.35950f4f.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.54af4f5f.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.bb07240e.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.8f39ad15.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.39836314.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.ee52b83c.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.68302b50.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.9b5edd63.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.c8a5f6e1.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.34dcd815.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.8c0a6980.js"><link rel="prefetch" href="/assets/GLOSSARY.html.af317d6f.js"><link rel="prefetch" href="/assets/index.html.859506fe.js"><link rel="prefetch" href="/assets/404.html.61bcede7.js"><link rel="prefetch" href="/assets/index.html.6eefb2c9.js"><link rel="prefetch" href="/assets/index.html.276bb6b8.js"><link rel="prefetch" href="/assets/index.html.6c49b0c9.js"><link rel="prefetch" href="/assets/index.html.938faca6.js"><link rel="prefetch" href="/assets/index.html.234dfb8d.js"><link rel="prefetch" href="/assets/index.html.02cffa46.js"><link rel="prefetch" href="/assets/index.html.c70b19c7.js"><link rel="prefetch" href="/assets/index.html.e9ae5772.js"><link rel="prefetch" href="/assets/index.html.43ef8dd6.js"><link rel="prefetch" href="/assets/index.html.0319d1c3.js"><link rel="prefetch" href="/assets/ElasticSearch.html.1822d360.js"><link rel="prefetch" href="/assets/MQ.html.257a1eec.js"><link rel="prefetch" href="/assets/MySQL.html.12265bed.js"><link rel="prefetch" href="/assets/Redis.html.c5915ac6.js"><link rel="prefetch" href="/assets/design-patterns.html.4dff82bc.js"><link rel="prefetch" href="/assets/dubbo.html.70900b5c.js"><link rel="prefetch" href="/assets/git.html.9f0ce8a6.js"><link rel="prefetch" href="/assets/java-base.html.f9b49957.js"><link rel="prefetch" href="/assets/linux.html.9f1e7d55.js"><link rel="prefetch" href="/assets/maven.html.f848fc43.js"><link rel="prefetch" href="/assets/multi-thread.html.5d323dfe.js"><link rel="prefetch" href="/assets/mybatis.html.868f5463.js"><link rel="prefetch" href="/assets/network.html.347740e9.js"><link rel="prefetch" href="/assets/nginx.html.acf44958.js"><link rel="prefetch" href="/assets/soft-power.html.fa4cc2bb.js"><link rel="prefetch" href="/assets/spring-boot.html.eb446c44.js"><link rel="prefetch" href="/assets/spring-cloud.html.5a2e7953.js"><link rel="prefetch" href="/assets/spring.html.e5d334fa.js"><link rel="prefetch" href="/assets/tomcat.html.1edb1280.js"><link rel="prefetch" href="/assets/zookeeper.html.d47f6f3b.js"><link rel="prefetch" href="/assets/分布式.html.8362b544.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.e0b3e691.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.73dedd46.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.a7a61510.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.19af1cfc.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.078c9131.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.3da35573.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.ee1e2ba2.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.5796a618.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.26f3a028.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.cbc4b5ad.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.d79a5425.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.8dab2c77.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.f8e03fcd.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.f1c1f80f.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.a0b4da7e.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.8cf5825d.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.63173a34.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.a51cc121.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.55632279.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.aa190da2.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.c311f962.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.bef20aad.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.54dcb84b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.baae2fb3.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.de07d445.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.d8703177.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.93feb431.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.14ad8743.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.2e4d7d89.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.ebe6ec2f.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.a1a0d482.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.7353d51d.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.b546fd0e.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.fa14f195.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.ddaebd47.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.9f503937.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.95f81089.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.354471cd.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.c9d4ab47.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.9b369837.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.93069f29.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b6a68508.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.4cda471b.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.fec20cbf.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.46eb93f8.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.70884000.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.16cc56b7.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.0f6a9d34.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.ced5f781.js"><link rel="prefetch" href="/assets/00-Introduction.html.2b1f0852.js"><link rel="prefetch" href="/assets/00-Preface.html.e516d7c3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.86c4af1e.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.88cddd12.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.4da53003.js"><link rel="prefetch" href="/assets/04-Operators.html.f9d313c6.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.ecf81ffe.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.c35ecf1b.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.396e0a6f.js"><link rel="prefetch" href="/assets/08-Reuse.html.8c7c4047.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.2150cc57.js"><link rel="prefetch" href="/assets/10-Interfaces.html.6ee853fa.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.ae7b89c4.js"><link rel="prefetch" href="/assets/12-Collections.html.0483e4dd.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.63412e72.js"><link rel="prefetch" href="/assets/14-Streams.html.7e7cce42.js"><link rel="prefetch" href="/assets/15-Exceptions.html.c186f23a.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.b3313ffc.js"><link rel="prefetch" href="/assets/17-Files.html.7a9ad498.js"><link rel="prefetch" href="/assets/18-Strings.html.46e57539.js"><link rel="prefetch" href="/assets/19-Type-Information.html.b68894bf.js"><link rel="prefetch" href="/assets/20-Generics.html.3993804b.js"><link rel="prefetch" href="/assets/21-Arrays.html.4d150e5c.js"><link rel="prefetch" href="/assets/22-Enumerations.html.87d060f0.js"><link rel="prefetch" href="/assets/23-Annotations.html.0c455464.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.8485a02c.js"><link rel="prefetch" href="/assets/25-Patterns.html.4f5781b0.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.4e7ecda3.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.1a18282e.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.ec4969df.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.c956724d.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.ac5ea88b.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.26db6884.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.80dbdde9.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.613e991c.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.de90320b.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.1f3841f2.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.a3de1972.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.28579d58.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.aae5a747.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.4bf49d65.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.9d9599c8.js"><link rel="prefetch" href="/assets/GLOSSARY.html.d812823c.js"><link rel="prefetch" href="/assets/index.html.d25b0535.js"><link rel="prefetch" href="/assets/404.html.0c8252b8.js"><link rel="prefetch" href="/assets/index.html.d5cc08ad.js"><link rel="prefetch" href="/assets/index.html.1331f6ca.js"><link rel="prefetch" href="/assets/index.html.da6c3a69.js"><link rel="prefetch" href="/assets/index.html.1174fbbd.js"><link rel="prefetch" href="/assets/index.html.c73d2264.js"><link rel="prefetch" href="/assets/index.html.1e315145.js"><link rel="prefetch" href="/assets/index.html.514b72a3.js"><link rel="prefetch" href="/assets/index.html.b19f5086.js"><link rel="prefetch" href="/assets/index.html.1ac6115e.js"><link rel="prefetch" href="/assets/404.3a5fd86b.js"><link rel="prefetch" href="/assets/Layout.42785ec5.js"><link rel="prefetch" href="/assets/Slide.5e14cdfb.js"><link rel="prefetch" href="/assets/Blog.f29d76d0.js"><link rel="prefetch" href="/assets/auto.esm.15d52109.js"><link rel="prefetch" href="/assets/index.1842ee54.js"><link rel="prefetch" href="/assets/mermaid.esm.min.f71f1464.js"><link rel="prefetch" href="/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/assets/photoswipe.esm.92018b73.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="DTF&#39;s blog"><!----><span class="site-name hide-in-pad">DTF&#39;s blog</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guide/" class="nav-link" aria-label="使用指南"><i class="icon iconfont icon-creative"></i>使用指南<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/imdtf/blog" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" aria-labelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewbox="0 0 1024 1024" aria-labelledby="outlook"><title id="outlook" lang="en">outlook icon</title><g fill="currentColor"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></g></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-guide"></i><span class="title">语言</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-markdown"></i><span class="title">数据库</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-question"></i><span class="title">面试题</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/interview/java-base.html" class="nav-link sidebar-link sidebar-page" aria-label="基础篇"><!---->基础篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/interview/jvm.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="JVM 篇"><!---->JVM 篇<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_1、知识点汇总" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1、知识点汇总"><!---->1、知识点汇总<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_2、知识点详解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2、知识点详解："><!---->2、知识点详解：<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_3、说说类加载与卸载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3、说说类加载与卸载"><!---->3、说说类加载与卸载<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_4、简述一下-jvm-的内存模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4、简述一下 JVM 的内存模型"><!---->4、简述一下 JVM 的内存模型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_5、说说堆和栈的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5、说说堆和栈的区别"><!---->5、说说堆和栈的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_6、-什么时候会触发-fullgc" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6、 什么时候会触发 FullGC"><!---->6、 什么时候会触发 FullGC<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_7、什么是-java-虚拟机-为什么-java-被称作是-平台无关的编程语言" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？"><!---->7、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_8、java-内存结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8、Java 内存结构"><!---->8、Java 内存结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_9、说说对象分配规则" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9、说说对象分配规则"><!---->9、说说对象分配规则<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_10、描述一下-jvm-加载-class-文件的原理机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10、描述一下 JVM 加载 class 文件的原理机制？"><!---->10、描述一下 JVM 加载 class 文件的原理机制？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_11、说说-java-对象创建过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11、说说 Java 对象创建过程"><!---->11、说说 Java 对象创建过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_12、知道类的生命周期吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12、知道类的生命周期吗？"><!---->12、知道类的生命周期吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_13、简述-java-的对象结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="13、简述 Java 的对象结构"><!---->13、简述 Java 的对象结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_14、如何判断对象可以被回收" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="14、如何判断对象可以被回收？"><!---->14、如何判断对象可以被回收？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_15、jvm-的永久代中会发生垃圾回收么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15、JVM 的永久代中会发生垃圾回收么？"><!---->15、JVM 的永久代中会发生垃圾回收么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_16、你知道哪些垃圾收集算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="16、你知道哪些垃圾收集算法"><!---->16、你知道哪些垃圾收集算法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_17、调优命令有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17、调优命令有哪些？"><!---->17、调优命令有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_18、常见调优工具有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18、常见调优工具有哪些"><!---->18、常见调优工具有哪些<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_19、minor-gc-与-full-gc-分别在什么时候发生" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="19、Minor GC 与 Full GC 分别在什么时候发生？"><!---->19、Minor GC 与 Full GC 分别在什么时候发生？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_20、你知道哪些-jvm-性能调优参数-简单版回答" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="20、你知道哪些 JVM 性能调优参数？（简单版回答）"><!---->20、你知道哪些 JVM 性能调优参数？（简单版回答）<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_21、-对象一定分配在堆中吗-有没有了解逃逸分析技术" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="21、 对象一定分配在堆中吗？有没有了解逃逸分析技术？"><!---->21、 对象一定分配在堆中吗？有没有了解逃逸分析技术？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_22、虚拟机为什么使用元空间替换了永久代" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="22、虚拟机为什么使用元空间替换了永久代？"><!---->22、虚拟机为什么使用元空间替换了永久代？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_23、什么是-stop-the-world-什么是-oopmap-什么是安全点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="23、什么是 Stop The World ? 什么是 OopMap？什么是安全点？"><!---->23、什么是 Stop The World ? 什么是 OopMap？什么是安全点？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_24、说一下-jvm-的主要组成部分及其作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="24、说一下 JVM 的主要组成部分及其作用？"><!---->24、说一下 JVM 的主要组成部分及其作用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_25、什么是指针碰撞" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="25、什么是指针碰撞？"><!---->25、什么是指针碰撞？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_26-什么是空闲列表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="26，什么是空闲列表？"><!---->26，什么是空闲列表？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_27-什么是-tlab" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="27，什么是 TLAB？"><!---->27，什么是 TLAB？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_28、对象头具体都包含哪些内容" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="28、对象头具体都包含哪些内容？"><!---->28、对象头具体都包含哪些内容？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_29、你知道哪些-jvm-调优参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="29、你知道哪些 JVM 调优参数？"><!---->29、你知道哪些 JVM 调优参数？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_30、说一下-jvm-有哪些垃圾回收器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="30、说一下 JVM 有哪些垃圾回收器？"><!---->30、说一下 JVM 有哪些垃圾回收器？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_31、如何选择垃圾收集器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="31、如何选择垃圾收集器？"><!---->31、如何选择垃圾收集器？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_32、-什么是类加载器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="32、 什么是类加载器？"><!---->32、 什么是类加载器？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/jvm.html#_33、什么是-tomcat-类加载机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="33、什么是 tomcat 类加载机制？"><!---->33、什么是 tomcat 类加载机制？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/interview/multi-thread.html" class="nav-link sidebar-link sidebar-page" aria-label="多线程&amp;并发篇"><!---->多线程&amp;并发篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring.html" class="nav-link sidebar-link sidebar-page" aria-label="Spring 篇"><!---->Spring 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-boot.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringBoot 篇"><!---->SpringBoot 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-cloud.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringCloud 篇"><!---->SpringCloud 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/dubbo.html" class="nav-link sidebar-link sidebar-page" aria-label="Dubbo 篇"><!---->Dubbo 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/mybatis.html" class="nav-link sidebar-link sidebar-page" aria-label="MyBatis 篇"><!---->MyBatis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MySQL.html" class="nav-link sidebar-link sidebar-page" aria-label="MySQL 篇"><!---->MySQL 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/nginx.html" class="nav-link sidebar-link sidebar-page" aria-label="Nginx 篇"><!---->Nginx 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MQ.html" class="nav-link sidebar-link sidebar-page" aria-label="MQ 篇"><!---->MQ 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/linux.html" class="nav-link sidebar-link sidebar-page" aria-label="Linux 篇"><!---->Linux 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/zookeeper.html" class="nav-link sidebar-link sidebar-page" aria-label="Zookeeper 篇"><!---->Zookeeper 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/Redis.html" class="nav-link sidebar-link sidebar-page" aria-label="Redis 篇"><!---->Redis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/%E5%88%86%E5%B8%83%E5%BC%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="分布式篇"><!---->分布式篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/network.html" class="nav-link sidebar-link sidebar-page" aria-label="网络篇"><!---->网络篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/design-patterns.html" class="nav-link sidebar-link sidebar-page" aria-label="设计模式"><!---->设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/maven.html" class="nav-link sidebar-link sidebar-page" aria-label="maven 篇"><!---->maven 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/ElasticSearch.html" class="nav-link sidebar-link sidebar-page" aria-label="ElasticSearch 篇"><!---->ElasticSearch 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/tomcat.html" class="nav-link sidebar-link sidebar-page" aria-label="tomcat 篇"><!---->tomcat 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/git.html" class="nav-link sidebar-link sidebar-page" aria-label="Git 篇"><!---->Git 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/soft-power.html" class="nav-link sidebar-link sidebar-page" aria-label="软实力篇"><!---->软实力篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->JVM 篇</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" aria-labelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://github.com/imdtf" target="_blank" rel="noopener noreferrer">DTF</a></span><span property="author" content="DTF"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" aria-labelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年5月17日</span><meta property="datePublished" content="2022-05-17T15:50:18.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" aria-labelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 37 分钟</span><meta property="timeRequired" content="PT37M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_1、知识点汇总" class="router-link-active router-link-exact-active toc-link level2">1、知识点汇总</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_2、知识点详解" class="router-link-active router-link-exact-active toc-link level2">2、知识点详解：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_3、说说类加载与卸载" class="router-link-active router-link-exact-active toc-link level2">3、说说类加载与卸载</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_4、简述一下-jvm-的内存模型" class="router-link-active router-link-exact-active toc-link level2">4、简述一下 JVM 的内存模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_5、说说堆和栈的区别" class="router-link-active router-link-exact-active toc-link level2">5、说说堆和栈的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_6、-什么时候会触发-fullgc" class="router-link-active router-link-exact-active toc-link level2">6、 什么时候会触发 FullGC</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_7、什么是-java-虚拟机-为什么-java-被称作是-平台无关的编程语言" class="router-link-active router-link-exact-active toc-link level2">7、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_8、java-内存结构" class="router-link-active router-link-exact-active toc-link level2">8、Java 内存结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_9、说说对象分配规则" class="router-link-active router-link-exact-active toc-link level2">9、说说对象分配规则</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_10、描述一下-jvm-加载-class-文件的原理机制" class="router-link-active router-link-exact-active toc-link level2">10、描述一下 JVM 加载 class 文件的原理机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_11、说说-java-对象创建过程" class="router-link-active router-link-exact-active toc-link level2">11、说说 Java 对象创建过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_12、知道类的生命周期吗" class="router-link-active router-link-exact-active toc-link level2">12、知道类的生命周期吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_13、简述-java-的对象结构" class="router-link-active router-link-exact-active toc-link level2">13、简述 Java 的对象结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_14、如何判断对象可以被回收" class="router-link-active router-link-exact-active toc-link level2">14、如何判断对象可以被回收？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_15、jvm-的永久代中会发生垃圾回收么" class="router-link-active router-link-exact-active toc-link level2">15、JVM 的永久代中会发生垃圾回收么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_16、你知道哪些垃圾收集算法" class="router-link-active router-link-exact-active toc-link level2">16、你知道哪些垃圾收集算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_17、调优命令有哪些" class="router-link-active router-link-exact-active toc-link level2">17、调优命令有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_18、常见调优工具有哪些" class="router-link-active router-link-exact-active toc-link level2">18、常见调优工具有哪些</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_19、minor-gc-与-full-gc-分别在什么时候发生" class="router-link-active router-link-exact-active toc-link level2">19、Minor GC 与 Full GC 分别在什么时候发生？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_20、你知道哪些-jvm-性能调优参数-简单版回答" class="router-link-active router-link-exact-active toc-link level2">20、你知道哪些 JVM 性能调优参数？（简单版回答）</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_21、-对象一定分配在堆中吗-有没有了解逃逸分析技术" class="router-link-active router-link-exact-active toc-link level2">21、 对象一定分配在堆中吗？有没有了解逃逸分析技术？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_22、虚拟机为什么使用元空间替换了永久代" class="router-link-active router-link-exact-active toc-link level2">22、虚拟机为什么使用元空间替换了永久代？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_23、什么是-stop-the-world-什么是-oopmap-什么是安全点" class="router-link-active router-link-exact-active toc-link level2">23、什么是 Stop The World ? 什么是 OopMap？什么是安全点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_24、说一下-jvm-的主要组成部分及其作用" class="router-link-active router-link-exact-active toc-link level2">24、说一下 JVM 的主要组成部分及其作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_25、什么是指针碰撞" class="router-link-active router-link-exact-active toc-link level2">25、什么是指针碰撞？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_26-什么是空闲列表" class="router-link-active router-link-exact-active toc-link level2">26，什么是空闲列表？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_27-什么是-tlab" class="router-link-active router-link-exact-active toc-link level2">27，什么是 TLAB？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_28、对象头具体都包含哪些内容" class="router-link-active router-link-exact-active toc-link level2">28、对象头具体都包含哪些内容？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_29、你知道哪些-jvm-调优参数" class="router-link-active router-link-exact-active toc-link level2">29、你知道哪些 JVM 调优参数？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_30、说一下-jvm-有哪些垃圾回收器" class="router-link-active router-link-exact-active toc-link level2">30、说一下 JVM 有哪些垃圾回收器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_31、如何选择垃圾收集器" class="router-link-active router-link-exact-active toc-link level2">31、如何选择垃圾收集器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_32、-什么是类加载器" class="router-link-active router-link-exact-active toc-link level2">32、 什么是类加载器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/jvm.html#_33、什么是-tomcat-类加载机制" class="router-link-active router-link-exact-active toc-link level2">33、什么是 tomcat 类加载机制？</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h1 id="jvm-篇" tabindex="-1"><a class="header-anchor" href="#jvm-篇" aria-hidden="true">#</a> JVM 篇</h1><h2 id="_1、知识点汇总" tabindex="-1"><a class="header-anchor" href="#_1、知识点汇总" aria-hidden="true">#</a> 1、知识点汇总</h2><p>JVM 是 Java 运行基础, 面试时一定会遇到 JVM 的有关问题, 内容相对集中, 但对只是深度要求较高.</p><p>其中内存模型, 类加载机制, GC 是重点方面.性能调优部分更偏向应用, 重点突出实践能力.编译器优化和执行模式部分偏向于理论基础, 重点掌握知识点.</p><p>需了解 <strong>内存模型</strong>各部分作用, 保存哪些数据.</p><p><strong>类加载</strong>双亲委派加载机制, 常用加载器分别加载哪种类型的类.</p><p><strong>GC</strong>分代回收的思想和依据以及不同垃圾回收算法的回收思路和适合场景.</p><p><strong>性能调优</strong>常有 JVM 优化参数作用, 参数调优的依据, 常用的 JVM 分析工具能分析哪些问题以及使用方法.</p><p><strong>执行模式</strong>解释/编译/混合模式的优缺点, Java7 提供的分层编译技术, JIT 即时编译技术,OSR 栈上替换, C1/C2 编译器针对的场景,C2 针对的是 server 模式, 优化更激进.新技术方面 Java10 的 graal 编译器</p><p><strong>编译器优化</strong> javac 的编译过程,ast 抽象语法树, 编译器优化和运行器优化.</p><h2 id="_2、知识点详解" tabindex="-1"><a class="header-anchor" href="#_2、知识点详解" aria-hidden="true">#</a> 2、知识点详解：</h2><ol><li><p><strong>JVM内存模型：</strong></p><p>线程独占: 栈, 本地方法栈, 程序计数器线程共享: 堆, 方法区</p></li><li><p><strong>栈</strong>:</p><p>又称方法栈, 线程私有的, 线程执行方法是都会创建一个栈阵, 用来存储局部变量表, 操作栈, 动态链接, 方法出口等信息.调用方法时执行入栈, 方法返回式执行出栈.</p></li><li><p><strong>本地方法栈</strong>:</p><p>与栈类似, 也是用来保存执行方法的信息. 执行 Java 方法是使用栈, 执行 Native 方法时使用本地方法栈.</p></li><li><p><strong>程序计数器</strong>:</p><p>保存着当前线程执行的字节码位置, 每个线程工作时都有独立的计数器, 只为执行 Java 方法服务, 执行 Native 方法时, 程序计数器为空.</p></li><li><p><strong>堆</strong>:</p><p>JVM 内存管理最大的一块, 对被线程共享, 目的是存放对象的实例, 几乎所欲的对象实例都会放在这里, 当堆没有可用空间时, 会抛出 OOM 异常.根据对象的存活周期不同,JVM 把对象进行分代管理, 由垃圾回收器进行垃圾的回收管理</p></li><li><p><strong>方法区</strong>：</p><p>又称非堆区, 用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器优化后的代码等数据.1.7 的永久代和 1.8 的元空间都是方法区的一种实现</p></li><li><p><strong>JVM内存可见性</strong>:</p><p>JMM 是定义程序中变量的访问规则, 线程对于变量的操作只能在自己的工作内存中进行, 而不能直接对主内存操作.由于指令重排序, 读写的顺序会被打乱, 因此 JMM 需要提供原子性, 可见性, 有序性保证.</p></li></ol><h2 id="_3、说说类加载与卸载" tabindex="-1"><a class="header-anchor" href="#_3、说说类加载与卸载" aria-hidden="true">#</a> 3、说说类加载与卸载</h2><p><strong>加载过程</strong></p><p>// TODO image</p><ol><li><strong>加载</strong>通过类的完全限定名, 查找此类字节码文件, 利用字节码文件创建 Class 对象.</li><li>其中<strong>验证, 准备, 解析</strong>合称<strong>链接</strong></li></ol><ul><li><strong>验证</strong>确保 Class 文件符合当前虚拟机的要求, 不会危害到虚拟机自身安全.</li><li><strong>准备</strong>进行内存分配, 为 static 修饰的类变量分配内存, 并设置初始值(0 或 null).不包含 ﬁnal 修饰的静态变量, 因为 ﬁnal 变量在编译时分配.</li><li><strong>解析</strong>将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等.</li></ul><ol start="3"><li><p><strong>初始化</strong>主要完成静态块执行以及静态变量的赋值.先初始化父类, 再初始化当前类.只有对类主动使用时才会初始化.</p><p>触发条件包括, 创建类的实例时, 访问类的静态方法或静态变量的时候, 使用 Class.forName 反射类的时候, 或者某个子类初始化的时候.</p></li></ol><p>Java 自带的加载器加载的类, 在虚拟机的生命周期中是不会被卸载的, 只有用户自定义的加载器加载的类才可以被卸.</p><p><strong>加载机制-双亲委派模式</strong></p><p>双亲委派模式, 即加载器加载类时先把请求委托给自己的父类加载器执行, 直到顶层的启动类加载器.父类加载器能够完成加载则成功返回, 不能则子类加载器才自己尝试加载.</p><ul><li>优点:</li></ul><ol><li>避免类的重复加载</li><li>避免 Java 的核心 API 被篡改</li></ol><p><strong>分代回收</strong></p><p>分代回收基于两个事实: 大部分对象很快就不使用了, 还有一部分不会立即无用, 但也不会持续很长时间.</p><p>年轻代-&gt;标记-复制老年代-&gt;标记-清除</p><p><strong>回收算法</strong></p><ol><li><p>G1 算法</p><p>1.9 后默认的垃圾回收算法, 特点保持高回收率的同时减少停顿.采用每次只清理一部分, 而不是清理全部的增量式清理, 以保证停顿时间不会过长</p><p>其取消了年轻代与老年代的物理划分, 但仍属于分代收集器, 算法将堆分为若干个逻辑区域(region), 一部分用作年轻代, 一部分用作老年代, 还有用来存储巨型对象的分区.</p><p>同 CMS 相同, 会遍历所有对象, 标记引用情况, 清除对象后会对区域进行复制移动, 以整合碎片空间.</p><p>年轻代回收: 并行复制采用复制算法, 并行收集, 会 StopTheWorld.</p><p>老年代回收: 会对年轻代一并回收</p><p>初始标记完成堆 root 对象的标记, 会 StopTheWorld. 并发标记 GC 线程和应用线程并发执行. 最终标记完成三色标记周期, 会 StopTheWorld. 复制/清楚会优先对可回收空间加大的区域进行回收</p></li><li><p>ZGC 算法</p><p>前面提供的高效垃圾回收算法, 针对大堆内存设计, 可以处理 TB 级别的堆, 可以做到 10ms 以下的回收停顿时间.</p><ul><li>着色指针</li><li>读屏障</li><li>并发处理</li><li>基于 region</li><li>内存压缩(整理)</li></ul><p>roots 标记：标记 root 对象, 会 StopTheWorld. 并发标记：利用读屏障与应用线程一起运行标记, 可能会发生 StopTheWorld. 清除会清理标记为不可用的对象. roots 重定位：是对存活的对象进行移动, 以腾出大块内存空间, 减少碎片产生.重定位最开始会 StopTheWorld, 却决于重定位集与对象总活动集的比例. 并发重定位与并发标记类似.</p></li></ol><h2 id="_4、简述一下-jvm-的内存模型" tabindex="-1"><a class="header-anchor" href="#_4、简述一下-jvm-的内存模型" aria-hidden="true">#</a> 4、简述一下 JVM 的内存模型</h2><p><strong>JVM内存模型简介</strong></p><blockquote><p>JVM 定义了不同运行时数据区，他们是用来执行应用程序的。某些区域随着 JVM 启动及销毁，另外一些区域的数据是线程性独立的，随着线程创建和销毁。jvm 内存模型总体架构图如下：（摘自 oracle 官方网站）</p></blockquote><p>JVM 在执行 Java 程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建销毁时间。如下图所示，可以分为两大部分，线程私有区和共享区。下图是根据自己理解画的一个JVM 内存模型架构图：</p><p>JVM 内存分为线程私有区和线程共享区</p><ul><li><p>线程私有区</p><ol><li><p><strong>程序计数器</strong></p><p>当同时进行的线程数超过 CPU 数或其内核数时，就要通过时间片轮询分派 CPU 的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令。如果执行的是 JAVA 方法，计数器记录正在执行的 java 字节码地址，如果执行的是 native 方法，则计数器为空。</p></li><li><p><strong>虚拟机栈</strong></p><p>线程私有的，与线程在同一时间创建。管理 JAVA 方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss 参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出 stackOverﬂowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出 OutofMemoryError。 使用 jclasslib 工具可以查看 class 类文件的结构。下图为栈帧结构图：</p></li><li><p><strong>本地方法栈</strong></p><p>与虚拟机栈作用相似。但它不是为 Java 方法服务的，而是本地方法（C 语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p></li></ol></li><li><p>线程共享区</p><ol><li><p><strong>方法区</strong></p><p>线程共享的，用于存放被虚拟机加载的类的元数据信息，如常量、静态变量和即时编译器编译后的代码。若要分代，算是永久代（老年代），以前类大多“static”的，很少被卸载或收集，现回收废弃常量和无用的类。其中运行时常量池存放编译生成的各种常量。（如果 hotspot 虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的 ClassLoader 被回收）</p></li><li><p><strong>堆</strong></p><p>存放对象实例和数组，是垃圾回收的主要区域，分为新生代和老年代。刚创建的对象在新生代的 Eden 区中，经过 GC 后进入新生代的 S0 区中，再经过 GC 进入新生代的 S1 区中，15 次 GC 后仍存在就进入老年代。这是按照一种回收机制进行划分的，不是固定的。若堆的空间不够实例分配，则抛出 OutOfMemoryError异常。</p><table><thead><tr><th>位置</th><th>作用</th></tr></thead><tbody><tr><td>Young Generation</td><td>即图中的 Eden + From Space（s0） + To Space(s1)</td></tr><tr><td>Eden</td><td>存放新生的对象</td></tr><tr><td>Survivor Space</td><td>有两个，存放每次垃圾回收后存活的对象(s0+s1)</td></tr><tr><td>Old Generation</td><td>Tenured Generation 即图中的 Old Space 主要存放应用程序中生命周期长的存活对象</td></tr></tbody></table></li></ol></li></ul><h2 id="_5、说说堆和栈的区别" tabindex="-1"><a class="header-anchor" href="#_5、说说堆和栈的区别" aria-hidden="true">#</a> 5、说说堆和栈的区别</h2><p>栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。</p><ul><li><p><strong>功能不同</strong></p><p>栈内存用来存储局部变量和方法调用，而堆内存用来存储 Java 中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p></li><li><p><strong>共享性不同</strong></p><p>栈内存是线程私有的。 堆内存是所有线程共有的。</p></li><li><p><strong>异常错误不同</strong></p><p>如果栈内存或者堆内存不足都会抛出异常。 栈空间不足：java.lang.StackOverFlowError。 堆空间不足：java.lang.OutOfMemoryError。</p></li><li><p><strong>空间大小</strong></p><p>栈的空间大小远远小于堆的。</p></li></ul><h2 id="_6、-什么时候会触发-fullgc" tabindex="-1"><a class="header-anchor" href="#_6、-什么时候会触发-fullgc" aria-hidden="true">#</a> 6、 什么时候会触发 FullGC</h2><p>除直接调用 System.gc 外，触发 Full GC 执行的情况有如下四种。</p><ol><li><strong>旧生代空间不足</strong> 旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行 Full GC 后空间仍然不足，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的 FullGC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</li><li><strong>Permanet Generation空间满</strong> PermanetGeneration 中存放的为一些 class 的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，在未配置为采用 CMS GC 的情况下会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息： java.lang.OutOfMemoryError: PermGen space 为避免 Perm Gen 占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。</li><li><strong>CMS GC时出现 promotion failed和concurrent mode failure</strong> 对于采用 CMS 进行旧生代 GC 的程序而言，尤其要注意 GC 日志中是否有 promotion failed 和 concurrent mode failure 两种状况，当这两种状况出现时可能会触发 Full GC。 promotionfailed 是在进行 Minor GC 时，survivor space 放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。 应对措施为：增大 survivorspace、旧生代空间或调低触发并发 GC 的比率，但在 JDK 5.0+、6.0+的版本中有可能会由于 JDK 的 bug29 导致 CMS 在 remark 完毕后很久才触发 sweeping 动作。对于这种状况，可通过设置- XX:CMSMaxAbortablePrecleanTime=5（单位为 ms）来避免。</li><li><strong>统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</strong> 这是一个较为复杂的触发情况，Hotspot 为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行 Minor GC 时，做了一个判断，如果之前统计所得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发 Full GC。 例如程序第一次触发 MinorGC 后，有 6MB 的对象晋升到旧生代，那么当下一次 Minor GC 发生时，首先检查旧生代的剩余空间是否大于 6MB，如果小于 6MB，则执行 Full GC。 当新生代采用 PSGC 时，方式稍有不同，PS GC 是在 Minor GC 后也会检查，例如上面的例子中第一次 Minor GC 后，PS GC 会检查此时旧生代的剩余空间是否大于 6MB，如小于，则触发对旧生代的回收。 除了以上 4 种状况外，对于使用 RMI 来进行 RPC 或管理的 Sun JDK 应用而言，默认情况下会一小时执行一次 Full GC。可通过在启动时通过- java- Dsun.rmi.dgc.client.gcInterval=3600000 来设置 Full GC 执行的间隔时间或通过-XX:+DisableExplicitGC 来禁止 RMI 调用 System.gc。</li></ol><h2 id="_7、什么是-java-虚拟机-为什么-java-被称作是-平台无关的编程语言" tabindex="-1"><a class="header-anchor" href="#_7、什么是-java-虚拟机-为什么-java-被称作是-平台无关的编程语言" aria-hidden="true">#</a> 7、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？</h2><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。 Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p><h2 id="_8、java-内存结构" tabindex="-1"><a class="header-anchor" href="#_8、java-内存结构" aria-hidden="true">#</a> 8、Java 内存结构</h2><p>方法区和对是所有线程共享的内存区域；而 java 栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p><ul><li>Java 堆（Heap）, 是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</li><li>方法区（Method Area）, 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>程序计数器（Program Counter Register）, 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li><li>JVM 栈（JVM Stacks）, 与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>本地方法栈（Native Method Stacks）, 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。</li></ul><h2 id="_9、说说对象分配规则" tabindex="-1"><a class="header-anchor" href="#_9、说说对象分配规则" aria-hidden="true">#</a> 9、说说对象分配规则</h2><ul><li>对象优先分配在 Eden 区，如果 Eden 区没有足够的空间时，虚拟机执行一次 Minor GC。</li><li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li><li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1，知道达到阀值对象进入老年区。</li><li>动态判断对象的年龄。如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li><li>空间分配担保。每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC，如果小于检查 HandlePromotionFailure 设置，如果 true 则只进行 Monitor GC, 如果 false 则进行 Full GC。</li></ul><h2 id="_10、描述一下-jvm-加载-class-文件的原理机制" tabindex="-1"><a class="header-anchor" href="#_10、描述一下-jvm-加载-class-文件的原理机制" aria-hidden="true">#</a> 10、描述一下 JVM 加载 class 文件的原理机制？</h2><p>JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应的Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明：</p><ul><li>Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）</li><li>Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap</li><li>System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li></ul><h2 id="_11、说说-java-对象创建过程" tabindex="-1"><a class="header-anchor" href="#_11、说说-java-对象创建过程" aria-hidden="true">#</a> 11、说说 Java 对象创建过程</h2><ol><li>JVM 遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）</li><li>为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”</li><li>将除对象头外的对象内存空间初始化为 0</li><li>对对象头进行必要设置</li></ol><h2 id="_12、知道类的生命周期吗" tabindex="-1"><a class="header-anchor" href="#_12、知道类的生命周期吗" aria-hidden="true">#</a> 12、知道类的生命周期吗？</h2><p>类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程, 如下图</p><ul><li>加载，查找并加载类的二进制数据，在 Java 堆中也创建一个 java.lang.Class 类的对象</li><li>链接，链接又包含三块内容：验证、准备、初始化。 <ol><li>验证，文件格式、元数据、字节码、符号引用验证；</li><li>准备，为类的静态变量分配内存，并将其初始化为默认值；</li><li>解析，把类中的符号引用转换为直接引用</li></ol></li><li>初始化，为类的静态变量赋予正确的初始值</li><li>使用，new 出对象程序中使用</li><li>卸载，执行垃圾回收</li></ul><h2 id="_13、简述-java-的对象结构" tabindex="-1"><a class="header-anchor" href="#_13、简述-java-的对象结构" aria-hidden="true">#</a> 13、简述 Java 的对象结构</h2><p>Java 对象由三个部分组成：对象头、实例数据、对齐填充。</p><ul><li><p>对象头由两部分组成，</p><ol><li>第一部分存储对象自身的运行时数据：哈希码、GC 分代年龄、锁标识状态、线程持有的锁、偏向线程 ID（一般占 32/64 bit）。</li><li>第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。</li></ol></li><li><p>实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）</p></li><li><p>对齐填充：JVM 要求对象起始地址必须是 8 字节的整数倍（8 字节对齐）</p></li></ul><h2 id="_14、如何判断对象可以被回收" tabindex="-1"><a class="header-anchor" href="#_14、如何判断对象可以被回收" aria-hidden="true">#</a> 14、如何判断对象可以被回收？</h2><p>判断对象是否存活一般有两种方式：</p><ol><li>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加 1，引用释放时计数减 1，计数为 0 时可以回收。此方法简单，无法解决对象相互循环引用的问题。</li><li>可达性分析（Reachability Analysis）：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</li></ol><h2 id="_15、jvm-的永久代中会发生垃圾回收么" tabindex="-1"><a class="header-anchor" href="#_15、jvm-的永久代中会发生垃圾回收么" aria-hidden="true">#</a> 15、JVM 的永久代中会发生垃圾回收么？</h2><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。请参考下 Java8：从永久代到元数据区 (注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)</p><h2 id="_16、你知道哪些垃圾收集算法" tabindex="-1"><a class="header-anchor" href="#_16、你知道哪些垃圾收集算法" aria-hidden="true">#</a> 16、你知道哪些垃圾收集算法</h2><p>GC 最基础的算法有三种： 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p><ul><li>标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</li><li>复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li><li>标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li><li>分代收集算法，“分代收集”（Generational Collection）算法，把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</li></ul><h2 id="_17、调优命令有哪些" tabindex="-1"><a class="header-anchor" href="#_17、调优命令有哪些" aria-hidden="true">#</a> 17、调优命令有哪些？</h2><p>Sun JDK 监控和故障处理命令有 jps jstat jmap jhat jstack jinfo</p><ul><li>jps，JVM Process Status Tool, 显示指定系统内所有的 HotSpot 虚拟机进程。</li><li>jstat，JVM statistics Monitoring 是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。</li><li>jmap，JVM Memory Map 命令用于生成 heap dump 文件</li><li>jhat，JVM Heap Analysis Tool 命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump，jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看</li><li>jstack，用于生成 java 虚拟机当前时刻的线程快照。</li><li>jinfo，JVM Conﬁguration info 这个命令作用是实时查看和调整虚拟机运行参数。</li><li>arthas</li></ul><h2 id="_18、常见调优工具有哪些" tabindex="-1"><a class="header-anchor" href="#_18、常见调优工具有哪些" aria-hidden="true">#</a> 18、常见调优工具有哪些</h2><p>常用调优工具分为两类,jdk 自带监控工具：jconsole 和 jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p><ul><li>jconsole，Java Monitoring and Management Console 是从 java5 开始，在 JDK 中自带的 java 监控和管理控制台，用于对 JVM 中内存，线程和类等的监控</li><li>jvisualvm，jdk 自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC 变化等。</li><li>MAT，Memory Analyzer Tool，一个基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li><li>GChisto，一款专业分析 gc 日志的工具</li><li>arthas</li></ul><h2 id="_19、minor-gc-与-full-gc-分别在什么时候发生" tabindex="-1"><a class="header-anchor" href="#_19、minor-gc-与-full-gc-分别在什么时候发生" aria-hidden="true">#</a> 19、Minor GC 与 Full GC 分别在什么时候发生？</h2><p>新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC</p><h2 id="_20、你知道哪些-jvm-性能调优参数-简单版回答" tabindex="-1"><a class="header-anchor" href="#_20、你知道哪些-jvm-性能调优参数-简单版回答" aria-hidden="true">#</a> 20、你知道哪些 JVM 性能调优参数？（简单版回答）</h2><ul><li><p>设定堆内存大小</p><p>-Xmx：堆内存最大限制。</p></li><li><p>设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代</p><p>-XX:NewSize：新生代大小 -XX:NewRatio 新生代和老生代占比 -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p></li><li><p>设定垃圾回收器年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC</p></li></ul><h2 id="_21、-对象一定分配在堆中吗-有没有了解逃逸分析技术" tabindex="-1"><a class="header-anchor" href="#_21、-对象一定分配在堆中吗-有没有了解逃逸分析技术" aria-hidden="true">#</a> 21、 对象一定分配在堆中吗？有没有了解逃逸分析技术？</h2><ul><li><p><strong>「对象一定分配在堆中吗？」</strong></p><p>不一定的，JVM 通过<strong>逃逸分析</strong> ，那些逃不出方法的对象会在栈上分配。</p></li><li><p><strong>「什么时逃逸分析？」</strong></p><p>逃逸分析(Escape Analysis)，是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针发生了逃逸。</p></li><li><p><strong>「逃逸分析的好处」</strong></p><ol><li>栈上分配，可以降低垃圾收集器运行的频率。</li><li>同步消除，如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。</li><li>标量替换，把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有， <ul><li>减少内存使用，因为不用生成对象头。</li><li>程序内存回收效率高，并且 GC 频率也会减少。</li></ul></li></ol></li></ul><h2 id="_22、虚拟机为什么使用元空间替换了永久代" tabindex="-1"><a class="header-anchor" href="#_22、虚拟机为什么使用元空间替换了永久代" aria-hidden="true">#</a> 22、虚拟机为什么使用元空间替换了永久代？</h2><ul><li><p><strong>什么是元空间？什么是永久代？为什么用元空间代替永久代？</strong></p><p>我们先回顾一下<strong>方法区</strong> 吧, 看看虚拟机运行时数据内存图，如下:</p></li><li><p><strong>什么是永久代？它和方法区有什么关系呢？</strong></p><p>如果在 HotSpot 虚拟机上开发、部署，很多程序员都把方法区称作永久代。可以说方法区是规范，永久代是 Hotspot 针对该规范进行的实现。在 Java7 及以前的版本，方法区都是永久代实现的。</p></li><li><p><strong>什么是元空间？它和方法区有什么关系呢？</strong></p><p>对于 Java8，HotSpots 取消了永久代，取而代之的是元空间(Metaspace)。换句话说，就是方法区还是在的，只是实现变了，从永久代变为元空间了。</p></li><li><p><strong>为什么使用元空间替换了永久代？</strong></p><ul><li>永久代的方法区，和堆使用的物理内存是连续的。</li></ul><p><strong>「永久代」</strong> 是通过以下这两个参数配置大小的~</p><ul><li>-XX:PremSize：设置永久代的初始大小</li><li>-XX:MaxPermSize: 设置永久代的最大值，默认是 64M</li></ul><p>对于<strong>永久代</strong> ，如果动态生成很多 class 的话，就很可能出现 <strong>java.lang.OutOfMemoryError: PermGen space</strong> 错误，因为永久代空间配置有限嘛。最典型的场景是，在 web 开发比较多 jsp 页面的时候。</p><p>之后，方法区存在于元空间(Metaspace)。物理内存不再与堆连续，而是直接存在于本地内存中，理论上机器<strong>内存有多大，元空间就有多大</strong>。</p><p>可以通过以下的参数来设置元空间的大小:</p><ul><li>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时 GC 会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 MaxMetaspaceSize 时，适当提高该值。</li><li>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</li><li>-XX:MinMetaspaceFreeRatio，在 GC 之后，最小的 Metaspace 剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</li><li>-XX:MaxMetaspaceFreeRatio，在 GC 之后，最大的 Metaspace 剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</li></ul></li><li><p><strong>所以，为什么使用元空间替换永久代？</strong></p><p>表面上看是为了避免 OOM 异常。因为通常使用 PermSize 和 MaxPermSize 设置永久代的大小就决定了永久代的上限，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到 OOM 错误。当使用元空间时，可以加载多少类的元数据就不再由 MaxPermSize 控制, 而由系统的实际可用空间来控制啦。</p></li></ul><h2 id="_23、什么是-stop-the-world-什么是-oopmap-什么是安全点" tabindex="-1"><a class="header-anchor" href="#_23、什么是-stop-the-world-什么是-oopmap-什么是安全点" aria-hidden="true">#</a> 23、什么是 Stop The World ? 什么是 OopMap？什么是安全点？</h2><p>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为<strong>Stop The World</strong> 。也简称为 <strong>STW</strong> 。</p><p>在 HotSpot 中，有个数据结构（映射表）称为<strong>OopMap</strong> 。一旦类加载动作完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，记录到 OopMap。在即时编译过程中，也会在<strong>特定的位置</strong> 生成 OopMap，记录下栈上和寄存器里哪些位置是引用。</p><p>这些特定的位置主要在：</p><ol><li>循环的末尾（非 counted 循环）</li><li>方法临返回前 / 调用方法的 call 指令后</li><li>可能抛异常的位置</li></ol><p>这些位置就叫作<strong>安全点(safepoint)</strong> 。用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。</p><h2 id="_24、说一下-jvm-的主要组成部分及其作用" tabindex="-1"><a class="header-anchor" href="#_24、说一下-jvm-的主要组成部分及其作用" aria-hidden="true">#</a> 24、说一下 JVM 的主要组成部分及其作用？</h2><p>JVM 包含两个子系统和两个组件，分别为</p><ul><li><p><strong>Class loader(类装载子系统)</strong></p></li><li><p><strong>Execution engine(执行引擎子系统)</strong></p></li><li><p><strong>Runtime data area(运行时数据区组件)</strong></p></li><li><p><strong>Native Interface(本地接口组件)</strong></p></li><li><p><strong>Class loader(类装载)</strong> : 根据给定的全限定名类名(如：java.lang.Object)来装载 class 文件到运行时数据区的方法区中。</p></li><li><p><strong>Execution engine(执行引擎)</strong> : 执行 class 的指令。</p></li><li><p><strong>Native Interface(本地接口)</strong> : 与 native lib 交互，是其它编程语言交互的接口。</p></li><li><p><strong>Runtime data area(运行时数据区域)</strong> : 即我们常说的 JVM 的内存。</p><blockquote><p>首先通过编译器把 Java 源代码转换成字节码，Class loader(类装载)再把字节码加载到内存 中，将其放在运行时数据区的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p></blockquote></li></ul><h2 id="_25、什么是指针碰撞" tabindex="-1"><a class="header-anchor" href="#_25、什么是指针碰撞" aria-hidden="true">#</a> 25、什么是指针碰撞？</h2><p>一般情况下，JVM 的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java 虚拟机开始为新生对象分配内存。如果 Java 堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是指针碰撞。</p><h2 id="_26-什么是空闲列表" tabindex="-1"><a class="header-anchor" href="#_26-什么是空闲列表" aria-hidden="true">#</a> 26，什么是空闲列表？</h2><p>如果 Java 堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞啦，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</p><h2 id="_27-什么是-tlab" tabindex="-1"><a class="header-anchor" href="#_27-什么是-tlab" aria-hidden="true">#</a> 27，什么是 TLAB？</h2><p>可以把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在 Java 堆中预先分配一小块内存, 这就是 TLAB（Thread Local Allocation Buﬀer，本地线程分配缓存） 。虚拟机通过 <code>-:UseTLAB</code> 设定它的。</p><h2 id="_28、对象头具体都包含哪些内容" tabindex="-1"><a class="header-anchor" href="#_28、对象头具体都包含哪些内容" aria-hidden="true">#</a> 28、对象头具体都包含哪些内容？</h2><p>在我们常用的 Hotspot 虚拟机中，对象在内存中布局实际包含 3 个部分：</p><ol><li>对象头</li><li>实例数据</li><li>对齐填充</li></ol><p>而对象头包含两部分内容，Mark Word 中的内容会随着锁标志位而发生变化，所以只说存储结构就好了。</p><ol><li>对象自身运行时所需的数据，也被称为 Mark Word，也就是用于轻量级锁和偏向锁的关键点。具体的内容包含对象的 hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC 标记、偏向锁线程 ID、偏向锁时间戳。</li><li>存储类型指针，也就是指向类的元数据的指针，通过这个指针才能确定对象是属于哪个类的实例。</li></ol><p>如果是数组的话，则还包含了数组的长度。</p><h2 id="_29、你知道哪些-jvm-调优参数" tabindex="-1"><a class="header-anchor" href="#_29、你知道哪些-jvm-调优参数" aria-hidden="true">#</a> 29、你知道哪些 JVM 调优参数？</h2><ul><li>堆栈内存相关 <ul><li>-Xms 设置初始堆的大小</li><li>-Xmx 设置最大堆的大小</li><li>-Xmn 设置年轻代大小，相当于同时配置-XX:NewSize 和-XX:MaxNewSize 为一样的值</li><li>-Xss 每个线程的堆栈大小</li><li>-XX:NewSize 设置年轻代大小(for 1.3/1.4)</li><li>-XX:MaxNewSize 年轻代最大值(for 1.3/1.4)</li><li>-XX:NewRatio 年轻代与年老代的比值(除去持久代)</li><li>-XX:SurvivorRatio Eden 区与 Survivor 区的的比值</li><li>-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。</li><li>-XX:MaxTenuringThreshold 设定对象在 Survivor 复制的最大年龄阈值，超过阈值转移到老年代</li></ul></li><li>垃圾收集器相关 <ul><li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数</li><li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</li><li>-XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行 5 次 GC 以后对内存空间进行压缩、整理。</li><li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li></ul></li><li>辅助信息相关 <ul><li>-XX:+PrintGCDetails 打印 GC 详细信息</li><li>-XX:+HeapDumpOnOutOfMemoryError 让 JVM 在发生内存溢出的时候自动生成内存快照, 排查问题用</li><li>-XX:+DisableExplicitGC 禁止系统 System.gc()，防止手动误触发 FGC 造成问题.</li><li>-XX:+PrintTLAB 查看 TLAB 空间的使用情况</li></ul></li></ul><h2 id="_30、说一下-jvm-有哪些垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_30、说一下-jvm-有哪些垃圾回收器" aria-hidden="true">#</a> 30、说一下 JVM 有哪些垃圾回收器？</h2><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了 7 种作用于不同分代的收集器，其中用于回收新生代的收集器包括 Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括 Serial Old、Parallel Old、CMS，还有用于回收整个 Java 堆的G1 收集器。不同收集器之间的连线表示它们可以搭配使用。</p><ul><li><p>Serial 收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</p></li><li><p>ParNew 收集器 (复制算法): 新生代收并行集器，实际上是 Serial 收集器的多线程版本，在多核CPU 环境下有着比 Serial 更好的表现；</p></li><li><p>Parallel Scavenge 收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</p></li><li><p>Serial Old 收集器 (标记-整理算法): 老年代单线程收集器，Serial 收集器的老年代版本；</p></li><li><p>Parallel Old 收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge 收集器的老年代版本；</p></li><li><p>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。</p></li><li><p>G1(Garbage First)收集器 (标记-整理算法)： Java 堆并行收集器，G1 收集器是 JDK1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p></li><li><p>ZGC （Z Garbage Collector）是一款由 Oracle 公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态 Region 内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在 JDK 11 新加入，还在实验阶段，主要特点是：回收 TB 级内存（最大4T），停顿时间不超过 10ms。</p><ul><li><strong>优点</strong>：低停顿，高吞吐量, ZGC 收集过程中额外耗费的内存小。</li><li><strong>缺点</strong>：浮动垃圾</li></ul><p>目前使用的非常少，真正普及还是需要写时间的。<strong>新生代收集器</strong>：Serial、 ParNew 、 Parallel Scavenge<strong>老年</strong></p></li><li><p><strong>代收集器</strong>： CMS 、Serial Old、Parallel Old</p></li><li><p><strong>整堆收集器</strong>： G1 , ZGC (因为不涉年代不在图中)。</p></li></ul><h2 id="_31、如何选择垃圾收集器" tabindex="-1"><a class="header-anchor" href="#_31、如何选择垃圾收集器" aria-hidden="true">#</a> 31、如何选择垃圾收集器？</h2><ol><li><p>如果你的堆大小不是很大（比如 100MB ），选择串行收集器一般是效率最高的。参数： <code>-XX:+UseSerialGC</code> 。</p></li><li><p>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益。</p><p>参数： <code>-XX:+UseSerialGC</code> 。</p></li><li><p>如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的。</p><p>参数： <code>-XX:+UseParallelGC</code> 。</p></li><li><p>如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择 G1 、 ZGC 、 CMS 都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些。</p><p>参数：</p><p><code>-XX:+UseConcMarkSweepGC</code>、</p><p><code>-XX:+UseG1GC</code> 、</p><p><code>-XX:+UseZGC</code> 等 。</p><p>从上面这些出发点来看，我们平常的 Web 服务器，都是对响应性要求非常高的。选择性其实就集中在 CMS 、 G1 、 ZGC 上。而对于某些定时任务，使用并行收集器，是一个比较好的选择。</p></li></ol><h2 id="_32、-什么是类加载器" tabindex="-1"><a class="header-anchor" href="#_32、-什么是类加载器" aria-hidden="true">#</a> 32、 什么是类加载器？</h2><p>类加载器是一个用来加载类文件的类。Java 源代码通过 javac 编译器编译成类文件。然后 JVM 来执行类文件中的字节码来执行程序。类加载器负责加载文件系统、网络或其他来源的类文件。</p><h2 id="_33、什么是-tomcat-类加载机制" tabindex="-1"><a class="header-anchor" href="#_33、什么是-tomcat-类加载机制" aria-hidden="true">#</a> 33、什么是 tomcat 类加载机制？</h2><p>在 tomcat 中类的加载稍有不同，如下图：</p><p>当 tomcat 启动时，会创建几种类加载器：</p><ul><li><strong>Bootstrap 引导类加载器</strong> 加载 JVM 启动所需的类，以及标准扩展类（位于 jre/lib/ext 下）</li><li><strong>System 系统类加载器</strong> 加载 tomcat 启动的类，比如 bootstrap.jar，通常在 catalina.bat 或者 catalina.sh 中指定。位于 CATALINA_HOME/bin 下。</li><li><strong>Common 通用类加载器</strong></li></ul><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/imdtf/blog/edit/main/docs/interview/jvm.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" aria-labelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/5/18 23:27:14</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: imdtf@qq.com">DTF</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/interview/java-base.html" class="nav-link prev" aria-label="基础篇"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->基础篇</div></a><a href="/interview/multi-thread.html" class="nav-link next" aria-label="多线程&amp;并发篇"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">多线程&amp;并发篇<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2022 DTF</div></footer><!--]--></div><!--]--><!----><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewbox="0 0 1024 1024" aria-labelledby="close"><title id="close" lang="en">close icon</title><g fill="currentColor"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></g></svg></button><div class="logo"><!----><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!----><!----></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button class="install-button">安装<span></span></button><button class="cancel-button">取消</button></div></div></div></div><!--]--></div>
    <script type="module" src="/assets/app.597ce2f2.js" defer></script>
  </body>
</html>
