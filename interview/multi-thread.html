<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.43" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-v2-demo.mrhope.site/interview/multi-thread.html"><meta property="og:site_name" content="DTF's blog"><meta property="og:title" content="多线程&并发篇"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-05-19T15:59:47.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-05-19T15:59:47.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>多线程&并发篇 | DTF's blog</title><meta name="description" content="我的学习记录博客">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.af58f80f.css">
    <link rel="modulepreload" href="/assets/app.597ce2f2.js"><link rel="modulepreload" href="/assets/multi-thread.html.5d323dfe.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/multi-thread.html.3652cc7f.js"><link rel="prefetch" href="/assets/index.html.e173ef83.js"><link rel="prefetch" href="/assets/ElasticSearch.html.279e5d7b.js"><link rel="prefetch" href="/assets/MQ.html.9d040945.js"><link rel="prefetch" href="/assets/MySQL.html.d1ae2d1e.js"><link rel="prefetch" href="/assets/Redis.html.b201ad05.js"><link rel="prefetch" href="/assets/design-patterns.html.733535fa.js"><link rel="prefetch" href="/assets/dubbo.html.c776d990.js"><link rel="prefetch" href="/assets/git.html.72b47aa0.js"><link rel="prefetch" href="/assets/java-base.html.db5311da.js"><link rel="prefetch" href="/assets/jvm.html.53d34a5d.js"><link rel="prefetch" href="/assets/linux.html.65017b81.js"><link rel="prefetch" href="/assets/maven.html.ceec6571.js"><link rel="prefetch" href="/assets/mybatis.html.cb44fe5a.js"><link rel="prefetch" href="/assets/network.html.b1609fd9.js"><link rel="prefetch" href="/assets/nginx.html.9ca67d3a.js"><link rel="prefetch" href="/assets/soft-power.html.508fb44f.js"><link rel="prefetch" href="/assets/spring-boot.html.e888e4e7.js"><link rel="prefetch" href="/assets/spring-cloud.html.57c2b0d4.js"><link rel="prefetch" href="/assets/spring.html.94b261f5.js"><link rel="prefetch" href="/assets/tomcat.html.dc4aea03.js"><link rel="prefetch" href="/assets/zookeeper.html.75896320.js"><link rel="prefetch" href="/assets/分布式.html.6e369ff9.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.58f6dba8.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.04b85b76.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.116abb6a.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.1d83f138.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.40f6f1e4.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.900bda42.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.3492d336.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.dcc88998.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.7239f150.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.6199feb4.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.57624587.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.d99caa1b.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.cabd308f.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.c89015fe.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.6b8e9ff0.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.e1e4da4a.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.697b9a23.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.9000e742.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.4d12fb46.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.48d80708.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.da9eab5a.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.95150d1c.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.b9bda91b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.bb805e63.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.514eb232.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.4cfc99f3.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.1561ec1a.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.11ef8b3e.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.ef765715.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.50f4f1d6.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.60a1c908.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.b6c6ee60.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.0fa73bd5.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.bfe213be.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.e0558584.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.3087bc74.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.c5df5f6e.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.b9edc687.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.9906de00.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.4b8670c8.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.b78f67d4.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b762f081.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.e5ec66c1.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.f9b4c2c6.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.d4daa082.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.1f616fc4.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.25fe22f4.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.8bb53047.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.63f53d07.js"><link rel="prefetch" href="/assets/00-Introduction.html.aed5c856.js"><link rel="prefetch" href="/assets/00-Preface.html.feee9db3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.ab6ea8b6.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.0224a9bf.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.bea55af9.js"><link rel="prefetch" href="/assets/04-Operators.html.35525abf.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.c4cd86f5.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.b5c2b268.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.399ae58f.js"><link rel="prefetch" href="/assets/08-Reuse.html.0ab07e65.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.89443cf5.js"><link rel="prefetch" href="/assets/10-Interfaces.html.4948bb7b.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.b8f6a196.js"><link rel="prefetch" href="/assets/12-Collections.html.52f2a06b.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.db50a84d.js"><link rel="prefetch" href="/assets/14-Streams.html.9308751d.js"><link rel="prefetch" href="/assets/15-Exceptions.html.40e68d98.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.3edda5f0.js"><link rel="prefetch" href="/assets/17-Files.html.e87e7c99.js"><link rel="prefetch" href="/assets/18-Strings.html.a2842b17.js"><link rel="prefetch" href="/assets/19-Type-Information.html.12cc605b.js"><link rel="prefetch" href="/assets/20-Generics.html.3e4b17f6.js"><link rel="prefetch" href="/assets/21-Arrays.html.67720723.js"><link rel="prefetch" href="/assets/22-Enumerations.html.ab50f89b.js"><link rel="prefetch" href="/assets/23-Annotations.html.747faef3.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.5b9841aa.js"><link rel="prefetch" href="/assets/25-Patterns.html.10af6fe7.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.13f6de18.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.4774ac79.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.fec6d369.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.fe3a1870.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.35950f4f.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.54af4f5f.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.bb07240e.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.8f39ad15.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.39836314.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.ee52b83c.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.68302b50.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.9b5edd63.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.c8a5f6e1.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.34dcd815.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.8c0a6980.js"><link rel="prefetch" href="/assets/GLOSSARY.html.af317d6f.js"><link rel="prefetch" href="/assets/index.html.859506fe.js"><link rel="prefetch" href="/assets/404.html.61bcede7.js"><link rel="prefetch" href="/assets/index.html.6eefb2c9.js"><link rel="prefetch" href="/assets/index.html.276bb6b8.js"><link rel="prefetch" href="/assets/index.html.6c49b0c9.js"><link rel="prefetch" href="/assets/index.html.938faca6.js"><link rel="prefetch" href="/assets/index.html.234dfb8d.js"><link rel="prefetch" href="/assets/index.html.02cffa46.js"><link rel="prefetch" href="/assets/index.html.c70b19c7.js"><link rel="prefetch" href="/assets/index.html.e9ae5772.js"><link rel="prefetch" href="/assets/index.html.43ef8dd6.js"><link rel="prefetch" href="/assets/index.html.0319d1c3.js"><link rel="prefetch" href="/assets/ElasticSearch.html.1822d360.js"><link rel="prefetch" href="/assets/MQ.html.257a1eec.js"><link rel="prefetch" href="/assets/MySQL.html.12265bed.js"><link rel="prefetch" href="/assets/Redis.html.c5915ac6.js"><link rel="prefetch" href="/assets/design-patterns.html.4dff82bc.js"><link rel="prefetch" href="/assets/dubbo.html.70900b5c.js"><link rel="prefetch" href="/assets/git.html.9f0ce8a6.js"><link rel="prefetch" href="/assets/java-base.html.f9b49957.js"><link rel="prefetch" href="/assets/jvm.html.7b42d915.js"><link rel="prefetch" href="/assets/linux.html.9f1e7d55.js"><link rel="prefetch" href="/assets/maven.html.f848fc43.js"><link rel="prefetch" href="/assets/mybatis.html.868f5463.js"><link rel="prefetch" href="/assets/network.html.347740e9.js"><link rel="prefetch" href="/assets/nginx.html.acf44958.js"><link rel="prefetch" href="/assets/soft-power.html.fa4cc2bb.js"><link rel="prefetch" href="/assets/spring-boot.html.eb446c44.js"><link rel="prefetch" href="/assets/spring-cloud.html.5a2e7953.js"><link rel="prefetch" href="/assets/spring.html.e5d334fa.js"><link rel="prefetch" href="/assets/tomcat.html.1edb1280.js"><link rel="prefetch" href="/assets/zookeeper.html.d47f6f3b.js"><link rel="prefetch" href="/assets/分布式.html.8362b544.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.e0b3e691.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.73dedd46.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.a7a61510.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.19af1cfc.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.078c9131.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.3da35573.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.ee1e2ba2.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.5796a618.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.26f3a028.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.cbc4b5ad.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.d79a5425.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.8dab2c77.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.f8e03fcd.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.f1c1f80f.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.a0b4da7e.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.8cf5825d.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.63173a34.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.a51cc121.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.55632279.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.aa190da2.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.c311f962.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.bef20aad.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.54dcb84b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.baae2fb3.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.de07d445.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.d8703177.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.93feb431.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.14ad8743.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.2e4d7d89.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.ebe6ec2f.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.a1a0d482.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.7353d51d.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.b546fd0e.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.fa14f195.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.ddaebd47.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.9f503937.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.95f81089.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.354471cd.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.c9d4ab47.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.9b369837.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.93069f29.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b6a68508.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.4cda471b.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.fec20cbf.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.46eb93f8.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.70884000.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.16cc56b7.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.0f6a9d34.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.ced5f781.js"><link rel="prefetch" href="/assets/00-Introduction.html.2b1f0852.js"><link rel="prefetch" href="/assets/00-Preface.html.e516d7c3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.86c4af1e.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.88cddd12.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.4da53003.js"><link rel="prefetch" href="/assets/04-Operators.html.f9d313c6.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.ecf81ffe.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.c35ecf1b.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.396e0a6f.js"><link rel="prefetch" href="/assets/08-Reuse.html.8c7c4047.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.2150cc57.js"><link rel="prefetch" href="/assets/10-Interfaces.html.6ee853fa.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.ae7b89c4.js"><link rel="prefetch" href="/assets/12-Collections.html.0483e4dd.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.63412e72.js"><link rel="prefetch" href="/assets/14-Streams.html.7e7cce42.js"><link rel="prefetch" href="/assets/15-Exceptions.html.c186f23a.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.b3313ffc.js"><link rel="prefetch" href="/assets/17-Files.html.7a9ad498.js"><link rel="prefetch" href="/assets/18-Strings.html.46e57539.js"><link rel="prefetch" href="/assets/19-Type-Information.html.b68894bf.js"><link rel="prefetch" href="/assets/20-Generics.html.3993804b.js"><link rel="prefetch" href="/assets/21-Arrays.html.4d150e5c.js"><link rel="prefetch" href="/assets/22-Enumerations.html.87d060f0.js"><link rel="prefetch" href="/assets/23-Annotations.html.0c455464.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.8485a02c.js"><link rel="prefetch" href="/assets/25-Patterns.html.4f5781b0.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.4e7ecda3.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.1a18282e.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.ec4969df.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.c956724d.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.ac5ea88b.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.26db6884.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.80dbdde9.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.613e991c.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.de90320b.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.1f3841f2.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.a3de1972.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.28579d58.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.aae5a747.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.4bf49d65.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.9d9599c8.js"><link rel="prefetch" href="/assets/GLOSSARY.html.d812823c.js"><link rel="prefetch" href="/assets/index.html.d25b0535.js"><link rel="prefetch" href="/assets/404.html.0c8252b8.js"><link rel="prefetch" href="/assets/index.html.d5cc08ad.js"><link rel="prefetch" href="/assets/index.html.1331f6ca.js"><link rel="prefetch" href="/assets/index.html.da6c3a69.js"><link rel="prefetch" href="/assets/index.html.1174fbbd.js"><link rel="prefetch" href="/assets/index.html.c73d2264.js"><link rel="prefetch" href="/assets/index.html.1e315145.js"><link rel="prefetch" href="/assets/index.html.514b72a3.js"><link rel="prefetch" href="/assets/index.html.b19f5086.js"><link rel="prefetch" href="/assets/index.html.1ac6115e.js"><link rel="prefetch" href="/assets/404.3a5fd86b.js"><link rel="prefetch" href="/assets/Layout.42785ec5.js"><link rel="prefetch" href="/assets/Slide.5e14cdfb.js"><link rel="prefetch" href="/assets/Blog.f29d76d0.js"><link rel="prefetch" href="/assets/auto.esm.15d52109.js"><link rel="prefetch" href="/assets/index.1842ee54.js"><link rel="prefetch" href="/assets/mermaid.esm.min.f71f1464.js"><link rel="prefetch" href="/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/assets/photoswipe.esm.92018b73.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="DTF&#39;s blog"><!----><span class="site-name hide-in-pad">DTF&#39;s blog</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guide/" class="nav-link" aria-label="使用指南"><i class="icon iconfont icon-creative"></i>使用指南<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/imdtf/blog" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" aria-labelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewbox="0 0 1024 1024" aria-labelledby="outlook"><title id="outlook" lang="en">outlook icon</title><g fill="currentColor"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></g></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-guide"></i><span class="title">语言</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-markdown"></i><span class="title">数据库</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-question"></i><span class="title">面试题</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/interview/java-base.html" class="nav-link sidebar-link sidebar-page" aria-label="基础篇"><!---->基础篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/jvm.html" class="nav-link sidebar-link sidebar-page" aria-label="JVM 篇"><!---->JVM 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/interview/multi-thread.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="多线程&amp;并发篇"><!---->多线程&amp;并发篇<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_1、说说-java-中实现多线程有几种方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1、说说 Java 中实现多线程有几种方法"><!---->1、说说 Java 中实现多线程有几种方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_2、如何停止一个正在运行的线程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2、如何停止一个正在运行的线程"><!---->2、如何停止一个正在运行的线程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_3、notify-和-notifyall-有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3、notify()和 notifyAll()有什么区别？"><!---->3、notify()和 notifyAll()有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_4、sleep-和-wait-有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4、sleep()和 wait() 有什么区别？"><!---->4、sleep()和 wait() 有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_5、volatile-是什么-可以保证有序性吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5、volatile 是什么?可以保证有序性吗?"><!---->5、volatile 是什么?可以保证有序性吗?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_6、thread-类中的-start-和-run-方法有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6、Thread 类中的 start() 和 run() 方法有什么区别？"><!---->6、Thread 类中的 start() 和 run() 方法有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_7、为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7、为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？"><!---->7、为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_8、为什么-wait-和-notify-方法要在同步块中调用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8、为什么 wait 和 notify 方法要在同步块中调用？"><!---->8、为什么 wait 和 notify 方法要在同步块中调用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_9、java-中-interrupted-和-isinterrupted-方法的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9、Java 中 interrupted 和 isInterrupted 方法的区别？"><!---->9、Java 中 interrupted 和 isInterrupted 方法的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_10、java-中-synchronized-和-reentrantlock-有什么不同" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10、Java 中 synchronized 和 ReentrantLock 有什么不同？"><!---->10、Java 中 synchronized 和 ReentrantLock 有什么不同？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_11、有三个线程-t1-t2-t3-如何保证顺序执行" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11、有三个线程 T1, T2, T3 如何保证顺序执行？"><!---->11、有三个线程 T1, T2, T3 如何保证顺序执行？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_12、synchronizedmap-和-concurrenthashmap-有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12、SynchronizedMap 和 ConcurrentHashMap 有什么区别？"><!---->12、SynchronizedMap 和 ConcurrentHashMap 有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_13、什么是线程安全" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="13、什么是线程安全"><!---->13、什么是线程安全<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_14、thread-类中的-yield-方法有什么作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="14、Thread 类中的 yield 方法有什么作用？"><!---->14、Thread 类中的 yield 方法有什么作用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_15、java-线程池中-submit-和-execute-方法有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15、Java 线程池中 submit() 和 execute() 方法有什么区别？"><!---->15、Java 线程池中 submit() 和 execute() 方法有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_16、说一说自己对于-synchronized-关键字的了解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="16、说一说自己对于 synchronized 关键字的了解"><!---->16、说一说自己对于 synchronized 关键字的了解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_17、说说自己是怎么使用-synchronized-关键字" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17、说说自己是怎么使用 synchronized 关键字？"><!---->17、说说自己是怎么使用 synchronized 关键字？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_18、什么是线程安全-vector-是一个线程安全类吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18、什么是线程安全？Vector 是一个线程安全类吗？"><!---->18、什么是线程安全？Vector 是一个线程安全类吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_19、-volatile-关键字的作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="19、 volatile 关键字的作用？"><!---->19、 volatile 关键字的作用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_20、常用的线程池有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="20、常用的线程池有哪些？"><!---->20、常用的线程池有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_21、简述一下你对线程池的理解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="21、简述一下你对线程池的理解"><!---->21、简述一下你对线程池的理解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_22、java-程序是如何执行的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="22、Java 程序是如何执行的"><!---->22、Java 程序是如何执行的<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_23、锁的优化机制了解吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="23、锁的优化机制了解吗？"><!---->23、锁的优化机制了解吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_24、说说进程和线程的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="24、说说进程和线程的区别？"><!---->24、说说进程和线程的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_25-产生死锁的四个必要条件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="25，产生死锁的四个必要条件？"><!---->25，产生死锁的四个必要条件？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_26、如何避免死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="26、如何避免死锁？"><!---->26、如何避免死锁？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_27-线程池核心线程数怎么设置呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="27，线程池核心线程数怎么设置呢？"><!---->27，线程池核心线程数怎么设置呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_28-java-线程池中队列常用类型有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="28，Java 线程池中队列常用类型有哪些？"><!---->28，Java 线程池中队列常用类型有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_29-线程安全需要保证几个基本特征" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="29，线程安全需要保证几个基本特征？"><!---->29，线程安全需要保证几个基本特征？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_30-说一下线程之间是如何通信的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="30，说一下线程之间是如何通信的？"><!---->30，说一下线程之间是如何通信的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_31、cas-的原理呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="31、CAS 的原理呢？"><!---->31、CAS 的原理呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_32、cas-有什么缺点吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="32、CAS 有什么缺点吗？"><!---->32、CAS 有什么缺点吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_33、引用类型有哪些-有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="33、引用类型有哪些？有什么区别？"><!---->33、引用类型有哪些？有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_34、说说-threadlocal-原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="34、说说 ThreadLocal 原理？"><!---->34、说说 ThreadLocal 原理？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_35、线程池原理知道吗-以及核心参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="35、线程池原理知道吗？以及核心参数"><!---->35、线程池原理知道吗？以及核心参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_36、-线程池的拒绝策略有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="36、 线程池的拒绝策略有哪些？"><!---->36、 线程池的拒绝策略有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_37、说说你对-jmm-内存模型的理解-为什么需要-jmm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="37、说说你对 JMM 内存模型的理解？为什么需要 JMM？"><!---->37、说说你对 JMM 内存模型的理解？为什么需要 JMM？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_38、多线程有什么用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="38、多线程有什么用？"><!---->38、多线程有什么用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_39、说说-cyclicbarrier-和-countdownlatch-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="39、说说 CyclicBarrier 和 CountDownLatch 的区别？"><!---->39、说说 CyclicBarrier 和 CountDownLatch 的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_40、什么是-aqs" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="40、什么是 AQS？"><!---->40、什么是 AQS？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_41、了解-semaphore-吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="41、了解 Semaphore 吗？"><!---->41、了解 Semaphore 吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_42、什么是-callable-和-future" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="42、什么是 Callable 和 Future?"><!---->42、什么是 Callable 和 Future?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_43、什么是阻塞队列-阻塞队列的实现原理是什么-如何使用阻塞队列来实现生产者-消费者模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="43、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><!---->43、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_44、什么是多线程中的上下文切换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="44、什么是多线程中的上下文切换？"><!---->44、什么是多线程中的上下文切换？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_45、什么是-daemon-线程-它有什么意义" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="45、什么是 Daemon 线程？它有什么意义？"><!---->45、什么是 Daemon 线程？它有什么意义？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/multi-thread.html#_46、乐观锁和悲观锁的理解及如何实现-有哪些实现方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="46、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><!---->46、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/interview/spring.html" class="nav-link sidebar-link sidebar-page" aria-label="Spring 篇"><!---->Spring 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-boot.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringBoot 篇"><!---->SpringBoot 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-cloud.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringCloud 篇"><!---->SpringCloud 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/dubbo.html" class="nav-link sidebar-link sidebar-page" aria-label="Dubbo 篇"><!---->Dubbo 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/mybatis.html" class="nav-link sidebar-link sidebar-page" aria-label="MyBatis 篇"><!---->MyBatis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MySQL.html" class="nav-link sidebar-link sidebar-page" aria-label="MySQL 篇"><!---->MySQL 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/nginx.html" class="nav-link sidebar-link sidebar-page" aria-label="Nginx 篇"><!---->Nginx 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MQ.html" class="nav-link sidebar-link sidebar-page" aria-label="MQ 篇"><!---->MQ 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/linux.html" class="nav-link sidebar-link sidebar-page" aria-label="Linux 篇"><!---->Linux 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/zookeeper.html" class="nav-link sidebar-link sidebar-page" aria-label="Zookeeper 篇"><!---->Zookeeper 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/Redis.html" class="nav-link sidebar-link sidebar-page" aria-label="Redis 篇"><!---->Redis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/%E5%88%86%E5%B8%83%E5%BC%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="分布式篇"><!---->分布式篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/network.html" class="nav-link sidebar-link sidebar-page" aria-label="网络篇"><!---->网络篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/design-patterns.html" class="nav-link sidebar-link sidebar-page" aria-label="设计模式"><!---->设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/maven.html" class="nav-link sidebar-link sidebar-page" aria-label="maven 篇"><!---->maven 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/ElasticSearch.html" class="nav-link sidebar-link sidebar-page" aria-label="ElasticSearch 篇"><!---->ElasticSearch 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/tomcat.html" class="nav-link sidebar-link sidebar-page" aria-label="tomcat 篇"><!---->tomcat 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/git.html" class="nav-link sidebar-link sidebar-page" aria-label="Git 篇"><!---->Git 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/soft-power.html" class="nav-link sidebar-link sidebar-page" aria-label="软实力篇"><!---->软实力篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->多线程&amp;并发篇</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" aria-labelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://github.com/imdtf" target="_blank" rel="noopener noreferrer">DTF</a></span><span property="author" content="DTF"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" aria-labelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年5月18日</span><meta property="datePublished" content="2022-05-18T15:27:14.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" aria-labelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 43 分钟</span><meta property="timeRequired" content="PT43M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_1、说说-java-中实现多线程有几种方法" class="router-link-active router-link-exact-active toc-link level2">1、说说 Java 中实现多线程有几种方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_2、如何停止一个正在运行的线程" class="router-link-active router-link-exact-active toc-link level2">2、如何停止一个正在运行的线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_3、notify-和-notifyall-有什么区别" class="router-link-active router-link-exact-active toc-link level2">3、notify()和 notifyAll()有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_4、sleep-和-wait-有什么区别" class="router-link-active router-link-exact-active toc-link level2">4、sleep()和 wait() 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_5、volatile-是什么-可以保证有序性吗" class="router-link-active router-link-exact-active toc-link level2">5、volatile 是什么?可以保证有序性吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_6、thread-类中的-start-和-run-方法有什么区别" class="router-link-active router-link-exact-active toc-link level2">6、Thread 类中的 start() 和 run() 方法有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_7、为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面" class="router-link-active router-link-exact-active toc-link level2">7、为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_8、为什么-wait-和-notify-方法要在同步块中调用" class="router-link-active router-link-exact-active toc-link level2">8、为什么 wait 和 notify 方法要在同步块中调用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_9、java-中-interrupted-和-isinterrupted-方法的区别" class="router-link-active router-link-exact-active toc-link level2">9、Java 中 interrupted 和 isInterrupted 方法的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_10、java-中-synchronized-和-reentrantlock-有什么不同" class="router-link-active router-link-exact-active toc-link level2">10、Java 中 synchronized 和 ReentrantLock 有什么不同？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_11、有三个线程-t1-t2-t3-如何保证顺序执行" class="router-link-active router-link-exact-active toc-link level2">11、有三个线程 T1, T2, T3 如何保证顺序执行？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_12、synchronizedmap-和-concurrenthashmap-有什么区别" class="router-link-active router-link-exact-active toc-link level2">12、SynchronizedMap 和 ConcurrentHashMap 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_13、什么是线程安全" class="router-link-active router-link-exact-active toc-link level2">13、什么是线程安全</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_14、thread-类中的-yield-方法有什么作用" class="router-link-active router-link-exact-active toc-link level2">14、Thread 类中的 yield 方法有什么作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_15、java-线程池中-submit-和-execute-方法有什么区别" class="router-link-active router-link-exact-active toc-link level2">15、Java 线程池中 submit() 和 execute() 方法有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_16、说一说自己对于-synchronized-关键字的了解" class="router-link-active router-link-exact-active toc-link level2">16、说一说自己对于 synchronized 关键字的了解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_17、说说自己是怎么使用-synchronized-关键字" class="router-link-active router-link-exact-active toc-link level2">17、说说自己是怎么使用 synchronized 关键字？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_18、什么是线程安全-vector-是一个线程安全类吗" class="router-link-active router-link-exact-active toc-link level2">18、什么是线程安全？Vector 是一个线程安全类吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_19、-volatile-关键字的作用" class="router-link-active router-link-exact-active toc-link level2">19、 volatile 关键字的作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_20、常用的线程池有哪些" class="router-link-active router-link-exact-active toc-link level2">20、常用的线程池有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_21、简述一下你对线程池的理解" class="router-link-active router-link-exact-active toc-link level2">21、简述一下你对线程池的理解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_22、java-程序是如何执行的" class="router-link-active router-link-exact-active toc-link level2">22、Java 程序是如何执行的</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_23、锁的优化机制了解吗" class="router-link-active router-link-exact-active toc-link level2">23、锁的优化机制了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_24、说说进程和线程的区别" class="router-link-active router-link-exact-active toc-link level2">24、说说进程和线程的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_25-产生死锁的四个必要条件" class="router-link-active router-link-exact-active toc-link level2">25，产生死锁的四个必要条件？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_26、如何避免死锁" class="router-link-active router-link-exact-active toc-link level2">26、如何避免死锁？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_27-线程池核心线程数怎么设置呢" class="router-link-active router-link-exact-active toc-link level2">27，线程池核心线程数怎么设置呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_28-java-线程池中队列常用类型有哪些" class="router-link-active router-link-exact-active toc-link level2">28，Java 线程池中队列常用类型有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_29-线程安全需要保证几个基本特征" class="router-link-active router-link-exact-active toc-link level2">29，线程安全需要保证几个基本特征？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_30-说一下线程之间是如何通信的" class="router-link-active router-link-exact-active toc-link level2">30，说一下线程之间是如何通信的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_31、cas-的原理呢" class="router-link-active router-link-exact-active toc-link level2">31、CAS 的原理呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_32、cas-有什么缺点吗" class="router-link-active router-link-exact-active toc-link level2">32、CAS 有什么缺点吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_33、引用类型有哪些-有什么区别" class="router-link-active router-link-exact-active toc-link level2">33、引用类型有哪些？有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_34、说说-threadlocal-原理" class="router-link-active router-link-exact-active toc-link level2">34、说说 ThreadLocal 原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_35、线程池原理知道吗-以及核心参数" class="router-link-active router-link-exact-active toc-link level2">35、线程池原理知道吗？以及核心参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_36、-线程池的拒绝策略有哪些" class="router-link-active router-link-exact-active toc-link level2">36、 线程池的拒绝策略有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_37、说说你对-jmm-内存模型的理解-为什么需要-jmm" class="router-link-active router-link-exact-active toc-link level2">37、说说你对 JMM 内存模型的理解？为什么需要 JMM？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_38、多线程有什么用" class="router-link-active router-link-exact-active toc-link level2">38、多线程有什么用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_39、说说-cyclicbarrier-和-countdownlatch-的区别" class="router-link-active router-link-exact-active toc-link level2">39、说说 CyclicBarrier 和 CountDownLatch 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_40、什么是-aqs" class="router-link-active router-link-exact-active toc-link level2">40、什么是 AQS？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_41、了解-semaphore-吗" class="router-link-active router-link-exact-active toc-link level2">41、了解 Semaphore 吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_42、什么是-callable-和-future" class="router-link-active router-link-exact-active toc-link level2">42、什么是 Callable 和 Future?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_43、什么是阻塞队列-阻塞队列的实现原理是什么-如何使用阻塞队列来实现生产者-消费者模型" class="router-link-active router-link-exact-active toc-link level2">43、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_44、什么是多线程中的上下文切换" class="router-link-active router-link-exact-active toc-link level2">44、什么是多线程中的上下文切换？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_45、什么是-daemon-线程-它有什么意义" class="router-link-active router-link-exact-active toc-link level2">45、什么是 Daemon 线程？它有什么意义？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/multi-thread.html#_46、乐观锁和悲观锁的理解及如何实现-有哪些实现方式" class="router-link-active router-link-exact-active toc-link level2">46、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h1 id="多线程-并发篇" tabindex="-1"><a class="header-anchor" href="#多线程-并发篇" aria-hidden="true">#</a> 多线程&amp;并发篇</h1><h2 id="_1、说说-java-中实现多线程有几种方法" tabindex="-1"><a class="header-anchor" href="#_1、说说-java-中实现多线程有几种方法" aria-hidden="true">#</a> 1、说说 Java 中实现多线程有几种方法</h2><p>创建线程的常用三种方式：</p><ol><li>继承 <strong>Thread</strong> 类</li><li>实现 <strong>Runnable</strong> 接口</li><li>实现 <strong>Callable</strong> 接口 (JDK&gt;=1.5)</li><li><strong>线程池</strong> 方式创建</li></ol><p>通过继承 Thread 类或者实现 Runnable 接口、Callable 接口都可以实现多线程，不过实现 Runnable 接口与实现 Callable 接口的方式基本相同，只是 Callable 接口里定义的方法返回值，可以声明抛出异常而已。因此将实现 Runnable 接口和实现 Callable 接口归为一种方式。</p><ul><li>采用实现 Runnable、Callable 接口的方式创建线程的优缺点 <ul><li><strong>优点</strong> ：线程类只是实现了 Runnable 或者 Callable 接口，还可以继承其他类。这种方式下，多个线程可以共享一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。</li><li><strong>缺点</strong> ：编程稍微复杂一些，如果需要访问当前线程，则必须使用<code>Thread.currentThread()</code> 方法</li></ul></li><li>采用继承 Thread 类的方式创建线程的优缺点 <ul><li><strong>优点</strong> ：编写简单，如果需要访问当前线程，则无需使用<code>Thread.currentThread()</code> 方法，直接使用<code>this</code> 即可获取当前线程</li><li><strong>缺点</strong>：因为线程类已经继承了 Thread 类，Java 语言是单继承的，所以就不能再继承其他父类了。</li></ul></li></ul><h2 id="_2、如何停止一个正在运行的线程" tabindex="-1"><a class="header-anchor" href="#_2、如何停止一个正在运行的线程" aria-hidden="true">#</a> 2、如何停止一个正在运行的线程</h2><ol><li><p>使用退出标志，使线程正常退出，也就是当 run 方法完成后线程终止。</p></li><li><p>使用 stop 方法强行终止，但是不推荐这个方法，因为 stop 和 suspend 及 resume 一样都是过期作废的方法。</p></li><li><p>使用 interrupt 方法中断线程。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; is running&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;week up from blcok...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 在异常处理代码中修改共享变量的状态</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; is exiting...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">InterruptThreadDemo3</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThread</span> m1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Starting thread...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        m1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Interrupt thread...: &quot;</span> <span class="token operator">+</span> m1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        m1<span class="token punctuation">.</span>stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 设置共享变量为 true</span>
        m1<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻塞时退出阻塞状态</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 主线程休眠 3 秒以便观察线程 m1 的中断情况</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Stopping application...&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div></li></ol><h2 id="_3、notify-和-notifyall-有什么区别" tabindex="-1"><a class="header-anchor" href="#_3、notify-和-notifyall-有什么区别" aria-hidden="true">#</a> 3、notify()和 notifyAll()有什么区别？</h2><p>notify 可能会导致死锁，而 notifyAll 则不会</p><p>任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行 synchronized 中的代码使用 notifyall,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。</p><p>wait() 应配合 while 循环使用，不应使用 if，务必在 wait()调用前后都检查条件，如果不满足，必须调用 notify()唤醒另外的线程来处理，自己继续 wait()直至条件满足再往下执行。</p><p>notify() 是对 notifyAll()的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死锁。正确的场景应该是 WaitSet 中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续 notify()下一个线程，并且自身需要重新回到 WaitSet 中.</p><h2 id="_4、sleep-和-wait-有什么区别" tabindex="-1"><a class="header-anchor" href="#_4、sleep-和-wait-有什么区别" aria-hidden="true">#</a> 4、sleep()和 wait() 有什么区别？</h2><p>对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于 Object 类中的。</p><p>sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用 sleep()方法的过程中，线程不会释放对象锁。</p><p>当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。</p><h2 id="_5、volatile-是什么-可以保证有序性吗" tabindex="-1"><a class="header-anchor" href="#_5、volatile-是什么-可以保证有序性吗" aria-hidden="true">#</a> 5、volatile 是什么?可以保证有序性吗?</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile 关键字会强制将修改的值立即写入主存。</li><li>禁止进行指令重排序。</li></ol><p>volatile 不是原子性操作</p><p>什么叫保证部分有序性?</p><p>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 语句 1</span>
y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 语句 2</span>
flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//语句 3</span>
x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 语句 4</span>
y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 语句 5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>由于 ﬂag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句 3 放到语句 1、语句 2 前面，也不会讲语句 3 放到语句 4、语句 5 后面。但是要注意语句 1 和语句 2 的顺序、语句 4 和语句 5 的顺序是不作任何保证的。</p><p>使用 volatile 一般用于状态标记量和单例模式的双检锁。</p><h2 id="_6、thread-类中的-start-和-run-方法有什么区别" tabindex="-1"><a class="header-anchor" href="#_6、thread-类中的-start-和-run-方法有什么区别" aria-hidden="true">#</a> 6、Thread 类中的 start() 和 run() 方法有什么区别？</h2><p>start()方法被用来启动新创建的线程，而且 start()内部调用了 run()方法，这和直接调用 run()方法的效果不一样。当你调用 run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p><h2 id="_7、为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面" tabindex="-1"><a class="header-anchor" href="#_7、为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面" aria-hidden="true">#</a> 7、为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？</h2><p>明显的原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的 wait()方法就有意义了。如果 wait()方法定义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象。</p><h2 id="_8、为什么-wait-和-notify-方法要在同步块中调用" tabindex="-1"><a class="header-anchor" href="#_8、为什么-wait-和-notify-方法要在同步块中调用" aria-hidden="true">#</a> 8、为什么 wait 和 notify 方法要在同步块中调用？</h2><ol><li>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的 wait(),notify()和 notifyAll()方法。</li><li>如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。</li><li>还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。</li></ol><p>wait()方法强制当前线程释放对象锁。这意味着在调用某对象的 wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的 wait()方法。</p><p>在调用对象的 notify()和 notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的 notify()或 notifyAll()方法。</p><p>调用 wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用 notify()或 notifyAll() 方法的原因通常是，调用线程希望告诉其他等待中的线程:&quot;<strong>特殊状态已经被设置</strong>&quot;。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。</p><h2 id="_9、java-中-interrupted-和-isinterrupted-方法的区别" tabindex="-1"><a class="header-anchor" href="#_9、java-中-interrupted-和-isinterrupted-方法的区别" aria-hidden="true">#</a> 9、Java 中 interrupted 和 isInterrupted 方法的区别？</h2><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java 多线程的中断机制是用内部标识来实现的，调用 Thread.interrupt()来中断一个线程就会设置中断标识为 true。当中断线程调用静态方法 Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法 isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出 InterruptedException 异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p><h2 id="_10、java-中-synchronized-和-reentrantlock-有什么不同" tabindex="-1"><a class="header-anchor" href="#_10、java-中-synchronized-和-reentrantlock-有什么不同" aria-hidden="true">#</a> 10、Java 中 synchronized 和 ReentrantLock 有什么不同？</h2><ul><li><p>相似点：</p><p>这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.</p></li><li><p>区别：</p><p>这两种方式最大区别就是对于 Synchronized 来说，它是 java 语言的关键字，是原生语法层面的互斥，需要 jvm 实现。而 ReentrantLock 它是 JDK 1.5 之后提供的 API 层面的互斥锁，需要 lock()和 unlock()方法配合 try/ﬁnally 语句块来完成。</p><p>Synchronized 进过编译，会在同步块的前后分别形成 monitorenter 和 monitorexit 这个两个字节码指令。在执行 monitorenter 指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加 1，相应的，在执行 monitorexit 指令时会将锁计算器就减 1，当计算器为 0 时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p><p>由于 ReentrantLock 是 java.util.concurrent 包下提供的一套互斥锁，相比 Synchronized，ReentrantLock 类提供了一些高级功能，主要有以下 3 项：</p><ol><li>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于 Synchronized 来说可以避免出现死锁的情况。</li><li>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized 锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数 true 设为公平锁，但公平锁表现的性能不是很好。</li><li>锁绑定多个条件，一个 ReentrantLock 对象可以同时绑定对个对象。</li></ol></li></ul><h2 id="_11、有三个线程-t1-t2-t3-如何保证顺序执行" tabindex="-1"><a class="header-anchor" href="#_11、有三个线程-t1-t2-t3-如何保证顺序执行" aria-hidden="true">#</a> 11、有三个线程 T1, T2, T3 如何保证顺序执行？</h2><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的 join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3 调用 T2，T2 调用 T1)，这样 T1 就会先完成而 T3 最后完成。</p><p>实际上先启动三个线程中哪一个都行, 因为在每个线程的 run 方法中用 join 方法限定了三个线程的执行顺序。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JoinTest2</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 引用 t1 线程，等待 t1 线程执行完</span>
                t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 引用 t2 线程，等待 t2 线程执行完</span>
                t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;t3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里三个线程的启动顺序可以任意，大家可以试下！</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="_12、synchronizedmap-和-concurrenthashmap-有什么区别" tabindex="-1"><a class="header-anchor" href="#_12、synchronizedmap-和-concurrenthashmap-有什么区别" aria-hidden="true">#</a> 12、SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h2><p>SynchronizedMap()和 Hashtable 一样，实现上在调用 map 所有方法时，都对整个 map 进行同步。而 ConcurrentHashMap 的实现却更加精细，它对 map 中的所有桶加了锁。所以，只要有一个线程访问 map，其他线程就无法进入 map，而如果一个线程在访问 ConcurrentHashMap 某个桶时，其他线程，仍然可以对 map 执行某些操作。</p><p>所以，ConcurrentHashMap 在性能以及安全性方面，明显比 Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历 map 时，如果其他线程试图对 map 进行数据修改，也不会抛出 ConcurrentModiﬁcationException。</p><h2 id="_13、什么是线程安全" tabindex="-1"><a class="header-anchor" href="#_13、什么是线程安全" aria-hidden="true">#</a> 13、什么是线程安全</h2><p>线程安全就是说多线程访问同一段代码，不会产生不确定的结果。</p><p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><ol><li><p>不可变</p><p>像 String、Integer、Long 这些，都是 ﬁnal 类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p></li><li><p>绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java 中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java 中也有，比方说 CopyOnWriteArrayList、CopyOnWriteArraySet</p></li><li><p>相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像 Vector 这种，add、remove 方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个 Vector、有个线程同时在 add 这个 Vector，99%的情况下都会出现 ConcurrentModiﬁcationException，也就是<strong>fail-fast</strong> 机制。</p></li><li><p>线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap 等都是线程非安全的类</p></li></ol><h2 id="_14、thread-类中的-yield-方法有什么作用" tabindex="-1"><a class="header-anchor" href="#_14、thread-类中的-yield-方法有什么作用" aria-hidden="true">#</a> 14、Thread 类中的 yield 方法有什么作用？</h2><p>Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用 CPU，执行 yield()的线程有可能在进入到暂停状态后马上又被执行。</p><h2 id="_15、java-线程池中-submit-和-execute-方法有什么区别" tabindex="-1"><a class="header-anchor" href="#_15、java-线程池中-submit-和-execute-方法有什么区别" aria-hidden="true">#</a> 15、Java 线程池中 submit() 和 execute() 方法有什么区别？</h2><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定义在 Executor 接口中,而 submit()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。</p><h2 id="_16、说一说自己对于-synchronized-关键字的了解" tabindex="-1"><a class="header-anchor" href="#_16、说一说自己对于-synchronized-关键字的了解" aria-hidden="true">#</a> 16、说一说自己对于 synchronized 关键字的了解</h2><p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h2 id="_17、说说自己是怎么使用-synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#_17、说说自己是怎么使用-synchronized-关键字" aria-hidden="true">#</a> 17、说说自己是怎么使用 synchronized 关键字？</h2><ul><li><p><strong>修饰实例方法</strong>:</p><p>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</p></li><li><p><strong>修饰静态方法</strong>:</p><p>也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</strong></p></li><li><p><strong>修饰代码块</strong>:</p><p>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p></li><li><p><strong>总结</strong>：</p><p>synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！可以使用 synchronized(a.intern())。</p></li></ul><h2 id="_18、什么是线程安全-vector-是一个线程安全类吗" tabindex="-1"><a class="header-anchor" href="#_18、什么是线程安全-vector-是一个线程安全类吗" aria-hidden="true">#</a> 18、什么是线程安全？Vector 是一个线程安全类吗？</h2><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的 ArrayList 不是线程安全的。</p><h2 id="_19、-volatile-关键字的作用" tabindex="-1"><a class="header-anchor" href="#_19、-volatile-关键字的作用" aria-hidden="true">#</a> 19、 volatile 关键字的作用？</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：</p><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。 volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。</li><li>volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul><h2 id="_20、常用的线程池有哪些" tabindex="-1"><a class="header-anchor" href="#_20、常用的线程池有哪些" aria-hidden="true">#</a> 20、常用的线程池有哪些？</h2><ul><li><strong>newSingleThreadExecutor</strong> ：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li><strong>newFixedThreadPool</strong> ：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</li><li><strong>newCachedThreadPool</strong> ：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</li><li><strong>newScheduledThreadPool</strong> ：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li><li><strong>newSingleThreadExecutor</strong> ：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ul><h2 id="_21、简述一下你对线程池的理解" tabindex="-1"><a class="header-anchor" href="#_21、简述一下你对线程池的理解" aria-hidden="true">#</a> 21、简述一下你对线程池的理解</h2><p>（如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略）合理利用线程池能够带来三个好处。</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h2 id="_22、java-程序是如何执行的" tabindex="-1"><a class="header-anchor" href="#_22、java-程序是如何执行的" aria-hidden="true">#</a> 22、Java 程序是如何执行的</h2><p>我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse 等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者 war 包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java 程序内部是如何执行的？其实不论是在开发工具中运行还是在 Tomcat 中运行，Java 程序的执行流程基本都是相同的，它的执行流程如下：</p><ul><li>先把 Java 代码编译成字节码，也就是把 .java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java 源代码 -&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字符码生成器 -&gt;最终生成字节码，其中任何一个节点执行失败就会造成编译失败；</li><li>把 class 文件放置到 Java 虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM；</li><li>Java 虚拟机使用类加载器（Class Loader）装载 class 文件；</li><li>类加载完成之后，会进行字节码效验，字节码效验通过之后 JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。Java 程序执行流程图如下：</li></ul><p>// TODO image</p><h2 id="_23、锁的优化机制了解吗" tabindex="-1"><a class="header-anchor" href="#_23、锁的优化机制了解吗" aria-hidden="true">#</a> 23、锁的优化机制了解吗？</h2><p>从 JDK1.6 版本之后，synchronized 本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。</p><p>锁的状态从低到高依次为<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong> ，升级的过程就是从低到高，降级在一定条件也是有可能发生的。</p><ul><li><p><strong>自旋锁</strong> ：</p><p>由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining 来开启，自旋的默认次数是 10 次，可以使用-XX:PreBlockSpin 设置。</p></li><li><p><strong>自适应锁</strong> ：</p><p>自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。</p></li><li><p><strong>锁消除</strong> ：锁消除指的是 JVM 检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p></li><li><p><strong>锁粗化</strong> ：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外。</p></li><li><p><strong>偏向锁</strong> ：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程 ID，之后这个线程再次进入同步块时都不需要 CAS 来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以用过设置-XX:+UseBiasedLocking 开启偏向锁。</p></li><li><p><strong>轻量级锁</strong> ：JVM 的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM 将会使用 CAS 方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试自旋来获得锁。</p><p>整个锁升级的过程非常复杂，我尽力去除一些无用的环节，简单来描述整个升级的机制。</p><p>简单点说，偏向锁就是通过对象头的偏向线程 ID 来对比，甚至都不需要 CAS 了，而轻量级锁主要就是通过 CAS 修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。</p><p>// TODO image</p></li></ul><h2 id="_24、说说进程和线程的区别" tabindex="-1"><a class="header-anchor" href="#_24、说说进程和线程的区别" aria-hidden="true">#</a> 24、说说进程和线程的区别？</h2><ol><li>进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位。</li><li>线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）</li><li>线程上下文的切换比进程上下文切换要快很多。 <ol><li>进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置。</li><li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li></ol></li></ol><h2 id="_25-产生死锁的四个必要条件" tabindex="-1"><a class="header-anchor" href="#_25-产生死锁的四个必要条件" aria-hidden="true">#</a> 25，产生死锁的四个必要条件？</h2><ol><li><p>互斥条件：一个资源每次只能被一个线程使用</p></li><li><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</p></li><li><p>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺</p></li><li><p>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</p></li></ol><h2 id="_26、如何避免死锁" tabindex="-1"><a class="header-anchor" href="#_26、如何避免死锁" aria-hidden="true">#</a> 26、如何避免死锁？</h2><p>指定获取锁的顺序，举例如下：</p><ol><li>比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？</li><li>获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！</li></ol><h2 id="_27-线程池核心线程数怎么设置呢" tabindex="-1"><a class="header-anchor" href="#_27-线程池核心线程数怎么设置呢" aria-hidden="true">#</a> 27，线程池核心线程数怎么设置呢？</h2><p>分为 CPU 密集型和 IO 密集型</p><ul><li><p><strong>CPU 密集型</strong></p><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p></li><li><p><strong>IO 密集型</strong></p><p>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ： 核心线程数=CPU 核心数量*2。</p></li></ul><h2 id="_28-java-线程池中队列常用类型有哪些" tabindex="-1"><a class="header-anchor" href="#_28-java-线程池中队列常用类型有哪些" aria-hidden="true">#</a> 28，Java 线程池中队列常用类型有哪些？</h2><ul><li><p><code>ArrayBlockingQueue</code> 是一个基于数组结构的<strong>有界阻塞队列</strong>，此队列按 FIFO（先进先出）原则对元素进行排序。</p></li><li><p><code>LinkedBlockingQueue</code> 一个基于链表结构的<strong>阻塞队列</strong>，此队列按 FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue 。</p></li><li><p><code>SynchronousQueue</code> 一个不存储元素的<strong>阻塞队列</strong>。</p></li><li><p><code>PriorityBlockingQueue</code> 是一个具有优先级的<strong>无限阻塞队列</strong>。PriorityBlockingQueue 也是基于最小二叉堆实现</p></li><li><p><code>DelayQueue</code> 是一个没有大小限制的队列, 只有当其指定的延迟时间到了，才能够从队列中获取到该元素。 因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p></li></ul><p>这里能说出前三种也就差不多了，如果能说全那是最好。</p><h2 id="_29-线程安全需要保证几个基本特征" tabindex="-1"><a class="header-anchor" href="#_29-线程安全需要保证几个基本特征" aria-hidden="true">#</a> 29，线程安全需要保证几个基本特征？</h2><ul><li><strong>原子性</strong> ，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li><li><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li><li><strong>有序性</strong> ，是保证线程内串行语义，避免指令重排等。</li></ul><h2 id="_30-说一下线程之间是如何通信的" tabindex="-1"><a class="header-anchor" href="#_30-说一下线程之间是如何通信的" aria-hidden="true">#</a> 30，说一下线程之间是如何通信的？</h2><p>线程之间的通信有两种方式：共享内存和消息传递。</p><ul><li><p><strong>共享内存</strong> :</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p><p>例如上图线程 A 与线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p><ol><li>线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。</li><li>线程 B 到主内存中去读取线程 A 之前更新过的共享变量。</li></ol></li><li><p><strong>消息传递</strong></p></li></ul><p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 <code>wait() </code> 和 <code>notify()</code> ，或者 <code>BlockingQueue</code> 。</p><h2 id="_31、cas-的原理呢" tabindex="-1"><a class="header-anchor" href="#_31、cas-的原理呢" aria-hidden="true">#</a> 31、CAS 的原理呢？</h2><p>CAS 叫做 CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：</p><ol><li><p>变量内存地址，V 表示</p></li><li><p>旧的预期值，A 表示</p></li><li><p>准备设置的新值，B 表示执行 CAS 指令时，只有当 V 等于 A 时，才会用 B 去更新 V 的值，否则就不会执行更新操作。</p></li></ol><h2 id="_32、cas-有什么缺点吗" tabindex="-1"><a class="header-anchor" href="#_32、cas-有什么缺点吗" aria-hidden="true">#</a> 32、CAS 有什么缺点吗？</h2><p>CAS 的缺点主要有 3 点：</p><ol><li><p><strong>ABA</strong> 问题：</p><p>ABA 的问题指的是在 CAS 更新的过程中，当读取到的值是 A，然后准备赋值的时候仍然是 A，但是实际上有可能 A 的值被改成了 B，然后又被改回了 A，这个 CAS 更新的漏洞就叫做 ABA。只是 ABA 的问题大部分场景下都不影响并发的最终效果。</p><p>Java 中有 AtomicStampedReference 来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p></li><li><p><strong>循环时间长开销大</strong>：</p><p>自旋 CAS 的方式如果长时间不成功，会给 CPU 带来很大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong>：</p><p>只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过 AtomicReference 来处理或者使用锁 synchronized 实现。</p></li></ol><h2 id="_33、引用类型有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#_33、引用类型有哪些-有什么区别" aria-hidden="true">#</a> 33、引用类型有哪些？有什么区别？</h2><p>引用类型主要分为强软弱虚四种：</p><ol><li>强引用指的就是代码中普遍存在的赋值方式，比如 <code>A a = new A()</code> 这种。强引用关联的对象，永远不会被 GC 回收。</li><li>软引用可以用<code> SoftReference</code> 来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。</li><li>弱引用可以用 <code>WeakReference</code> 来描述，他的强度比软引用更低一点，弱引用的对象下一次 GC 的时候一定会被回收，而不管内存是否足够。</li><li>虚引用也被称作幻影引用，是最弱的引用关系，可以用 <code>PhantomReference</code> 来描述，他必须和 <code>ReferenceQueue</code> 一起使用，同样的当发生 GC 的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。</li></ol><h2 id="_34、说说-threadlocal-原理" tabindex="-1"><a class="header-anchor" href="#_34、说说-threadlocal-原理" aria-hidden="true">#</a> 34、说说 ThreadLocal 原理？</h2><p>ThreadLocal 可以理解为线程本地变量，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于 synchronized 的做法是用空间来换时间。</p><p>ThreadLocal 有一个静态内部类 ThreadLocalMap，ThreadLocalMap 又包含了一个 Entry 数组，Entry 本身是一个弱引用，他的 key 是指向 ThreadLocal 的弱引用，Entry 具备了保存 key value 键值对的能力。</p><p>弱引用的目的是为了防止内存泄露，如果是强引用那么 ThreadLocal 对象除非线程结束否则始终无法被回收，弱引用则会在下一次 GC 的时候被回收。</p><p>但是这样还是会存在内存泄露的问题，假如 key 和 ThreadLocal 对象被回收之后，entry 中就存在 key 为 null，但是 value 有值的 entry 对象，但是永远没办法被访问到，同样除非线程结束运行。</p><p>但是只要 ThreadLocal 使用恰当，在使用完之后调用 remove 方法删除 Entry 对象，实际上是不会出现这个问题的。</p><h2 id="_35、线程池原理知道吗-以及核心参数" tabindex="-1"><a class="header-anchor" href="#_35、线程池原理知道吗-以及核心参数" aria-hidden="true">#</a> 35、线程池原理知道吗？以及核心参数</h2><p>首先线程池有几个核心的参数概念：</p><ol><li><p>最大线程数 <code>maximumPoolSize</code></p></li><li><p>核心线程数 <code>corePoolSize</code></p></li><li><p>活跃时间 <code>keepAliveTime</code></p></li><li><p>阻塞队列 <code>workQueue</code></p></li><li><p>拒绝策略 <code>RejectedExecutionHandler</code></p></li></ol><p>提交一个新任务到线程池时，具体的执行流程如下：</p><ol><li><p>当我们提交任务，线程池会根据 corePoolSize 大小创建若干任务数量线程执行任务</p></li><li><p>当任务的数量超过 corePoolSize 数量，后续的任务将会进入阻塞队列阻塞排队</p></li><li><p>当阻塞队列也满了之后，那么将会继续创建(maximumPoolSize-corePoolSize)个数量的线程来执行任务，如果任务处理完成，maximumPoolSize-corePoolSize 额外创建的线程等待 keepAliveTime 之后被自动销毁</p></li><li><p>如果达到 maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理</p></li></ol><h2 id="_36、-线程池的拒绝策略有哪些" tabindex="-1"><a class="header-anchor" href="#_36、-线程池的拒绝策略有哪些" aria-hidden="true">#</a> 36、 线程池的拒绝策略有哪些？</h2><p>主要有 4 种拒绝策略：</p><ol><li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li><li>CallerRunsPolicy：只用调用者所在的线程来处理任务</li><li>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务，也不抛出异常</li></ol><h2 id="_37、说说你对-jmm-内存模型的理解-为什么需要-jmm" tabindex="-1"><a class="header-anchor" href="#_37、说说你对-jmm-内存模型的理解-为什么需要-jmm" aria-hidden="true">#</a> 37、说说你对 JMM 内存模型的理解？为什么需要 JMM？</h2><p>随着 CPU 和内存的发展速度差异的问题，导致 CPU 的速度远快于内存，所以现在的 CPU 加入了高速缓存，高速缓存一般可以分为 L1、L2、L3 三级缓存。基于上面的例子我们知道了这导致了缓存一致性的问题，所以加入了缓存一致性协议，同时导致了内存可见性的问题，而编译器和 CPU 的重排序导致了原子性和有序性的问题，JMM 内存模型正是对多线程操作下的一系列规范约束，因为不可能让陈雇员的代码去兼容所有的 CPU，通过 JMM 我们才屏蔽了不同硬件和操作系统内存的访问差异，这样保证了 Java 程序在不同的平台下达到一致的内存访问效果，同时也是保证在高效并发的时候程序能够正确执行。</p><ul><li><p><strong>原子性</strong> ：</p><p>Java 内存模型通过 read、load、assign、use、store、write 来保证原子性操作，此外还有 lock 和 unlock，直接对应着 synchronized 关键字的 monitorenter 和 monitorexit 字节码指令。</p></li><li><p><strong>可见性</strong> ：</p><p>可见性的问题在上面的回答已经说过，Java 保证可见性可以认为通过 volatile、synchronized、ﬁnal 来实现。</p></li><li><p><strong>有序性</strong> ：</p><p>由于处理器和编译器的重排序导致的有序性问题，Java 通过 volatile、synchronized 来保证。</p></li><li><p><strong>happen-before 规则</strong> :</p><p>虽然指令重排提高了并发的性能，但是 Java 虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：</p><ol><li>单线程每个操作，happen-before 于该线程中任意后续操作</li><li>volatile 写 happen-before 与后续对这个变量的读</li><li>synchronized 解锁 happen-before 后续对这个锁的加锁</li><li>ﬁnal 变量的写 happen-before 于 ﬁnal 域对象的读，happen-before 后续对 ﬁnal 变量的读</li><li>传递性规则，A 先于 B，B 先于 C，那么 A 一定先于 C 发生</li></ol></li></ul><p>说了半天，到底工作内存和主内存是什么？</p><p>主内存可以认为就是物理内存，Java 内存模型中实际就是虚拟机内存的一部分。而工作内存就是 CPU 缓存，他有可能是寄存器也有可能是 L1\L2\L3 缓存，都是有可能的。</p><h2 id="_38、多线程有什么用" tabindex="-1"><a class="header-anchor" href="#_38、多线程有什么用" aria-hidden="true">#</a> 38、多线程有什么用？</h2><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓&quot;知其然知其所以然&quot;，&quot;会用&quot;只是&quot;知其然&quot;，&quot;为什么用&quot;才是&quot;知其所以然&quot;，只有达到&quot;知其然知其所以然&quot;的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><ol><li><p><strong>发挥多核 CPU 的优势</strong></p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4 核、8 核甚至 16 核的也都不少见，如果是单线程的程序，那么在双核 CPU 上就浪费了 50%，在 4 核 CPU 上就浪费了 75%。单核 CPU 上所谓的多线程那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程同时运行罢了。多核 CPU 上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核 CPU 的优势来，达到充分利用 CPU 的目的。</p></li><li><p><strong>防止阻塞</strong></p><p>从程序运行效率的角度来看，单核 CPU 不但不会发挥出多线程的优势，反而会因为在单核 CPU 上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核 CPU 我们还是要应用多线程，就是为了防止阻塞。试想，如果单核 CPU 使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止 运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p></li><li><p><strong>便于建模</strong></p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务 A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务 A 分解成几个小任务，任务 B、任务 C、任务 D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p></li></ol><h2 id="_39、说说-cyclicbarrier-和-countdownlatch-的区别" tabindex="-1"><a class="header-anchor" href="#_39、说说-cyclicbarrier-和-countdownlatch-的区别" aria-hidden="true">#</a> 39、说说 CyclicBarrier 和 CountDownLatch 的区别？</h2><p>两个看上去有点像的类，都在 java.util.concurrent 下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><ol><li>CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch 则不是，某线程运行到某个点上之后，只是给某个数值-1 而已，该线程继续运行</li><li>CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务</li><li>CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为 0 该 CountDownLatch 就不可再用了</li></ol><h2 id="_40、什么是-aqs" tabindex="-1"><a class="header-anchor" href="#_40、什么是-aqs" aria-hidden="true">#</a> 40、什么是 AQS？</h2><p>简单说一下 AQS，AQS 全称为 AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说 java.util.concurrent 的基础是 CAS 的话，那么 AQS 就是整个 Java 并发包的核心了，ReentrantLock、CountDownLatch、Semaphore 等等都用到了它。AQS 实际上以双向队列的形式连接所有的 Entry，比方说 ReentrantLock，所有等待的线程都被放在一个 Entry 中并连成双向队列，前面一个线程使用 ReentrantLock 好了，则双向队列实际上的第一个 Entry 开始运行。</p><p>AQS 定义了对双向队列所有的操作，而只开放了 tryLock 和 tryRelease 方法给开发者使用，开发者可以根据自己的实现重写 tryLock 和 tryRelease 方法，以实现自己的并发功能。</p><h2 id="_41、了解-semaphore-吗" tabindex="-1"><a class="header-anchor" href="#_41、了解-semaphore-吗" aria-hidden="true">#</a> 41、了解 Semaphore 吗？</h2><p>emaphore 就是一个信号量，它的作用是<strong>限制某段代码块的并发数</strong>。</p><p>Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。</p><h2 id="_42、什么是-callable-和-future" tabindex="-1"><a class="header-anchor" href="#_42、什么是-callable-和-future" aria-hidden="true">#</a> 42、什么是 Callable 和 Future?</h2><p>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。可以认为是带有回调的 Runnable。</p><p>Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</p><h2 id="_43、什么是阻塞队列-阻塞队列的实现原理是什么-如何使用阻塞队列来实现生产者-消费者模型" tabindex="-1"><a class="header-anchor" href="#_43、什么是阻塞队列-阻塞队列的实现原理是什么-如何使用阻塞队列来实现生产者-消费者模型" aria-hidden="true">#</a> 43、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p><p>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7 提供了 7 个阻塞队列。分别是：</p><ol><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ol><p>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p><p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。</p><p>阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p><h2 id="_44、什么是多线程中的上下文切换" tabindex="-1"><a class="header-anchor" href="#_44、什么是多线程中的上下文切换" aria-hidden="true">#</a> 44、什么是多线程中的上下文切换？</h2><p>在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。</p><p>在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB 还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到 CPU 的内存中，直到他们被再次使用。</p><p>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p><h2 id="_45、什么是-daemon-线程-它有什么意义" tabindex="-1"><a class="header-anchor" href="#_45、什么是-daemon-线程-它有什么意义" aria-hidden="true">#</a> 45、什么是 Daemon 线程？它有什么意义？</h2><p>所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。</p><p>因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说, 只要有任何非后台线程还在运行，程序就不会终止。</p><p>必须在线程启动之前调用 setDaemon()方法，才能把它设置为后台线程。注意：后台进程在不执行 ﬁnally 子句的情况下就会终止其 run()方法。</p><p>比如：JVM 的垃圾回收线程就是 Daemon 线程，Finalizer 也是守护线程。</p><h2 id="_46、乐观锁和悲观锁的理解及如何实现-有哪些实现方式" tabindex="-1"><a class="header-anchor" href="#_46、乐观锁和悲观锁的理解及如何实现-有哪些实现方式" aria-hidden="true">#</a> 46、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p><p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</p><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。</p><p>在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p><ul><li><p><strong>乐观锁的实现方式</strong>：</p><ol><li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li><li>java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B。否则处理器不做任何操作。</li></ol></li><li><p><strong>CAS 缺点</strong> :</p><ol><li><p><strong>ABA 问题</strong> ：</p><p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 <code>AtomicStampedReference</code> 来解决 ABA 问题。</p></li><li><p><strong>循环时间长开销大</strong> ：</p><p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong> ：</p><p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p></li></ol></li></ul><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/imdtf/blog/edit/main/docs/interview/multi-thread.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" aria-labelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/5/19 23:59:47</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: imdtf@qq.com">DTF</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/interview/jvm.html" class="nav-link prev" aria-label="JVM 篇"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->JVM 篇</div></a><a href="/interview/spring.html" class="nav-link next" aria-label="Spring 篇"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">Spring 篇<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2022 DTF</div></footer><!--]--></div><!--]--><!----><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewbox="0 0 1024 1024" aria-labelledby="close"><title id="close" lang="en">close icon</title><g fill="currentColor"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></g></svg></button><div class="logo"><!----><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!----><!----></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button class="install-button">安装<span></span></button><button class="cancel-button">取消</button></div></div></div></div><!--]--></div>
    <script type="module" src="/assets/app.597ce2f2.js" defer></script>
  </body>
</html>
