<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.43" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-v2-demo.mrhope.site/interview/spring.html"><meta property="og:site_name" content="DTF's blog"><meta property="og:title" content="Spring 篇"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-05-18T15:27:14.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-05-18T15:27:14.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>Spring 篇 | DTF's blog</title><meta name="description" content="我的学习记录博客">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.af58f80f.css">
    <link rel="modulepreload" href="/assets/app.597ce2f2.js"><link rel="modulepreload" href="/assets/spring.html.e5d334fa.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/spring.html.94b261f5.js"><link rel="prefetch" href="/assets/index.html.e173ef83.js"><link rel="prefetch" href="/assets/ElasticSearch.html.279e5d7b.js"><link rel="prefetch" href="/assets/MQ.html.9d040945.js"><link rel="prefetch" href="/assets/MySQL.html.d1ae2d1e.js"><link rel="prefetch" href="/assets/Redis.html.b201ad05.js"><link rel="prefetch" href="/assets/design-patterns.html.733535fa.js"><link rel="prefetch" href="/assets/dubbo.html.c776d990.js"><link rel="prefetch" href="/assets/git.html.72b47aa0.js"><link rel="prefetch" href="/assets/java-base.html.db5311da.js"><link rel="prefetch" href="/assets/jvm.html.53d34a5d.js"><link rel="prefetch" href="/assets/linux.html.65017b81.js"><link rel="prefetch" href="/assets/maven.html.ceec6571.js"><link rel="prefetch" href="/assets/multi-thread.html.3652cc7f.js"><link rel="prefetch" href="/assets/mybatis.html.cb44fe5a.js"><link rel="prefetch" href="/assets/network.html.b1609fd9.js"><link rel="prefetch" href="/assets/nginx.html.9ca67d3a.js"><link rel="prefetch" href="/assets/soft-power.html.508fb44f.js"><link rel="prefetch" href="/assets/spring-boot.html.e888e4e7.js"><link rel="prefetch" href="/assets/spring-cloud.html.57c2b0d4.js"><link rel="prefetch" href="/assets/tomcat.html.dc4aea03.js"><link rel="prefetch" href="/assets/zookeeper.html.75896320.js"><link rel="prefetch" href="/assets/分布式.html.6e369ff9.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.58f6dba8.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.04b85b76.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.116abb6a.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.1d83f138.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.40f6f1e4.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.900bda42.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.3492d336.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.dcc88998.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.7239f150.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.6199feb4.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.57624587.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.d99caa1b.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.cabd308f.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.c89015fe.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.6b8e9ff0.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.e1e4da4a.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.697b9a23.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.9000e742.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.4d12fb46.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.48d80708.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.da9eab5a.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.95150d1c.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.b9bda91b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.bb805e63.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.514eb232.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.4cfc99f3.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.1561ec1a.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.11ef8b3e.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.ef765715.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.50f4f1d6.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.60a1c908.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.b6c6ee60.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.0fa73bd5.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.bfe213be.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.e0558584.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.3087bc74.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.c5df5f6e.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.b9edc687.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.9906de00.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.4b8670c8.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.b78f67d4.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b762f081.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.e5ec66c1.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.f9b4c2c6.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.d4daa082.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.1f616fc4.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.25fe22f4.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.8bb53047.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.63f53d07.js"><link rel="prefetch" href="/assets/00-Introduction.html.aed5c856.js"><link rel="prefetch" href="/assets/00-Preface.html.feee9db3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.ab6ea8b6.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.0224a9bf.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.bea55af9.js"><link rel="prefetch" href="/assets/04-Operators.html.35525abf.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.c4cd86f5.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.b5c2b268.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.399ae58f.js"><link rel="prefetch" href="/assets/08-Reuse.html.0ab07e65.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.89443cf5.js"><link rel="prefetch" href="/assets/10-Interfaces.html.4948bb7b.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.b8f6a196.js"><link rel="prefetch" href="/assets/12-Collections.html.52f2a06b.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.db50a84d.js"><link rel="prefetch" href="/assets/14-Streams.html.9308751d.js"><link rel="prefetch" href="/assets/15-Exceptions.html.40e68d98.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.3edda5f0.js"><link rel="prefetch" href="/assets/17-Files.html.e87e7c99.js"><link rel="prefetch" href="/assets/18-Strings.html.a2842b17.js"><link rel="prefetch" href="/assets/19-Type-Information.html.12cc605b.js"><link rel="prefetch" href="/assets/20-Generics.html.3e4b17f6.js"><link rel="prefetch" href="/assets/21-Arrays.html.67720723.js"><link rel="prefetch" href="/assets/22-Enumerations.html.ab50f89b.js"><link rel="prefetch" href="/assets/23-Annotations.html.747faef3.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.5b9841aa.js"><link rel="prefetch" href="/assets/25-Patterns.html.10af6fe7.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.13f6de18.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.4774ac79.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.fec6d369.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.fe3a1870.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.35950f4f.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.54af4f5f.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.bb07240e.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.8f39ad15.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.39836314.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.ee52b83c.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.68302b50.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.9b5edd63.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.c8a5f6e1.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.34dcd815.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.8c0a6980.js"><link rel="prefetch" href="/assets/GLOSSARY.html.af317d6f.js"><link rel="prefetch" href="/assets/index.html.859506fe.js"><link rel="prefetch" href="/assets/404.html.61bcede7.js"><link rel="prefetch" href="/assets/index.html.6eefb2c9.js"><link rel="prefetch" href="/assets/index.html.276bb6b8.js"><link rel="prefetch" href="/assets/index.html.6c49b0c9.js"><link rel="prefetch" href="/assets/index.html.938faca6.js"><link rel="prefetch" href="/assets/index.html.234dfb8d.js"><link rel="prefetch" href="/assets/index.html.02cffa46.js"><link rel="prefetch" href="/assets/index.html.c70b19c7.js"><link rel="prefetch" href="/assets/index.html.e9ae5772.js"><link rel="prefetch" href="/assets/index.html.43ef8dd6.js"><link rel="prefetch" href="/assets/index.html.0319d1c3.js"><link rel="prefetch" href="/assets/ElasticSearch.html.1822d360.js"><link rel="prefetch" href="/assets/MQ.html.257a1eec.js"><link rel="prefetch" href="/assets/MySQL.html.12265bed.js"><link rel="prefetch" href="/assets/Redis.html.c5915ac6.js"><link rel="prefetch" href="/assets/design-patterns.html.4dff82bc.js"><link rel="prefetch" href="/assets/dubbo.html.70900b5c.js"><link rel="prefetch" href="/assets/git.html.9f0ce8a6.js"><link rel="prefetch" href="/assets/java-base.html.f9b49957.js"><link rel="prefetch" href="/assets/jvm.html.7b42d915.js"><link rel="prefetch" href="/assets/linux.html.9f1e7d55.js"><link rel="prefetch" href="/assets/maven.html.f848fc43.js"><link rel="prefetch" href="/assets/multi-thread.html.5d323dfe.js"><link rel="prefetch" href="/assets/mybatis.html.868f5463.js"><link rel="prefetch" href="/assets/network.html.347740e9.js"><link rel="prefetch" href="/assets/nginx.html.acf44958.js"><link rel="prefetch" href="/assets/soft-power.html.fa4cc2bb.js"><link rel="prefetch" href="/assets/spring-boot.html.eb446c44.js"><link rel="prefetch" href="/assets/spring-cloud.html.5a2e7953.js"><link rel="prefetch" href="/assets/tomcat.html.1edb1280.js"><link rel="prefetch" href="/assets/zookeeper.html.d47f6f3b.js"><link rel="prefetch" href="/assets/分布式.html.8362b544.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.e0b3e691.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.73dedd46.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.a7a61510.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.19af1cfc.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.078c9131.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.3da35573.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.ee1e2ba2.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.5796a618.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.26f3a028.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.cbc4b5ad.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.d79a5425.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.8dab2c77.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.f8e03fcd.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.f1c1f80f.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.a0b4da7e.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.8cf5825d.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.63173a34.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.a51cc121.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.55632279.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.aa190da2.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.c311f962.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.bef20aad.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.54dcb84b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.baae2fb3.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.de07d445.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.d8703177.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.93feb431.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.14ad8743.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.2e4d7d89.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.ebe6ec2f.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.a1a0d482.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.7353d51d.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.b546fd0e.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.fa14f195.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.ddaebd47.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.9f503937.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.95f81089.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.354471cd.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.c9d4ab47.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.9b369837.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.93069f29.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b6a68508.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.4cda471b.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.fec20cbf.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.46eb93f8.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.70884000.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.16cc56b7.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.0f6a9d34.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.ced5f781.js"><link rel="prefetch" href="/assets/00-Introduction.html.2b1f0852.js"><link rel="prefetch" href="/assets/00-Preface.html.e516d7c3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.86c4af1e.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.88cddd12.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.4da53003.js"><link rel="prefetch" href="/assets/04-Operators.html.f9d313c6.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.ecf81ffe.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.c35ecf1b.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.396e0a6f.js"><link rel="prefetch" href="/assets/08-Reuse.html.8c7c4047.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.2150cc57.js"><link rel="prefetch" href="/assets/10-Interfaces.html.6ee853fa.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.ae7b89c4.js"><link rel="prefetch" href="/assets/12-Collections.html.0483e4dd.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.63412e72.js"><link rel="prefetch" href="/assets/14-Streams.html.7e7cce42.js"><link rel="prefetch" href="/assets/15-Exceptions.html.c186f23a.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.b3313ffc.js"><link rel="prefetch" href="/assets/17-Files.html.7a9ad498.js"><link rel="prefetch" href="/assets/18-Strings.html.46e57539.js"><link rel="prefetch" href="/assets/19-Type-Information.html.b68894bf.js"><link rel="prefetch" href="/assets/20-Generics.html.3993804b.js"><link rel="prefetch" href="/assets/21-Arrays.html.4d150e5c.js"><link rel="prefetch" href="/assets/22-Enumerations.html.87d060f0.js"><link rel="prefetch" href="/assets/23-Annotations.html.0c455464.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.8485a02c.js"><link rel="prefetch" href="/assets/25-Patterns.html.4f5781b0.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.4e7ecda3.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.1a18282e.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.ec4969df.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.c956724d.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.ac5ea88b.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.26db6884.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.80dbdde9.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.613e991c.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.de90320b.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.1f3841f2.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.a3de1972.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.28579d58.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.aae5a747.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.4bf49d65.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.9d9599c8.js"><link rel="prefetch" href="/assets/GLOSSARY.html.d812823c.js"><link rel="prefetch" href="/assets/index.html.d25b0535.js"><link rel="prefetch" href="/assets/404.html.0c8252b8.js"><link rel="prefetch" href="/assets/index.html.d5cc08ad.js"><link rel="prefetch" href="/assets/index.html.1331f6ca.js"><link rel="prefetch" href="/assets/index.html.da6c3a69.js"><link rel="prefetch" href="/assets/index.html.1174fbbd.js"><link rel="prefetch" href="/assets/index.html.c73d2264.js"><link rel="prefetch" href="/assets/index.html.1e315145.js"><link rel="prefetch" href="/assets/index.html.514b72a3.js"><link rel="prefetch" href="/assets/index.html.b19f5086.js"><link rel="prefetch" href="/assets/index.html.1ac6115e.js"><link rel="prefetch" href="/assets/404.3a5fd86b.js"><link rel="prefetch" href="/assets/Layout.42785ec5.js"><link rel="prefetch" href="/assets/Slide.5e14cdfb.js"><link rel="prefetch" href="/assets/Blog.f29d76d0.js"><link rel="prefetch" href="/assets/auto.esm.15d52109.js"><link rel="prefetch" href="/assets/index.1842ee54.js"><link rel="prefetch" href="/assets/mermaid.esm.min.f71f1464.js"><link rel="prefetch" href="/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/assets/photoswipe.esm.92018b73.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="DTF&#39;s blog"><!----><span class="site-name hide-in-pad">DTF&#39;s blog</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guide/" class="nav-link" aria-label="使用指南"><i class="icon iconfont icon-creative"></i>使用指南<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/imdtf/blog" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" aria-labelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewbox="0 0 1024 1024" aria-labelledby="outlook"><title id="outlook" lang="en">outlook icon</title><g fill="currentColor"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></g></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-guide"></i><span class="title">语言</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-markdown"></i><span class="title">数据库</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-question"></i><span class="title">面试题</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/interview/java-base.html" class="nav-link sidebar-link sidebar-page" aria-label="基础篇"><!---->基础篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/jvm.html" class="nav-link sidebar-link sidebar-page" aria-label="JVM 篇"><!---->JVM 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/multi-thread.html" class="nav-link sidebar-link sidebar-page" aria-label="多线程&amp;并发篇"><!---->多线程&amp;并发篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/interview/spring.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Spring 篇"><!---->Spring 篇<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_1、什么是spring" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1、什么是spring?"><!---->1、什么是spring?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_2、你们项目中为什么使用spring框架" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2、你们项目中为什么使用Spring框架？"><!---->2、你们项目中为什么使用Spring框架？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_3、autowired-和-resource关键字的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3、Autowired 和 Resource关键字的区别？"><!---->3、Autowired 和 Resource关键字的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_4、依赖注入的方式有几种-各是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4、依赖注入的方式有几种，各是什么?"><!---->4、依赖注入的方式有几种，各是什么?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_5、讲一下什么是spring" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5、讲一下什么是Spring"><!---->5、讲一下什么是Spring<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_6、说说你对spring-mvc的理解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6、说说你对Spring MVC的理解"><!---->6、说说你对Spring MVC的理解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_7、-springmvc常用的注解有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7、 SpringMVC常用的注解有哪些？"><!---->7、 SpringMVC常用的注解有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_8、-谈谈你对spring-的-aop理解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8、 谈谈你对Spring 的 AOP理解"><!---->8、 谈谈你对Spring 的 AOP理解<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_9、spring-aop-和-aspectj-aop有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9、Spring AOP 和 AspectJ AOP有什么区别？"><!---->9、Spring AOP 和 AspectJ AOP有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_10、说说你对spring-的-ioc是怎么理解的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10、说说你对Spring 的 IOC是怎么理解的？"><!---->10、说说你对Spring 的 IOC是怎么理解的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_11、解释一下spring-bean的生命周期" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11、解释一下spring bean的生命周期"><!---->11、解释一下spring bean的生命周期<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_12、解释spring支持的几种bean的作用域" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12、解释Spring支持的几种bean的作用域？"><!---->12、解释Spring支持的几种bean的作用域？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_13、-spring基于xml注入bean的几种方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="13、 Spring基于xml注入bean的几种方式?"><!---->13、 Spring基于xml注入bean的几种方式?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_14、spring框架中都用到了哪些设计模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="14、Spring框架中都用到了哪些设计模式？"><!---->14、Spring框架中都用到了哪些设计模式？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_15、说说spring-中-applicationcontext-和-beanfactory-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15、说说Spring 中 ApplicationContext 和 BeanFactory 的区别"><!---->15、说说Spring 中 ApplicationContext 和 BeanFactory 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_16、spring-框架中的单例-bean-是线程安全的么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="16、Spring 框架中的单例 Bean 是线程安全的么？"><!---->16、Spring 框架中的单例 Bean 是线程安全的么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_17、spring-是怎么解决循环依赖的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17、Spring 是怎么解决循环依赖的？"><!---->17、Spring 是怎么解决循环依赖的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_18、说说事务的隔离级别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18、说说事务的隔离级别"><!---->18、说说事务的隔离级别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_19、说说事务的传播级别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="19、说说事务的传播级别"><!---->19、说说事务的传播级别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_20、spring-事务实现方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="20、Spring 事务实现方式"><!---->20、Spring 事务实现方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_21、-spring框架的事务管理有哪些优点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="21、 Spring框架的事务管理有哪些优点"><!---->21、 Spring框架的事务管理有哪些优点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_22、事务三要素是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="22、事务三要素是什么？"><!---->22、事务三要素是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_23、-事务注解的本质是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="23、 事务注解的本质是什么？"><!---->23、 事务注解的本质是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_24、在-spring-aop-中-关注点和横切关注的区别是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="24、在 Spring AOP 中，关注点和横切关注的区别是什么？"><!---->24、在 Spring AOP 中，关注点和横切关注的区别是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/spring.html#_25、什么是通知呢-有哪些类型呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="25、什么是通知呢？有哪些类型呢？"><!---->25、什么是通知呢？有哪些类型呢？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/interview/spring-boot.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringBoot 篇"><!---->SpringBoot 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-cloud.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringCloud 篇"><!---->SpringCloud 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/dubbo.html" class="nav-link sidebar-link sidebar-page" aria-label="Dubbo 篇"><!---->Dubbo 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/mybatis.html" class="nav-link sidebar-link sidebar-page" aria-label="MyBatis 篇"><!---->MyBatis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MySQL.html" class="nav-link sidebar-link sidebar-page" aria-label="MySQL 篇"><!---->MySQL 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/nginx.html" class="nav-link sidebar-link sidebar-page" aria-label="Nginx 篇"><!---->Nginx 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MQ.html" class="nav-link sidebar-link sidebar-page" aria-label="MQ 篇"><!---->MQ 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/linux.html" class="nav-link sidebar-link sidebar-page" aria-label="Linux 篇"><!---->Linux 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/zookeeper.html" class="nav-link sidebar-link sidebar-page" aria-label="Zookeeper 篇"><!---->Zookeeper 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/Redis.html" class="nav-link sidebar-link sidebar-page" aria-label="Redis 篇"><!---->Redis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/%E5%88%86%E5%B8%83%E5%BC%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="分布式篇"><!---->分布式篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/network.html" class="nav-link sidebar-link sidebar-page" aria-label="网络篇"><!---->网络篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/design-patterns.html" class="nav-link sidebar-link sidebar-page" aria-label="设计模式"><!---->设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/maven.html" class="nav-link sidebar-link sidebar-page" aria-label="maven 篇"><!---->maven 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/ElasticSearch.html" class="nav-link sidebar-link sidebar-page" aria-label="ElasticSearch 篇"><!---->ElasticSearch 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/tomcat.html" class="nav-link sidebar-link sidebar-page" aria-label="tomcat 篇"><!---->tomcat 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/git.html" class="nav-link sidebar-link sidebar-page" aria-label="Git 篇"><!---->Git 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/soft-power.html" class="nav-link sidebar-link sidebar-page" aria-label="软实力篇"><!---->软实力篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Spring 篇</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" aria-labelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://github.com/imdtf" target="_blank" rel="noopener noreferrer">DTF</a></span><span property="author" content="DTF"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" aria-labelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年5月18日</span><meta property="datePublished" content="2022-05-18T15:27:14.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" aria-labelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 30 分钟</span><meta property="timeRequired" content="PT30M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_1、什么是spring" class="router-link-active router-link-exact-active toc-link level2">1、什么是spring?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_2、你们项目中为什么使用spring框架" class="router-link-active router-link-exact-active toc-link level2">2、你们项目中为什么使用Spring框架？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_3、autowired-和-resource关键字的区别" class="router-link-active router-link-exact-active toc-link level2">3、Autowired 和 Resource关键字的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_4、依赖注入的方式有几种-各是什么" class="router-link-active router-link-exact-active toc-link level2">4、依赖注入的方式有几种，各是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_5、讲一下什么是spring" class="router-link-active router-link-exact-active toc-link level2">5、讲一下什么是Spring</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_6、说说你对spring-mvc的理解" class="router-link-active router-link-exact-active toc-link level2">6、说说你对Spring MVC的理解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_7、-springmvc常用的注解有哪些" class="router-link-active router-link-exact-active toc-link level2">7、 SpringMVC常用的注解有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_8、-谈谈你对spring-的-aop理解" class="router-link-active router-link-exact-active toc-link level2">8、 谈谈你对Spring 的 AOP理解</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_9、spring-aop-和-aspectj-aop有什么区别" class="router-link-active router-link-exact-active toc-link level2">9、Spring AOP 和 AspectJ AOP有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_10、说说你对spring-的-ioc是怎么理解的" class="router-link-active router-link-exact-active toc-link level2">10、说说你对Spring 的 IOC是怎么理解的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_11、解释一下spring-bean的生命周期" class="router-link-active router-link-exact-active toc-link level2">11、解释一下spring bean的生命周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_12、解释spring支持的几种bean的作用域" class="router-link-active router-link-exact-active toc-link level2">12、解释Spring支持的几种bean的作用域？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_13、-spring基于xml注入bean的几种方式" class="router-link-active router-link-exact-active toc-link level2">13、 Spring基于xml注入bean的几种方式?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_14、spring框架中都用到了哪些设计模式" class="router-link-active router-link-exact-active toc-link level2">14、Spring框架中都用到了哪些设计模式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_15、说说spring-中-applicationcontext-和-beanfactory-的区别" class="router-link-active router-link-exact-active toc-link level2">15、说说Spring 中 ApplicationContext 和 BeanFactory 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_16、spring-框架中的单例-bean-是线程安全的么" class="router-link-active router-link-exact-active toc-link level2">16、Spring 框架中的单例 Bean 是线程安全的么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_17、spring-是怎么解决循环依赖的" class="router-link-active router-link-exact-active toc-link level2">17、Spring 是怎么解决循环依赖的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_18、说说事务的隔离级别" class="router-link-active router-link-exact-active toc-link level2">18、说说事务的隔离级别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_19、说说事务的传播级别" class="router-link-active router-link-exact-active toc-link level2">19、说说事务的传播级别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_20、spring-事务实现方式" class="router-link-active router-link-exact-active toc-link level2">20、Spring 事务实现方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_21、-spring框架的事务管理有哪些优点" class="router-link-active router-link-exact-active toc-link level2">21、 Spring框架的事务管理有哪些优点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_22、事务三要素是什么" class="router-link-active router-link-exact-active toc-link level2">22、事务三要素是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_23、-事务注解的本质是什么" class="router-link-active router-link-exact-active toc-link level2">23、 事务注解的本质是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_24、在-spring-aop-中-关注点和横切关注的区别是什么" class="router-link-active router-link-exact-active toc-link level2">24、在 Spring AOP 中，关注点和横切关注的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/spring.html#_25、什么是通知呢-有哪些类型呢" class="router-link-active router-link-exact-active toc-link level2">25、什么是通知呢？有哪些类型呢？</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h1 id="spring-篇" tabindex="-1"><a class="header-anchor" href="#spring-篇" aria-hidden="true">#</a> Spring 篇</h1><h2 id="_1、什么是spring" tabindex="-1"><a class="header-anchor" href="#_1、什么是spring" aria-hidden="true">#</a> 1、什么是spring?</h2><p>Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</p><h2 id="_2、你们项目中为什么使用spring框架" tabindex="-1"><a class="header-anchor" href="#_2、你们项目中为什么使用spring框架" aria-hidden="true">#</a> 2、你们项目中为什么使用Spring框架？</h2><p>这么问的话，就直接说 Spring 框架的好处就可以了。比如说 Spring 有以下特点：</p><ul><li><strong>轻量</strong> : Spring 是轻量的，基本的版本大约 2MB。</li><li><strong>控制反转</strong> ：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li><li><strong>依赖注入</strong> : // TODO add</li><li><strong>面向切面的编程(AOP)</strong> : Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li><li><strong>容器</strong> : Spring 包含并管理应用中对象的生命周期和配置。</li><li><strong>MVC框架</strong> : Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。</li><li><strong>事务管理</strong> : Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务 （JTA）。</li><li><strong>异常处理</strong> : Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常。</li></ul><h2 id="_3、autowired-和-resource关键字的区别" tabindex="-1"><a class="header-anchor" href="#_3、autowired-和-resource关键字的区别" aria-hidden="true">#</a> 3、Autowired 和 Resource关键字的区别？</h2><p>@Resource 和@Autowired 都是做 bean 的注入时使用，其实@Resource 并不是 Spring 的注解，它的包是 javax.annotation.Resource，需要导入，但是 Spring 支持该注解的注入。</p><ul><li>共同点 两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter 方法。</li><li>不同点 <ul><li><p><strong>@Autowired</strong> :</p><p>Spring 提供的注解，需要导入包 <code>org.springframework.beans.factory.annotation.Autowired</code> , 只按照 byType 注入。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestServiceImpl</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下面两种@Autowired 只要使用一种即可</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span> <span class="token comment">// 用于字段上</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserDao</span><span class="token punctuation">(</span><span class="token class-name">UserDao</span> userDao<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 用于属性的方法上</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userDao <span class="token operator">=</span> userDao<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>@Autowired 注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许 null 值，可以设置它的 required 属性为 false。如果我们想使用按照名称（byName）来装配，可以结合@Qualiﬁer 注解一起使用。如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestServiceImpl</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">&quot;userDao&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p><strong>@Resource</strong> :</p><p>默认按照 ByName 自动注入，由 J2EE 提供，需要导入包 <code>javax.annotation.Resource</code> 。</p><p>@Resource 有两个重要的属性：<strong>name</strong> 和 <strong>type</strong> ，而 Spring 将@Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以，如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestServiceImpl</span> <span class="token punctuation">{</span> <span class="token comment">// 下面两种@Resource 只要使用一种即可 @Resource(name=&quot;userDao&quot;)</span>
    <span class="token keyword">private</span> <span class="token class-name">UserDao</span> userDao<span class="token punctuation">;</span> <span class="token comment">// 用于字段上 @Resource(name=&quot;userDao&quot;)</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserDao</span><span class="token punctuation">(</span><span class="token class-name">UserDao</span> userDao<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 用于属性的 setter 方法上</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userDao <span class="token operator">=</span> userDao<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>注：最好是将@Resource 放在 setter 方法上，因为这样更符合面向对象的思想，通过 set、get 去操作属性，而不是直接去操作属性。</p></li><li><p>@Resource 装配顺序：</p><ol><li>如果同时指定了 name 和 type，则从 Spring 上下文中找到唯一匹配的 bean 进行装配，找不到则抛出异常。</li><li>如果指定了 name，则从上下文中查找名称（id）匹配的 bean 进行装配，找不到则抛出异常。</li><li>如果指定了 type，则从上下文中找到类似匹配的唯一 bean 进行装配，找不到或是找到多个，都会抛出异常。</li><li>如果既没有指定 name，又没有指定 type，则自动按照 byName 方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li></ol><p>@Resource 的作用相当于@Autowired，只不过@Autowired 按照 byType 自动注入。</p></li></ul></li></ul><h2 id="_4、依赖注入的方式有几种-各是什么" tabindex="-1"><a class="header-anchor" href="#_4、依赖注入的方式有几种-各是什么" aria-hidden="true">#</a> 4、依赖注入的方式有几种，各是什么?</h2><ol><li><p>构造器注入将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。</p><ul><li><strong>优点</strong> ： 对象初始化完成后便可获得可使用的对象。</li></ul></li></ol><ul><li><strong>缺点</strong> ：当需要注入的对象很多时，构造器参数列表将会很长；不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。</li></ul><ol start="2"><li><p><strong>setter</strong>方法注入 IOC Service Provider 通过调用成员变量提供的 setter 函数将被依赖对象注入给依赖类。</p><ul><li><p><strong>优点</strong> ： 灵活, 可以选择性地注入需要的对象。</p></li><li><p><strong>缺点</strong> ： 依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。</p></li></ul></li><li><p>接口注入依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。 优点接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。 缺点： 侵入行太强，不建议使用。</p></li></ol><p>PS：什么是侵入行？ 如果类 A 要使用别人提供的一个功能，若为了使用这功能，需要在自己的类中增加额外的代码，这就是侵入性。</p><h2 id="_5、讲一下什么是spring" tabindex="-1"><a class="header-anchor" href="#_5、讲一下什么是spring" aria-hidden="true">#</a> 5、讲一下什么是Spring</h2><p>Spring 是一个轻量级的 IOC 和 AOP 容器框架。是为 Java 应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于 XML 的配置、基于注解的配置、基于 Java 的配置。</p><p>主要由以下几个模块组成：</p><ul><li>Spring Core：核心类库，提供 IOC 服务；</li><li>Spring Context：提供框架式的 Bean 访问方式，以及企业级功能（JNDI、定时任务等）；</li><li>Spring AOP：AOP 服务；</li><li>Spring DAO：对 JDBC 的抽象，简化了数据访问异常的处理；</li><li>Spring ORM：对现有的 ORM 框架的支持；</li><li>Spring Web：提供了基本的面向 Web 的综合特性，例如多方文件上传；</li><li>Spring MVC：提供面向 Web 应用的 Model-View-Controller 实现。</li></ul><h2 id="_6、说说你对spring-mvc的理解" tabindex="-1"><a class="header-anchor" href="#_6、说说你对spring-mvc的理解" aria-hidden="true">#</a> 6、说说你对Spring MVC的理解</h2><p>MVC 是一种设计模式</p><p>MVC 的原理图：</p><p>// TODO image</p><ul><li><p><strong>分析</strong>：</p><p>M-Model 模型（完成业务逻辑：有 javaBean 构成，service+dao+entity）</p><p>V-View 视图（做界面的展示jsp，html……）</p><p>C-Controller 控制器（接收请求—&gt;调用模型—&gt;根据结果派发页面）</p><p>Spring MVC 是一个 MVC 的开源框架，Spring MVC = Struts2 + Spring，Spring MVC 就相当于是 Struts2 加上 Sring 的整合，但是这里有一个疑惑就是，Spring MVC 和 Spring 是什么样的关系呢？这个在百度百科上有一个很好的解释：意思是说，Spring MVC 是 Spring 的一个后续产品，其实就是Spring 在原有基础上，又提供了 web 应用的 MVC 模块，可以简单的把 Spring MVC 理解为是 Spring 的一个模块 （类似 AOP，IOC 这样的模块），网络上经常会说 Spring MVC 和 Spring 无缝集成，其实 Spring MVC 就是 Spring 的一个子模块，所以根本不需要同 Spring 进行整合。</p></li><li><p><strong>工作原理</strong> ：</p><ol><li>用户发送请求至前端控制器 DispatcherServlet。</li><li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</li><li>处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。</li><li>DispatcherServlet 调用 HandlerAdapter 处理器适配器。</li><li>HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)。</li><li>Controller 执行完成返回 ModelAndView。</li><li>HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</li><li>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</li><li>ViewReslover 解析后返回具体 View。</li><li>DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet 响应用户。</li></ol></li><li><p><strong>组件说明</strong>:</p><p>以下组件通常使用框架提供实现：</p><ul><li>DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</li><li>HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。</li><li>ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、 excel 等。</li></ul><p><strong>组件</strong> ：</p><ol><li><strong>前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong>, 作用是接收请求，响应结果，相当于转发器，中央处理器。有了 dispatcherServlet 减少了其它组件之间的耦合度。 用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</li><li><strong>处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong> , 作用是根据请求的 url 查找 Handler HandlerMapping 负责根据用户请求找到 Handler 即处理器，springmvc 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li><li><strong>处理器适配器HandlerAdapter</strong> , 作用是按照特定规则（HandlerAdapter 要求的规则）去执行 Handler 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</li><li><strong>处理器Handler(需要工程师开发)</strong> , 编写<strong>Handler</strong>时按照<strong>HandlerAdapter</strong>的要求去做，这样适配器才可以去正确执行Handler Handler 是继 DispatcherServlet前端控制器的后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。 由于 Handler 涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发 Handler。</li><li><strong>视图解析器View resolver(不需要工程师开发),框架提供</strong> 作用是进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 Spring MVC 框架提供了很多的 View 视图类型，包括：jstlView、 freemarkerView、pdfView 等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</li><li><strong>视图View(需要工程师开发jsp...)</strong> View 是一个接口，实现类支持不同的 View 类型（jsp、 freemarker、pdf...）</li></ol><p><strong>核心架构的具体流程步骤如下：</strong></p><ol><li>首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</li><li>DispatcherServlet——&gt;HandlerMapping, HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一个 Handler 处理器（页面控制器）对象、多个 HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</li><li>DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</li><li>HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个 ModelAndView 对象（包含模型数据、逻辑视图名）；</li><li>ModelAndView 的逻辑视图名——&gt; ViewResolver, ViewResolver将把逻辑视图名解析为具体的 View，通过这种策略模式，很容易更换其他视图技术；</li><li>View——&gt;渲染，View 会根据传进来的 Model 模型数据进行渲染，此处的 Model 实际是一个 Map 数据结构，因此很容易支持其他视图技术；</li><li>返回控制权给 DispatcherServlet，由 DispatcherServlet 返回响应给用户，到此一个流程结束。</li></ol><p>看到这些步骤我相信大家很感觉非常的乱，这是正常的，但是这里主要是要大家理解 springMVC 中的几个组件：</p><ul><li>前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的 CPU。</li><li>处理器映射器（HandlerMapping）：根据 URL 去查找处理器。</li><li>处理器（Handler）：需要程序员去写代码处理逻辑的。</li><li>处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用）。</li><li>视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面。</li></ul></li></ul><h2 id="_7、-springmvc常用的注解有哪些" tabindex="-1"><a class="header-anchor" href="#_7、-springmvc常用的注解有哪些" aria-hidden="true">#</a> 7、 SpringMVC常用的注解有哪些？</h2><ul><li>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</li><li>@RequestBody：注解实现接收 http 请求的 json 数据，将 json转换为 java 对象。</li><li>@ResponseBody：注解实现将 conreoller 方法返回对象转化为 json 对象响应给客户。</li></ul><h2 id="_8、-谈谈你对spring-的-aop理解" tabindex="-1"><a class="header-anchor" href="#_8、-谈谈你对spring-的-aop理解" aria-hidden="true">#</a> 8、 谈谈你对Spring 的 AOP理解</h2><p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</p><p>Spring AOP 是基于动态代理的，如果要代理的对象实现了某个接口，那么 Spring AOP 就会使用 JDK 动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用 JDK 动态代理，转而使用 CGlib 动态代理生成一个被代理对象的子类来作为代理。</p><p>// TODO image</p><p>注意：图中的 implements 和 extend。即一个是接口，一个是实现类。</p><p>当然也可以使用 AspectJ，Spring AOP 中已经集成了 AspectJ，AspectJ 应该算得上是 Java 生态系统中最完整的 AOP 框架了。使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量。我们需要增加新功能也方便，提高了系统的扩展性。日志功能、事务管理和权限管理等场景都用到了 AOP。</p><h2 id="_9、spring-aop-和-aspectj-aop有什么区别" tabindex="-1"><a class="header-anchor" href="#_9、spring-aop-和-aspectj-aop有什么区别" aria-hidden="true">#</a> 9、Spring AOP 和 AspectJ AOP有什么区别？</h2><p>Spring AOP 是属于运行时增强，而 AspectJ 是编译时增强。Spring AOP 基于代理（Proxying），而 AspectJ 基于字节码操作（Bytecode Manipulation）。</p><p>Spring AOP 已经集成了 AspectJ，AspectJ 应该算得上是 Java 生态系统中最完整的 AOP 框架了。 AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ，它比 SpringAOP 快很多。</p><h2 id="_10、说说你对spring-的-ioc是怎么理解的" tabindex="-1"><a class="header-anchor" href="#_10、说说你对spring-的-ioc是怎么理解的" aria-hidden="true">#</a> 10、说说你对Spring 的 IOC是怎么理解的？</h2><ul><li><p>IOC 就是控制反转，是指创建对象的控制权的转移。以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到 Spring 容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。对象与对象之间松散耦合，也利于功能的复用。DI 依赖注入，和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖 IOC 容器来动态注入对象需要的外部资源。</p></li><li><p>最直观的表达就是，IOC 让对象的创建不用去 new 了，可以由 spring 自动生产，使用 java 的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p></li><li><p>Spring 的 IOC 有三种注入方式 ：</p><ul><li>构造器注入</li><li>setter 方法注入</li><li>根据注解注入</li></ul></li></ul><blockquote><p>IOC 让相互协作的组件保持松散的耦合，而 AOP 编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p></blockquote><h2 id="_11、解释一下spring-bean的生命周期" tabindex="-1"><a class="header-anchor" href="#_11、解释一下spring-bean的生命周期" aria-hidden="true">#</a> 11、解释一下spring bean的生命周期</h2><p>首先说一下 Servlet 的生命周期：实例化，初始 init，接收请求 service，销毁 destroy；</p><p>Spring 上下文中的 Bean 生命周期也类似，如下：</p><ol><li><p>实例化 Bean：</p><p>对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDeﬁnition 对象中的信息，实例化所有的 bean。</p></li><li><p>设置对象属性（依赖注入）：</p><p>实例化后的对象被封装在 BeanWrapper 对象中，紧接着，Spring 根据 BeanDeﬁnition 中的信息以及通过 BeanWrapper 提供的设置属性的接口完成依赖注入。</p></li><li><p>处理 Aware 接口：</p><p>接着，Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：</p><ul><li>如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String beanId)方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值；</li><li>如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory()方法，传递的是 Spring 工厂自身。</li><li>如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用 setApplicationContext(ApplicationContext)方法，传入 Spring 上下文；</li></ul></li><li><p>BeanPostProcessor：</p><p>如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization(Object obj, String s)方法。</p></li><li><p>InitializingBean 与 init-method：</p><p>如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p></li><li><p>postProcessAfterInitialization:</p><p>如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在 Bean 初始化结束时调用的，所以可以被应用于内存或缓存技术；</p><p>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。</p></li><li><p>DisposableBean：</p><p>当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy()方法；</p></li><li><p>destroy-method：</p><p>最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</p></li></ol><h2 id="_12、解释spring支持的几种bean的作用域" tabindex="-1"><a class="header-anchor" href="#_12、解释spring支持的几种bean的作用域" aria-hidden="true">#</a> 12、解释Spring支持的几种bean的作用域？</h2><p>Spring 容器中的 bean 可以分为 5 个范围：</p><ol><li>singleton：默认，每个容器中只有一个 bean 的实例，单例的模式由 BeanFactory 自身来维护。</li><li>prototype：为每一个 bean 请求提供一个实例。</li><li>request：为每一个网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。</li><li>session：与 request 范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后， bean 会随之失效。</li><li>global-session：全局作用域，global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。</li></ol><h2 id="_13、-spring基于xml注入bean的几种方式" tabindex="-1"><a class="header-anchor" href="#_13、-spring基于xml注入bean的几种方式" aria-hidden="true">#</a> 13、 Spring基于xml注入bean的几种方式?</h2><ol><li><p>Set 方法注入；</p></li><li><p>构造器注入：</p><ul><li><p>通过 index 设置参数的位置；</p></li><li><p>通过 type 设置参数类型；</p></li></ul></li><li><p>静态工厂注入；</p></li><li><p>实例工厂；</p></li></ol><p>通常回答前面两种即可，因为后面两种很多人都不太会，不会的就不要说出来，不然问到你不会就尴尬了。</p><h2 id="_14、spring框架中都用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_14、spring框架中都用到了哪些设计模式" aria-hidden="true">#</a> 14、Spring框架中都用到了哪些设计模式？</h2><p>这是一道相对有难度的题目，你不仅要会设计模式，还要知道每个设计模式在 Spring 中是如何使用的。</p><ul><li><p><strong>简单工厂模式</strong>：</p><p>Spring 中的 BeanFactory 就是简单工厂模式的体现。根据传入一个唯一的标识来获得 Bean 对象，但是在传入参数后创建还是传入参数前创建，要根据具体情况来定。</p></li><li><p><strong>工厂模式</strong>：</p><p>Spring 中的 FactoryBean 就是典型的工厂方法模式，实现了 FactoryBean 接口的 bean 是一类叫做 factory 的 bean。其特点是，spring 在使用 getBean() 调用获得该 bean 时，会自动调用该 bean 的 getObject() 方法，所以返回的不是 factory 这个 bean，而是这个 bean.getOjbect()方法的返回值。</p></li><li><p><strong>单例模式</strong>：</p><p>在 spring 中用到的单例模式有： scope=&quot;singleton&quot; ，注册式单例模式，bean 存放于 Map 中。bean name 当做 key，bean 当做 value。</p></li><li><p><strong>原型模式</strong>：</p><p>在 spring 中用到的原型模式有： scope=&quot;prototype&quot; ，每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</p></li><li><p><strong>迭代器模式</strong>：</p><p>在 Spring 中有个 CompositeIterator 实现了 Iterator，Iterable 接口和 Iterator 接口，这两个都是迭代相关的接口。可以这么认为，实现了 Iterable 接口，则表示某个对象是可被迭代的。Iterator 接口相当于是一个迭代器，实现了 Iterator 接口，等于具体定义了这个可被迭代的对象时如何进行迭代的。</p></li><li><p><strong>代理模式</strong>：</p><p>Spring 中经典的 AOP，就是使用动态代理实现的，分 JDK 和 CGlib 动态代理。</p></li><li><p><strong>适配器模式</strong>：</p><p>Spring 中的 AOP 中 AdvisorAdapter 类，它有三个实现：MethodBeforAdviceAdapter、AfterReturnningAdviceAdapter、ThrowsAdviceAdapter。</p><p>Spring 会根据不同的 AOP 配置来使用对应的 Advice，与策略模式不同的是，一个方法可以同时拥有多个 Advice。Spring 存在很多以 Adapter 结尾的，大多数都是适配器模式。</p></li><li><p><strong>观察者模式</strong>：</p><p>Spring 中的 Event 和 Listener。spring 事件：ApplicationEvent，该抽象类继承了 EventObject 类，JDK 建议所有的事件都应该继承自 EventObject。</p><p>spring 事件监听器： ApplicationListener，该接口继承了 EventListener 接口，JDK 建议所有的事件监听器都应该继承 EventListener。</p></li><li><p><strong>模板模式</strong>：</p><p>Spring 中的 org.springframework.jdbc.core.JdbcTemplate 就是非常经典的模板模式的应用，里面的 execute 方法，把整个算法步骤都定义好了。</p></li><li><p><strong>责任链模式</strong>：</p><p>DispatcherServlet 中的 doDispatch() 方法中获取与请求匹配的处理器 HandlerExecutionChain，this.getHandler() 方法的处理使用到了责任链模式。</p></li></ul><p>注意：这里只是列举了部分设计模式，其实里面用到了还有享元模式、建造者模式等。可选择性的回答，主要是怕你回答了迭代器模式，然后继续问你，结果你一问三不知，那就尴了尬了。</p><h2 id="_15、说说spring-中-applicationcontext-和-beanfactory-的区别" tabindex="-1"><a class="header-anchor" href="#_15、说说spring-中-applicationcontext-和-beanfactory-的区别" aria-hidden="true">#</a> 15、说说Spring 中 ApplicationContext 和 BeanFactory 的区别</h2><p>类图</p><ul><li><p><strong>包目录不同</strong></p><p>spring-beans.jar 中 org.springframework.beans.factory.BeanFactory</p><p>spring-context.jar 中 org.springframework.context.ApplicationContext</p></li><li><p><strong>国际化</strong></p><p>BeanFactory 是不支持国际化功能的，因为 BeanFactory 没有扩展 Spring 中 MessageResource 接口。相反，由于 ApplicationContext 扩展了 MessageResource 接口，因而具有消息处理的能力 (i18N)。</p></li><li><p><strong>强大的事件机制(Event)</strong></p><p>基本上牵涉到事件（Event）方面的设计，就离不开观察者模式，ApplicationContext 的事件机制主要通过 ApplicationEvent 和 ApplicationListener 这两个接口来提供的，和 Java swing 中的事件机制一样。即当 ApplicationContext 中发布一个事件时，所有扩展了 ApplicationListener 的 Bean 都将接受到这个事件，并进行相应的处理。</p></li><li><p><strong>底层资源的访问</strong></p><p>ApplicationContext 扩展了 ResourceLoader（资源加载器）接口，从而可以用来加载多个 Resource，而 BeanFactory 是没有扩展 ResourceLoader。</p></li><li><p><strong>对 Web 应用的支持</strong></p><p>与BeanFactory 通常以编程的方式被创建，ApplicationContext 能以声明的方式创建，如使用 ContextLoader。 当然你也可以使用 ApplicationContext 的实现方式之一，以编程的方式创建 ApplicationContext 实例。</p></li><li><p><strong>延迟加载</strong></p><ol><li>BeanFactroy 采用的是延迟加载形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用 getBean())，才对该 Bean 进行加载实例化。这样，我们就不能发现一些存在的 spring 的配置问题。而 ApplicationContext 则相反，它是在容器启动时，一次性创建了所有的 Bean。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误。</li><li>BeanFactory 和 ApplicationContext 都支持 BeanPostProcessor、 BeanFactoryPostProcessor 的使用。两者之间的区别是：BeanFactory 需要手动注册，而ApplicationContext 则是自动注册。</li></ol><p>可以看到，ApplicationContext 继承了 BeanFactory，BeanFactory 是 Spring 中比较原始的 Factory，它不支持 AOP、Web 等 Spring 插件。而 ApplicationContext 不仅包含了 BeanFactory 的所有功能，还支持 Spring 的各种插件，还以一种面向框架的方式工作以及对上下文进行分层和实现继承。 BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；而 ApplicationContext 面向使用 Spring 的开发者，相比 BeanFactory 提供了更多面向实际应用的功能，几乎所有场合都可以直接使用 ApplicationContext，而不是底层的 BeanFactory。</p></li><li><p><strong>常用容器</strong></p><p>BeanFactory 类型的有 XmlBeanFactory，它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p><p>ApplicationContext 类型的常用容器有：</p><ol><li>ClassPathXmlApplicationContext：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</li><li>FileSystemXmlApplicationContext：由文件系统中的 XML 配置文件读取上下文。</li><li>XmlWebApplicationContext：由 Web 应用的 XML 文件读取上下文。例如我们在 Spring MVC 使用的情况。</li></ol></li></ul><h2 id="_16、spring-框架中的单例-bean-是线程安全的么" tabindex="-1"><a class="header-anchor" href="#_16、spring-框架中的单例-bean-是线程安全的么" aria-hidden="true">#</a> 16、Spring 框架中的单例 Bean 是线程安全的么？</h2><p>Spring 框架并没有对单例 Bean 进行任何多线程的封装处理。</p><ul><li>关于单例 Bean 的线程安全和并发问题，需要开发者自行去搞定。</li><li>单例的线程安全问题，并不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。</li></ul><p>当然，但实际上，大部分的 Spring Bean 并没有可变的状态，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态 Bean 的作用域（Scope）由 Singleton 变更为 Prototype。</p><h2 id="_17、spring-是怎么解决循环依赖的" tabindex="-1"><a class="header-anchor" href="#_17、spring-是怎么解决循环依赖的" aria-hidden="true">#</a> 17、Spring 是怎么解决循环依赖的？</h2><p>整个流程大致如下：</p><ol><li>首先 A 完成初始化第一步并将自己<strong>提前曝光</strong>出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来；</li><li>然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来；</li><li>这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)。这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories），通过 ObjectFactory 提前曝光，所以可以通过 ObjectFactory#getObject() 方法来拿到 A 对象。C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中；</li><li>回到 B，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。</li></ol><p>关键字：<strong>三级缓存</strong> ，<strong>提前曝光</strong> 。</p><h2 id="_18、说说事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_18、说说事务的隔离级别" aria-hidden="true">#</a> 18、说说事务的隔离级别</h2><ul><li><p>提未交读(Read Uncommitted)：</p><p>允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</p></li><li><p>提交读(Read Committed)：</p><p>只能读取到已经提交的数据。Oracle 等多数数据库默认都是该级别 (不重复读)</p></li><li><p>可重复读(Repeated Read)：</p><p>在同一个事务内的查询都是事务开始时刻一致的，Mysql 的 InnoDB 默认级别。在 SQL 标准中，该隔离级别消除了不可重复读，但是还存在幻读（多个事务同时修改同一条记录，事务之间不知道彼此存在，当事务提交之后，后面的事务修改的数据将会覆盖前事务，前一个事务就像发生幻觉一样）</p></li><li><p>串行化(Serializable)：</p><p>完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>提未交读(Read Uncommitted)</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>提交读(Read Committed)</td><td>禁止</td><td>允许</td><td>允许</td></tr><tr><td>可重复读(Repeated Read)</td><td>禁止</td><td>禁止</td><td>允许</td></tr><tr><td>串行化(Serializable)</td><td>禁止</td><td>禁止</td><td>禁止</td></tr></tbody></table><p>不可重复读和幻读的区别主要是：解决不可重复读需要锁定了当前满足条件的记录，而解决幻读需要锁定当前满足条件的记录及相近的记录。比如查询某个商品的信息，可重复读事务隔离级别可以保证当前商品信息被锁定，解决不可重复读；但是如果统计商品个数，中途有记录插入，可重复读事务隔离级别就不能保证两个事务统计的个数相同。</p></li></ul><h2 id="_19、说说事务的传播级别" tabindex="-1"><a class="header-anchor" href="#_19、说说事务的传播级别" aria-hidden="true">#</a> 19、说说事务的传播级别</h2><p>Spring 事务定义了 7 种传播机制：</p><ol><li>PROPAGATION_REQUIRED:默认的 Spring 事物传播级别，若当前存在事务，则加入该事务，若不存在事务，则新建一个事务。</li><li>PAOPAGATION_REQUIRE_NEW:若当前没有事务，则新建一个事务。若当前存在事务，则新建一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交。</li><li>PROPAGATION_NESTED:如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务，则新建一个事务，类似于 REQUIRE_NEW。</li><li>PROPAGATION_SUPPORTS:支持当前事务，若当前不存在事务，以非事务的方式执行。</li><li>PROPAGATION_NOT_SUPPORTED:以非事务的方式执行，若当前存在事务，则把当前事务挂起。</li><li>PROPAGATION_MANDATORY:强制事务执行，若当前不存在事务，则抛出异常.</li><li>PROPAGATION_NEVER:以非事务的方式执行，如果当前存在事务，则抛出异常。 Spring 事务传播级别一般不需要定义，默认就是 PROPAGATION_REQUIRED，除非在嵌套事务的情况下需要重点了解。</li></ol><h2 id="_20、spring-事务实现方式" tabindex="-1"><a class="header-anchor" href="#_20、spring-事务实现方式" aria-hidden="true">#</a> 20、Spring 事务实现方式</h2><ul><li>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li><li>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者 XML 配置管理事务。</li></ul><h2 id="_21、-spring框架的事务管理有哪些优点" tabindex="-1"><a class="header-anchor" href="#_21、-spring框架的事务管理有哪些优点" aria-hidden="true">#</a> 21、 Spring框架的事务管理有哪些优点</h2><p>它为不同的事务 API(如 JTA, JDBC, Hibernate, JPA, 和 JDO)提供了统一的编程模型。它为编程式事务管理提供了一个简单的 API 而非一系列复杂的事务 API(如 JTA).它支持声明式事务管理。它可以和 Spring 的多种数据访问技术很好的融合。</p><p>它为不同的事务 API(如 JTA, JDBC, Hibernate, JPA, 和 JDO)提供了统一的编程模型。它为编程式事务管理提供了一个简单的 API 而非一系列复杂的事务 API(如 JTA).它支持声明式事务管理。它可以和 Spring 的多种数据访问技术很好的融合。</p><p>它为不同的事务 API(如 JTA, JDBC, Hibernate, JPA, 和 JDO)提供了统一的编程模型。它为编程式事务管理提供了一个简单的 API 而非一系列复杂的事务 API(如 JTA).它支持声明式事务管理。它可以和 Spring 的多种数据访问技术很好的融合。</p><h2 id="_22、事务三要素是什么" tabindex="-1"><a class="header-anchor" href="#_22、事务三要素是什么" aria-hidden="true">#</a> 22、事务三要素是什么？</h2><ul><li><strong>数据源</strong>：表示具体的事务性资源，是事务的真正处理者，如 MySQL 等。</li><li><strong>事务管理器</strong> ：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</li><li><strong>事务应用和属性配置</strong> ：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。</li></ul><h2 id="_23、-事务注解的本质是什么" tabindex="-1"><a class="header-anchor" href="#_23、-事务注解的本质是什么" aria-hidden="true">#</a> 23、 事务注解的本质是什么？</h2><p>@Transactional 这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置bean的事务行为。大致来说具有两方面功能</p><ul><li>一是表明该方法要参与事务</li><li>二是配置相关属性来定制事务的参与方式和运行行为</li></ul><p>声明式事务主要是得益于 Spring AOP，使用一个事务拦截器，在方法调用的前后/周围进行事务性增强（advice），来驱动事务完成。</p><p>@Transactional 注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所有方法。如果此时方法上也标注了，则方法上的优先级高。 另外注意方法一定要是 <strong>public</strong> 的。</p><h2 id="_24、在-spring-aop-中-关注点和横切关注的区别是什么" tabindex="-1"><a class="header-anchor" href="#_24、在-spring-aop-中-关注点和横切关注的区别是什么" aria-hidden="true">#</a> 24、在 Spring AOP 中，关注点和横切关注的区别是什么？</h2><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><p>那什么是连接点呢？连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个 AOP 切面，它实际上是个应用程序执行 Spring AOP 的位置。</p><p>切入点是什么？切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p><h2 id="_25、什么是通知呢-有哪些类型呢" tabindex="-1"><a class="header-anchor" href="#_25、什么是通知呢-有哪些类型呢" aria-hidden="true">#</a> 25、什么是通知呢？有哪些类型呢？</h2><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过 SpringAOP 框架触发的代码段。</p><p>Spring 切面可以应用五种类型的通知：</p><ul><li><strong>before</strong>：前置通知，在一个方法执行前被调用。</li><li><strong>after</strong> : 在方法执行之后调用的通知，无论方法执行是否成功。</li><li><strong>after-returning</strong> : 仅当方法成功完成后执行的通知。</li><li><strong>after-throwing</strong> : 在方法抛出异常退出时执行的通知。</li><li><strong>around</strong> : 在方法执行之前和之后调用的通知。</li></ul><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/imdtf/blog/edit/main/docs/interview/spring.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" aria-labelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/5/18 23:27:14</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: imdtf@qq.com">DTF</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/interview/multi-thread.html" class="nav-link prev" aria-label="多线程&amp;并发篇"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->多线程&amp;并发篇</div></a><a href="/interview/spring-boot.html" class="nav-link next" aria-label="SpringBoot 篇"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">SpringBoot 篇<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2022 DTF</div></footer><!--]--></div><!--]--><!----><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewbox="0 0 1024 1024" aria-labelledby="close"><title id="close" lang="en">close icon</title><g fill="currentColor"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></g></svg></button><div class="logo"><!----><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!----><!----></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button class="install-button">安装<span></span></button><button class="cancel-button">取消</button></div></div></div></div><!--]--></div>
    <script type="module" src="/assets/app.597ce2f2.js" defer></script>
  </body>
</html>
