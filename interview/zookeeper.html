<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.43" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-v2-demo.mrhope.site/interview/zookeeper.html"><meta property="og:site_name" content="DTF's blog"><meta property="og:title" content="Zookeeper 篇"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-06-08T15:47:48.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-06-08T15:47:48.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>Zookeeper 篇 | DTF's blog</title><meta name="description" content="我的学习记录博客">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.af58f80f.css">
    <link rel="modulepreload" href="/assets/app.597ce2f2.js"><link rel="modulepreload" href="/assets/zookeeper.html.d47f6f3b.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/zookeeper.html.75896320.js"><link rel="prefetch" href="/assets/index.html.e173ef83.js"><link rel="prefetch" href="/assets/ElasticSearch.html.279e5d7b.js"><link rel="prefetch" href="/assets/MQ.html.9d040945.js"><link rel="prefetch" href="/assets/MySQL.html.d1ae2d1e.js"><link rel="prefetch" href="/assets/Redis.html.b201ad05.js"><link rel="prefetch" href="/assets/design-patterns.html.733535fa.js"><link rel="prefetch" href="/assets/dubbo.html.c776d990.js"><link rel="prefetch" href="/assets/git.html.72b47aa0.js"><link rel="prefetch" href="/assets/java-base.html.db5311da.js"><link rel="prefetch" href="/assets/jvm.html.53d34a5d.js"><link rel="prefetch" href="/assets/linux.html.65017b81.js"><link rel="prefetch" href="/assets/maven.html.ceec6571.js"><link rel="prefetch" href="/assets/multi-thread.html.3652cc7f.js"><link rel="prefetch" href="/assets/mybatis.html.cb44fe5a.js"><link rel="prefetch" href="/assets/network.html.b1609fd9.js"><link rel="prefetch" href="/assets/nginx.html.9ca67d3a.js"><link rel="prefetch" href="/assets/soft-power.html.508fb44f.js"><link rel="prefetch" href="/assets/spring-boot.html.e888e4e7.js"><link rel="prefetch" href="/assets/spring-cloud.html.57c2b0d4.js"><link rel="prefetch" href="/assets/spring.html.94b261f5.js"><link rel="prefetch" href="/assets/tomcat.html.dc4aea03.js"><link rel="prefetch" href="/assets/分布式.html.6e369ff9.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.58f6dba8.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.04b85b76.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.116abb6a.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.1d83f138.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.40f6f1e4.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.900bda42.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.3492d336.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.dcc88998.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.7239f150.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.6199feb4.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.57624587.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.d99caa1b.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.cabd308f.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.c89015fe.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.6b8e9ff0.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.e1e4da4a.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.697b9a23.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.9000e742.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.4d12fb46.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.48d80708.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.da9eab5a.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.95150d1c.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.b9bda91b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.bb805e63.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.514eb232.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.4cfc99f3.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.1561ec1a.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.11ef8b3e.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.ef765715.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.50f4f1d6.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.60a1c908.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.b6c6ee60.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.0fa73bd5.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.bfe213be.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.e0558584.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.3087bc74.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.c5df5f6e.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.b9edc687.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.9906de00.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.4b8670c8.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.b78f67d4.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b762f081.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.e5ec66c1.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.f9b4c2c6.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.d4daa082.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.1f616fc4.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.25fe22f4.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.8bb53047.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.63f53d07.js"><link rel="prefetch" href="/assets/00-Introduction.html.aed5c856.js"><link rel="prefetch" href="/assets/00-Preface.html.feee9db3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.ab6ea8b6.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.0224a9bf.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.bea55af9.js"><link rel="prefetch" href="/assets/04-Operators.html.35525abf.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.c4cd86f5.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.b5c2b268.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.399ae58f.js"><link rel="prefetch" href="/assets/08-Reuse.html.0ab07e65.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.89443cf5.js"><link rel="prefetch" href="/assets/10-Interfaces.html.4948bb7b.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.b8f6a196.js"><link rel="prefetch" href="/assets/12-Collections.html.52f2a06b.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.db50a84d.js"><link rel="prefetch" href="/assets/14-Streams.html.9308751d.js"><link rel="prefetch" href="/assets/15-Exceptions.html.40e68d98.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.3edda5f0.js"><link rel="prefetch" href="/assets/17-Files.html.e87e7c99.js"><link rel="prefetch" href="/assets/18-Strings.html.a2842b17.js"><link rel="prefetch" href="/assets/19-Type-Information.html.12cc605b.js"><link rel="prefetch" href="/assets/20-Generics.html.3e4b17f6.js"><link rel="prefetch" href="/assets/21-Arrays.html.67720723.js"><link rel="prefetch" href="/assets/22-Enumerations.html.ab50f89b.js"><link rel="prefetch" href="/assets/23-Annotations.html.747faef3.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.5b9841aa.js"><link rel="prefetch" href="/assets/25-Patterns.html.10af6fe7.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.13f6de18.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.4774ac79.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.fec6d369.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.fe3a1870.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.35950f4f.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.54af4f5f.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.bb07240e.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.8f39ad15.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.39836314.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.ee52b83c.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.68302b50.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.9b5edd63.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.c8a5f6e1.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.34dcd815.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.8c0a6980.js"><link rel="prefetch" href="/assets/GLOSSARY.html.af317d6f.js"><link rel="prefetch" href="/assets/index.html.859506fe.js"><link rel="prefetch" href="/assets/404.html.61bcede7.js"><link rel="prefetch" href="/assets/index.html.6eefb2c9.js"><link rel="prefetch" href="/assets/index.html.276bb6b8.js"><link rel="prefetch" href="/assets/index.html.6c49b0c9.js"><link rel="prefetch" href="/assets/index.html.938faca6.js"><link rel="prefetch" href="/assets/index.html.234dfb8d.js"><link rel="prefetch" href="/assets/index.html.02cffa46.js"><link rel="prefetch" href="/assets/index.html.c70b19c7.js"><link rel="prefetch" href="/assets/index.html.e9ae5772.js"><link rel="prefetch" href="/assets/index.html.43ef8dd6.js"><link rel="prefetch" href="/assets/index.html.0319d1c3.js"><link rel="prefetch" href="/assets/ElasticSearch.html.1822d360.js"><link rel="prefetch" href="/assets/MQ.html.257a1eec.js"><link rel="prefetch" href="/assets/MySQL.html.12265bed.js"><link rel="prefetch" href="/assets/Redis.html.c5915ac6.js"><link rel="prefetch" href="/assets/design-patterns.html.4dff82bc.js"><link rel="prefetch" href="/assets/dubbo.html.70900b5c.js"><link rel="prefetch" href="/assets/git.html.9f0ce8a6.js"><link rel="prefetch" href="/assets/java-base.html.f9b49957.js"><link rel="prefetch" href="/assets/jvm.html.7b42d915.js"><link rel="prefetch" href="/assets/linux.html.9f1e7d55.js"><link rel="prefetch" href="/assets/maven.html.f848fc43.js"><link rel="prefetch" href="/assets/multi-thread.html.5d323dfe.js"><link rel="prefetch" href="/assets/mybatis.html.868f5463.js"><link rel="prefetch" href="/assets/network.html.347740e9.js"><link rel="prefetch" href="/assets/nginx.html.acf44958.js"><link rel="prefetch" href="/assets/soft-power.html.fa4cc2bb.js"><link rel="prefetch" href="/assets/spring-boot.html.eb446c44.js"><link rel="prefetch" href="/assets/spring-cloud.html.5a2e7953.js"><link rel="prefetch" href="/assets/spring.html.e5d334fa.js"><link rel="prefetch" href="/assets/tomcat.html.1edb1280.js"><link rel="prefetch" href="/assets/分布式.html.8362b544.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.e0b3e691.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.73dedd46.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.a7a61510.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.19af1cfc.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.078c9131.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.3da35573.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.ee1e2ba2.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.5796a618.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.26f3a028.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.cbc4b5ad.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.d79a5425.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.8dab2c77.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.f8e03fcd.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.f1c1f80f.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.a0b4da7e.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.8cf5825d.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.63173a34.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.a51cc121.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.55632279.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.aa190da2.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.c311f962.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.bef20aad.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.54dcb84b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.baae2fb3.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.de07d445.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.d8703177.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.93feb431.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.14ad8743.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.2e4d7d89.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.ebe6ec2f.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.a1a0d482.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.7353d51d.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.b546fd0e.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.fa14f195.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.ddaebd47.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.9f503937.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.95f81089.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.354471cd.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.c9d4ab47.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.9b369837.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.93069f29.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b6a68508.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.4cda471b.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.fec20cbf.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.46eb93f8.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.70884000.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.16cc56b7.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.0f6a9d34.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.ced5f781.js"><link rel="prefetch" href="/assets/00-Introduction.html.2b1f0852.js"><link rel="prefetch" href="/assets/00-Preface.html.e516d7c3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.86c4af1e.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.88cddd12.js"><link rel="prefetch" href="/assets/03-Objects-Everywhere.html.4da53003.js"><link rel="prefetch" href="/assets/04-Operators.html.f9d313c6.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.ecf81ffe.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.c35ecf1b.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.396e0a6f.js"><link rel="prefetch" href="/assets/08-Reuse.html.8c7c4047.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.2150cc57.js"><link rel="prefetch" href="/assets/10-Interfaces.html.6ee853fa.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.ae7b89c4.js"><link rel="prefetch" href="/assets/12-Collections.html.0483e4dd.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.63412e72.js"><link rel="prefetch" href="/assets/14-Streams.html.7e7cce42.js"><link rel="prefetch" href="/assets/15-Exceptions.html.c186f23a.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.b3313ffc.js"><link rel="prefetch" href="/assets/17-Files.html.7a9ad498.js"><link rel="prefetch" href="/assets/18-Strings.html.46e57539.js"><link rel="prefetch" href="/assets/19-Type-Information.html.b68894bf.js"><link rel="prefetch" href="/assets/20-Generics.html.3993804b.js"><link rel="prefetch" href="/assets/21-Arrays.html.4d150e5c.js"><link rel="prefetch" href="/assets/22-Enumerations.html.87d060f0.js"><link rel="prefetch" href="/assets/23-Annotations.html.0c455464.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.8485a02c.js"><link rel="prefetch" href="/assets/25-Patterns.html.4f5781b0.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.4e7ecda3.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.1a18282e.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.ec4969df.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.c956724d.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.ac5ea88b.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.26db6884.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.80dbdde9.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.613e991c.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.de90320b.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.1f3841f2.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.a3de1972.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.28579d58.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.aae5a747.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.4bf49d65.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.9d9599c8.js"><link rel="prefetch" href="/assets/GLOSSARY.html.d812823c.js"><link rel="prefetch" href="/assets/index.html.d25b0535.js"><link rel="prefetch" href="/assets/404.html.0c8252b8.js"><link rel="prefetch" href="/assets/index.html.d5cc08ad.js"><link rel="prefetch" href="/assets/index.html.1331f6ca.js"><link rel="prefetch" href="/assets/index.html.da6c3a69.js"><link rel="prefetch" href="/assets/index.html.1174fbbd.js"><link rel="prefetch" href="/assets/index.html.c73d2264.js"><link rel="prefetch" href="/assets/index.html.1e315145.js"><link rel="prefetch" href="/assets/index.html.514b72a3.js"><link rel="prefetch" href="/assets/index.html.b19f5086.js"><link rel="prefetch" href="/assets/index.html.1ac6115e.js"><link rel="prefetch" href="/assets/404.3a5fd86b.js"><link rel="prefetch" href="/assets/Layout.42785ec5.js"><link rel="prefetch" href="/assets/Slide.5e14cdfb.js"><link rel="prefetch" href="/assets/Blog.f29d76d0.js"><link rel="prefetch" href="/assets/auto.esm.15d52109.js"><link rel="prefetch" href="/assets/index.1842ee54.js"><link rel="prefetch" href="/assets/mermaid.esm.min.f71f1464.js"><link rel="prefetch" href="/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/assets/photoswipe.esm.92018b73.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="DTF&#39;s blog"><!----><span class="site-name hide-in-pad">DTF&#39;s blog</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guide/" class="nav-link" aria-label="使用指南"><i class="icon iconfont icon-creative"></i>使用指南<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/imdtf/blog" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" aria-labelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewbox="0 0 1024 1024" aria-labelledby="outlook"><title id="outlook" lang="en">outlook icon</title><g fill="currentColor"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></g></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-guide"></i><span class="title">语言</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-markdown"></i><span class="title">数据库</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-question"></i><span class="title">面试题</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/interview/java-base.html" class="nav-link sidebar-link sidebar-page" aria-label="基础篇"><!---->基础篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/jvm.html" class="nav-link sidebar-link sidebar-page" aria-label="JVM 篇"><!---->JVM 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/multi-thread.html" class="nav-link sidebar-link sidebar-page" aria-label="多线程&amp;并发篇"><!---->多线程&amp;并发篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring.html" class="nav-link sidebar-link sidebar-page" aria-label="Spring 篇"><!---->Spring 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-boot.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringBoot 篇"><!---->SpringBoot 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/spring-cloud.html" class="nav-link sidebar-link sidebar-page" aria-label="SpringCloud 篇"><!---->SpringCloud 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/dubbo.html" class="nav-link sidebar-link sidebar-page" aria-label="Dubbo 篇"><!---->Dubbo 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/mybatis.html" class="nav-link sidebar-link sidebar-page" aria-label="MyBatis 篇"><!---->MyBatis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MySQL.html" class="nav-link sidebar-link sidebar-page" aria-label="MySQL 篇"><!---->MySQL 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/nginx.html" class="nav-link sidebar-link sidebar-page" aria-label="Nginx 篇"><!---->Nginx 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/MQ.html" class="nav-link sidebar-link sidebar-page" aria-label="MQ 篇"><!---->MQ 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/linux.html" class="nav-link sidebar-link sidebar-page" aria-label="Linux 篇"><!---->Linux 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/interview/zookeeper.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Zookeeper 篇"><!---->Zookeeper 篇<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_1、说说-zookeeper-是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1、说说 Zookeeper 是什么？"><!---->1、说说 Zookeeper 是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_2、zookeeper-有哪些应用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2、ZooKeeper 有哪些应用场景？"><!---->2、ZooKeeper 有哪些应用场景？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_3、说说zookeeper的工作原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3、说说Zookeeper的工作原理？"><!---->3、说说Zookeeper的工作原理？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_4-请描述一下-zookeeper-的通知机制是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4，请描述一下 Zookeeper 的通知机制是什么？"><!---->4，请描述一下 Zookeeper 的通知机制是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_5、zookeeper-对节点的-watch-监听通知是永久的吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5、Zookeeper 对节点的 watch 监听通知是永久的吗？"><!---->5、Zookeeper 对节点的 watch 监听通知是永久的吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_6、zookeeper-集群中有哪些角色" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6、Zookeeper 集群中有哪些角色？"><!---->6、Zookeeper 集群中有哪些角色？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_7、zookeeper-集群中-server-有哪些工作状态" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="7、Zookeeper 集群中 Server 有哪些工作状态？"><!---->7、Zookeeper 集群中 Server 有哪些工作状态？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_8、zookeeper-集群中是怎样选举-leader-的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="8、Zookeeper 集群中是怎样选举 leader 的？"><!---->8、Zookeeper 集群中是怎样选举 leader 的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_9、zookeeper-是如何保证事务的顺序一致性的呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="9、Zookeeper 是如何保证事务的顺序一致性的呢？"><!---->9、Zookeeper 是如何保证事务的顺序一致性的呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_10、zookeeper-集群中个服务器之间是怎样通信的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="10、ZooKeeper 集群中个服务器之间是怎样通信的？"><!---->10、ZooKeeper 集群中个服务器之间是怎样通信的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_11、zookeeper-分布式锁怎么实现的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="11、ZooKeeper 分布式锁怎么实现的？"><!---->11、ZooKeeper 分布式锁怎么实现的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_12、了解zookeeper的系统架构吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="12、了解Zookeeper的系统架构吗？"><!---->12、了解Zookeeper的系统架构吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_13、zookeeper为什么要这么设计" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="13、Zookeeper为什么要这么设计？"><!---->13、Zookeeper为什么要这么设计？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_14、你知道zookeeper中有哪些角色" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="14、你知道Zookeeper中有哪些角色？"><!---->14、你知道Zookeeper中有哪些角色？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_15、你熟悉zookeeper节点znode和相关属性吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="15、你熟悉Zookeeper节点ZNode和相关属性吗？"><!---->15、你熟悉Zookeeper节点ZNode和相关属性吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_16、请简述zookeeper的选主流程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="16、请简述Zookeeper的选主流程"><!---->16、请简述Zookeeper的选主流程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_17、为什么zookeeper集群的数目-一般为奇数个" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="17、为什么Zookeeper集群的数目，一般为奇数个？"><!---->17、为什么Zookeeper集群的数目，一般为奇数个？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_18、知道zookeeper监听器的原理吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="18、知道Zookeeper监听器的原理吗？"><!---->18、知道Zookeeper监听器的原理吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_19、说说zookeeper中的acl-权限控制机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="19、说说Zookeeper中的ACL 权限控制机制"><!---->19、说说Zookeeper中的ACL 权限控制机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_20、zookeeper-有哪几种几种部署模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="20、Zookeeper 有哪几种几种部署模式？"><!---->20、Zookeeper 有哪几种几种部署模式？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_21、zookeeper集群支持动态添加机器吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="21、Zookeeper集群支持动态添加机器吗？"><!---->21、Zookeeper集群支持动态添加机器吗？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_22、描述一下-zab-协议" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="22、描述一下 ZAB 协议"><!---->22、描述一下 ZAB 协议<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_23、zab-和-paxos-算法的联系与区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="23、ZAB 和 Paxos 算法的联系与区别？"><!---->23、ZAB 和 Paxos 算法的联系与区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_24、zookeeper-宕机如何处理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="24、ZooKeeper 宕机如何处理？"><!---->24、ZooKeeper 宕机如何处理？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_25、-描述一下-zookeeper-的-session-管理的思想" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="25、 描述一下 ZooKeeper 的 session 管理的思想？"><!---->25、 描述一下 ZooKeeper 的 session 管理的思想？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_26、zookeeper-负载均衡和-nginx-负载均衡有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="26、ZooKeeper 负载均衡和 Nginx 负载均衡有什么区别？"><!---->26、ZooKeeper 负载均衡和 Nginx 负载均衡有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_27、说说zookeeper-的序列化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="27、说说ZooKeeper 的序列化"><!---->27、说说ZooKeeper 的序列化<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_28-在zookeeper-中-zxid-是什么-有什么作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="28，在Zookeeper 中 Zxid 是什么，有什么作用？"><!---->28，在Zookeeper 中 Zxid 是什么，有什么作用？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_29、讲解一下-zookeeper-的持久化机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="29、讲解一下 ZooKeeper 的持久化机制"><!---->29、讲解一下 ZooKeeper 的持久化机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_30、zookeeper选举中投票信息的五元组是什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="30、Zookeeper选举中投票信息的五元组是什么？"><!---->30、Zookeeper选举中投票信息的五元组是什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_31、说说zookeeper中的脑裂" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="31、说说Zookeeper中的脑裂？"><!---->31、说说Zookeeper中的脑裂？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_32、zookeeper脑裂是什么原因导致的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="32、Zookeeper脑裂是什么原因导致的？"><!---->32、Zookeeper脑裂是什么原因导致的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_33、zookeeper-是如何解决脑裂问题的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="33、Zookeeper 是如何解决脑裂问题的？"><!---->33、Zookeeper 是如何解决脑裂问题的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_34、说说-zookeeper-的-cap-问题上做的取舍" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="34、说说 Zookeeper 的 CAP 问题上做的取舍？"><!---->34、说说 Zookeeper 的 CAP 问题上做的取舍？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/interview/zookeeper.html#_35、watch-监听为什么是一次性的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="35、watch 监听为什么是一次性的？"><!---->35、watch 监听为什么是一次性的？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/interview/Redis.html" class="nav-link sidebar-link sidebar-page" aria-label="Redis 篇"><!---->Redis 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/%E5%88%86%E5%B8%83%E5%BC%8F.html" class="nav-link sidebar-link sidebar-page" aria-label="分布式篇"><!---->分布式篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/network.html" class="nav-link sidebar-link sidebar-page" aria-label="网络篇"><!---->网络篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/design-patterns.html" class="nav-link sidebar-link sidebar-page" aria-label="设计模式"><!---->设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/maven.html" class="nav-link sidebar-link sidebar-page" aria-label="maven 篇"><!---->maven 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/ElasticSearch.html" class="nav-link sidebar-link sidebar-page" aria-label="ElasticSearch 篇"><!---->ElasticSearch 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/tomcat.html" class="nav-link sidebar-link sidebar-page" aria-label="tomcat 篇"><!---->tomcat 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/git.html" class="nav-link sidebar-link sidebar-page" aria-label="Git 篇"><!---->Git 篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/interview/soft-power.html" class="nav-link sidebar-link sidebar-page" aria-label="软实力篇"><!---->软实力篇<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Zookeeper 篇</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" aria-labelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://github.com/imdtf" target="_blank" rel="noopener noreferrer">DTF</a></span><span property="author" content="DTF"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" aria-labelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年6月8日</span><meta property="datePublished" content="2022-06-08T15:47:48.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" aria-labelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 39 分钟</span><meta property="timeRequired" content="PT39M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_1、说说-zookeeper-是什么" class="router-link-active router-link-exact-active toc-link level2">1、说说 Zookeeper 是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_2、zookeeper-有哪些应用场景" class="router-link-active router-link-exact-active toc-link level2">2、ZooKeeper 有哪些应用场景？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_3、说说zookeeper的工作原理" class="router-link-active router-link-exact-active toc-link level2">3、说说Zookeeper的工作原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_4-请描述一下-zookeeper-的通知机制是什么" class="router-link-active router-link-exact-active toc-link level2">4，请描述一下 Zookeeper 的通知机制是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_5、zookeeper-对节点的-watch-监听通知是永久的吗" class="router-link-active router-link-exact-active toc-link level2">5、Zookeeper 对节点的 watch 监听通知是永久的吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_6、zookeeper-集群中有哪些角色" class="router-link-active router-link-exact-active toc-link level2">6、Zookeeper 集群中有哪些角色？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_7、zookeeper-集群中-server-有哪些工作状态" class="router-link-active router-link-exact-active toc-link level2">7、Zookeeper 集群中 Server 有哪些工作状态？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_8、zookeeper-集群中是怎样选举-leader-的" class="router-link-active router-link-exact-active toc-link level2">8、Zookeeper 集群中是怎样选举 leader 的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_9、zookeeper-是如何保证事务的顺序一致性的呢" class="router-link-active router-link-exact-active toc-link level2">9、Zookeeper 是如何保证事务的顺序一致性的呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_10、zookeeper-集群中个服务器之间是怎样通信的" class="router-link-active router-link-exact-active toc-link level2">10、ZooKeeper 集群中个服务器之间是怎样通信的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_11、zookeeper-分布式锁怎么实现的" class="router-link-active router-link-exact-active toc-link level2">11、ZooKeeper 分布式锁怎么实现的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_12、了解zookeeper的系统架构吗" class="router-link-active router-link-exact-active toc-link level2">12、了解Zookeeper的系统架构吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_13、zookeeper为什么要这么设计" class="router-link-active router-link-exact-active toc-link level2">13、Zookeeper为什么要这么设计？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_14、你知道zookeeper中有哪些角色" class="router-link-active router-link-exact-active toc-link level2">14、你知道Zookeeper中有哪些角色？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_15、你熟悉zookeeper节点znode和相关属性吗" class="router-link-active router-link-exact-active toc-link level2">15、你熟悉Zookeeper节点ZNode和相关属性吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_16、请简述zookeeper的选主流程" class="router-link-active router-link-exact-active toc-link level2">16、请简述Zookeeper的选主流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_17、为什么zookeeper集群的数目-一般为奇数个" class="router-link-active router-link-exact-active toc-link level2">17、为什么Zookeeper集群的数目，一般为奇数个？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_18、知道zookeeper监听器的原理吗" class="router-link-active router-link-exact-active toc-link level2">18、知道Zookeeper监听器的原理吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_19、说说zookeeper中的acl-权限控制机制" class="router-link-active router-link-exact-active toc-link level2">19、说说Zookeeper中的ACL 权限控制机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_20、zookeeper-有哪几种几种部署模式" class="router-link-active router-link-exact-active toc-link level2">20、Zookeeper 有哪几种几种部署模式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_21、zookeeper集群支持动态添加机器吗" class="router-link-active router-link-exact-active toc-link level2">21、Zookeeper集群支持动态添加机器吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_22、描述一下-zab-协议" class="router-link-active router-link-exact-active toc-link level2">22、描述一下 ZAB 协议</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_23、zab-和-paxos-算法的联系与区别" class="router-link-active router-link-exact-active toc-link level2">23、ZAB 和 Paxos 算法的联系与区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_24、zookeeper-宕机如何处理" class="router-link-active router-link-exact-active toc-link level2">24、ZooKeeper 宕机如何处理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_25、-描述一下-zookeeper-的-session-管理的思想" class="router-link-active router-link-exact-active toc-link level2">25、 描述一下 ZooKeeper 的 session 管理的思想？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_26、zookeeper-负载均衡和-nginx-负载均衡有什么区别" class="router-link-active router-link-exact-active toc-link level2">26、ZooKeeper 负载均衡和 Nginx 负载均衡有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_27、说说zookeeper-的序列化" class="router-link-active router-link-exact-active toc-link level2">27、说说ZooKeeper 的序列化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_28-在zookeeper-中-zxid-是什么-有什么作用" class="router-link-active router-link-exact-active toc-link level2">28，在Zookeeper 中 Zxid 是什么，有什么作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_29、讲解一下-zookeeper-的持久化机制" class="router-link-active router-link-exact-active toc-link level2">29、讲解一下 ZooKeeper 的持久化机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_30、zookeeper选举中投票信息的五元组是什么" class="router-link-active router-link-exact-active toc-link level2">30、Zookeeper选举中投票信息的五元组是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_31、说说zookeeper中的脑裂" class="router-link-active router-link-exact-active toc-link level2">31、说说Zookeeper中的脑裂？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_32、zookeeper脑裂是什么原因导致的" class="router-link-active router-link-exact-active toc-link level2">32、Zookeeper脑裂是什么原因导致的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_33、zookeeper-是如何解决脑裂问题的" class="router-link-active router-link-exact-active toc-link level2">33、Zookeeper 是如何解决脑裂问题的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_34、说说-zookeeper-的-cap-问题上做的取舍" class="router-link-active router-link-exact-active toc-link level2">34、说说 Zookeeper 的 CAP 问题上做的取舍？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/interview/zookeeper.html#_35、watch-监听为什么是一次性的" class="router-link-active router-link-exact-active toc-link level2">35、watch 监听为什么是一次性的？</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h1 id="zookeeper-篇" tabindex="-1"><a class="header-anchor" href="#zookeeper-篇" aria-hidden="true">#</a> Zookeeper 篇</h1><h2 id="_1、说说-zookeeper-是什么" tabindex="-1"><a class="header-anchor" href="#_1、说说-zookeeper-是什么" aria-hidden="true">#</a> 1、说说 Zookeeper 是什么？</h2><p><strong>直译</strong>: 从名字上直译就是动物管理员，动物指的是 Hadoop 一类的分布式软件，管理员三个字体现了 ZooKeeper 的特点：维护、协调、管理、监控。</p><p><strong>简述</strong>: 有些软件你想做成集群或者分布式，你可以用 ZooKeeper 帮你来辅助实现。</p><p><strong>特点</strong> :</p><ul><li>最终一致性：客户端看到的数据最终是一致的。</li><li>可靠性：服务器保存了消息，那么它就一直都存在。</li><li>实时性：ZooKeeper 不能保证两个客户端同时得到刚更新的数据。独立性（等待无关）：不同客户端直接互不影响。</li><li>原子性：更新要不成功要不失败，没有第三个状态。</li></ul><p>注意：回答面试题，切忌只是简单一句话回答，可以将你对概念的理解，特点等多个方面描述一下，哪怕你自己认为不完全切中题意的也可以说说，面试官不喜欢会打断你的，你的目的是让面试官认为你是好沟通的。当然了，如果不会可别装作会，说太多不专业的想法。</p><h2 id="_2、zookeeper-有哪些应用场景" tabindex="-1"><a class="header-anchor" href="#_2、zookeeper-有哪些应用场景" aria-hidden="true">#</a> 2、ZooKeeper 有哪些应用场景？</h2><ul><li><p><strong>数据发布与订阅</strong></p><p>发布与订阅即所谓的配置管理，顾名思义就是将数据发布到 ZooKeeper 节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，地址列表等就非常适合使用。</p><p>数据发布/订阅的一个常见的场景是配置中心，发布者把数据发布到 ZooKeeper 的一个或一系列的节点上，供订阅者进行数据订阅，达到动态获取数据的目的。</p><p>配置信息一般有几个特点:</p><ol><li>数据量小的 KV</li><li>数据内容在运行时会发生动态变化</li><li>集群机器共享，配置一致</li></ol><p>ZooKeeper 采用的是推拉结合的方式。</p><ol><li>推: 服务端会推给注册了监控节点的客户端 Wathcer 事件通知</li><li>拉: 客户端获得通知后，然后主动到服务端拉取最新的数据</li></ol></li><li><p><strong>命名服务</strong></p><p>作为分布式命名服务，命名服务是指通过指定的名字来获取资源或者服务的地址，利用 ZooKeeper 创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p><p>统一命名服务的命名结构图如下所示：</p><ol><li><p>在分布式环境下，经常需要对应用/服务进行统一命名，便于识别不同服务。</p><p>类似于域名与 IP 之间对应关系，IP 不容易记住，而域名容易记住。</p><p>通过名称来获取资源或服务的地址，提供者等信息。</p></li><li><p>按照层次结构组织服务/应用名称。 可将服务名称以及地址信息写到 ZooKeeper 上，客户端通过 ZooKeeper 获取可用服务列表类。</p></li></ol></li><li><p><strong>配置管理</strong></p><p>程序分布式的部署在不同的机器上，将程序的配置信息放在 ZooKeeper 的 znode 下，当有配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的内容，利用 watch 通知给各个客户端从而更改配置。</p><p>ZooKeeper 配置管理结构图如下所示：</p><ol><li><p>分布式环境下，配置文件管理和同步是一个常见问题。</p><p>一个集群中，所有节点的配置信息是一致的，比如 Hadoop 集群。</p><p>对配置文件修改后，希望能够快速同步到各个节点上。</p></li><li><p>配置管理可交由 ZooKeeper 实现。</p><p>可将配置信息写入 ZooKeeper 上的一个 Znode。各个节点监听这个 Znode。</p><p>一旦 Znode 中的数据被修改，ZooKeeper 将通知各个节点。</p></li></ol></li><li><p><strong>集群管理</strong></p><p>所谓集群管理就是：是否有机器退出和加入、选举 master。</p><p>集群管理主要指集群监控和集群控制两个方面。前者侧重于集群运行时的状态的收集，后者则是对集群进行操作与控制。开发和运维中，面对集群，经常有如下需求:</p><ol><li>希望知道集群中究竟有多少机器在工作</li><li>对集群中的每台机器的运行时状态进行数据收集</li><li>对集群中机器进行上下线的操作</li></ol><p>集群管理结构图如下所示：</p><ol><li><p>分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。</p></li><li><p>可交由 ZooKeeper 实现。</p><p>可将节点信息写入 ZooKeeper 上的一个 Znode。</p><p>监听这个 Znode 可获取它的实时状态变化。</p></li><li><p>典型应用: Hbase 中 Master 状态监控与选举。</p></li></ol><p>利用 ZooKeeper 的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功</p></li><li><p><strong>分布式通知与协调</strong></p><ol><li><p>分布式环境中，经常存在一个服务需要知道它所管理的子服务的状态。</p><p>NameNode 需知道各个 Datanode 的状态。</p><p>JobTracker 需知道各个 TaskTracker 的状态。</p></li><li><p>心跳检测机制可通过 ZooKeeper 来实现。</p></li><li><p>信息推送可由 ZooKeeper 来实现，ZooKeeper 相当于一个发布/订阅系统。</p></li></ol></li><li><p><strong>分布式锁</strong></p><p>处于不同节点上不同的服务，它们可能需要顺序的访问一些资源，这里需要一把分布式的锁。分布式锁具有以下特性：写锁、读锁、时序锁。</p><ul><li>写锁：在 zk 上创建的一个临时的无编号的节点。由于是无序编号，在创建时不会自动编号，导致只能客户端有一个客户端得到锁，然后进行写入。</li><li>读锁：在 zk 上创建一个临时的有编号的节点，这样即使下次有客户端加入是同时创建相同的节点时，他也会自动编号，也可以获得锁对象，然后对其进行读取。</li></ul></li><li><p>时序锁：在 zk 上创建的一个临时的有编号的节点根据编号的大小控制锁。</p></li></ul><p><strong>分布式队列</strong></p><p>分布式队列分为两种：</p><ol><li><p>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。</p><p>一个 job 由多个 task 组成，只有所有任务完成后，job 才运行完成。</p><p>可为 job 创建一个/job 目录，然后在该目录下，为每个完成的 task 创建一个临时的 Znode，一旦临时节点数目达到 task 总数，则表明 job 运行完成。</p></li><li><p>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。</p></li></ol><h2 id="_3、说说zookeeper的工作原理" tabindex="-1"><a class="header-anchor" href="#_3、说说zookeeper的工作原理" aria-hidden="true">#</a> 3、说说Zookeeper的工作原理？</h2><p>Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议。</p><p>Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。</p><p>Zab 协议的全称是 Zookeeper Atomic Broadcast (Zookeeper 原子广播)。Zookeeper 是通过 Zab 协议来保证分布式事务的最终一致性。Zab 协议要求每个 Leader 都要经历三个阶段：发现，同步，广播。</p><p>当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p><p>为了保证事务的顺序一致性，zookeeper 采用了递增的事务 id 号（zxid）来标识事务。所有的提议 (proposal) 都在被提出的时候加上了 zxid。实现中 zxid 是一个 64 位的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低 32 位用于递增计数。</p><p>epoch：可以理解为皇帝的年号，当新的皇帝 leader 产生后，将有一个新的 epoch 年号。</p><p>每个 Server 在工作过程中有三种状态：</p><ul><li>LOOKING：当前 Server 不知道 leader 是谁，正在搜寻。</li><li>LEADING：当前 Server 即为选举出来的 leader。</li><li>FOLLOWING：leader 已经选举出来，当前 Server 与之同步。</li></ul><h2 id="_4-请描述一下-zookeeper-的通知机制是什么" tabindex="-1"><a class="header-anchor" href="#_4-请描述一下-zookeeper-的通知机制是什么" aria-hidden="true">#</a> 4，请描述一下 Zookeeper 的通知机制是什么？</h2><p>Zookeeper允许客户端向服务端的某个 znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher ，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</p><p>大致分为三个步骤：</p><ul><li><p>客户端注册 Watcher</p><ol><li>调用 getData、getChildren、exist 三个 API ，传入 Watcher 对象。</li><li>标记请求 request ，封装 Watcher 到 WatchRegistration 。</li><li>封装成 Packet 对象，发服务端发送 request 。</li><li>收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理。</li><li>请求返回，完成注册。</li></ol></li><li><p>服务端处理 Watcher</p><ol><li>服务端接收 Watcher 并存储 。</li><li>Watcher 触发</li><li>调用 process 方法来触发 Watcher 。</li></ol></li><li><p>客户端回调 Watcher</p><ol><li>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher 。</li><li>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。</li></ol><p>client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。</p></li></ul><h2 id="_5、zookeeper-对节点的-watch-监听通知是永久的吗" tabindex="-1"><a class="header-anchor" href="#_5、zookeeper-对节点的-watch-监听通知是永久的吗" aria-hidden="true">#</a> 5、Zookeeper 对节点的 watch 监听通知是永久的吗？</h2><p>不是，一次性的。无论是服务端还是客户端，一旦一个 Watcher 被触发, Zookeeper都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</p><h2 id="_6、zookeeper-集群中有哪些角色" tabindex="-1"><a class="header-anchor" href="#_6、zookeeper-集群中有哪些角色" aria-hidden="true">#</a> 6、Zookeeper 集群中有哪些角色？</h2><p>在一个集群中，最少需要 3 台。或者保证 2N + 1 台，即奇数。为什么保证奇数？主要是为了选举算法。</p><h2 id="_7、zookeeper-集群中-server-有哪些工作状态" tabindex="-1"><a class="header-anchor" href="#_7、zookeeper-集群中-server-有哪些工作状态" aria-hidden="true">#</a> 7、Zookeeper 集群中 Server 有哪些工作状态？</h2><ul><li><p><strong>LOOKING</strong></p><p>寻找 Leader 状态；当服务器处于该状态时，它会认为当前集群中没有 Leader ，因此需要进入 Leader 选举状态</p></li><li><p><strong>FOLLOWING</strong></p><p>跟随者状态；表明当前服务器角色是 Follower</p></li><li><p><strong>LEADING</strong> 领导者状态；表明当前服务器角色是 Leader</p></li><li><p><strong>OBSERVING</strong> 观察者状态；表明当前服务器角色是 Observer</p></li></ul><h2 id="_8、zookeeper-集群中是怎样选举-leader-的" tabindex="-1"><a class="header-anchor" href="#_8、zookeeper-集群中是怎样选举-leader-的" aria-hidden="true">#</a> 8、Zookeeper 集群中是怎样选举 leader 的？</h2><p>当 Leader 崩溃了，或者失去了大多数的 Follower，这时候 Zookeeper 就进入恢复模式，恢复模式需要重新选举出一个新的 Leader，让所有的 Server 都恢复到一个状态<strong>LOOKING</strong> 。</p><p>Zookeeper 有两种选举算法：基于 basic paxos 实现和基于 fast paxos 实现。默认为 fast paxos 由于篇幅问题，这里推荐：<a href="https://www.cnblogs.com/leesf456/p/6107600.html" target="_blank" rel="noopener noreferrer">选举流程<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_9、zookeeper-是如何保证事务的顺序一致性的呢" tabindex="-1"><a class="header-anchor" href="#_9、zookeeper-是如何保证事务的顺序一致性的呢" aria-hidden="true">#</a> 9、Zookeeper 是如何保证事务的顺序一致性的呢？</h2><p>Zookeeper 采用了递增的事务 id 来识别，所有的 proposal (提议)都在被提出的时候加上了zxid 。 zxid 实际上是一个 64 位数字。</p><p>高 32 位是 epoch 用来标识 Leader 是否发生了改变，如果有新的 Leader 产生出来, epoch 会自增。 低 32 位用来递增计数。 当新产生的proposal的时候，会依据数据库的两阶段过程，首先会向其他的 Server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><h2 id="_10、zookeeper-集群中个服务器之间是怎样通信的" tabindex="-1"><a class="header-anchor" href="#_10、zookeeper-集群中个服务器之间是怎样通信的" aria-hidden="true">#</a> 10、ZooKeeper 集群中个服务器之间是怎样通信的？</h2><p>Leader 服务器会和每一个 Follower/Observer 服务器都建立 TCP 连接，同时为每个Follower/Observer 都创建一个叫做 LearnerHandler 的实体。</p><ul><li><p>LearnerHandler 主要负责 Leader 和 Follower/Observer 之间的网络通讯，包括数据同步，请求转发和 proposal 提议的投票等。</p></li><li><p>Leader 服务器保存了所有 Follower/Observer 的 LearnerHandler 。</p></li></ul><h2 id="_11、zookeeper-分布式锁怎么实现的" tabindex="-1"><a class="header-anchor" href="#_11、zookeeper-分布式锁怎么实现的" aria-hidden="true">#</a> 11、ZooKeeper 分布式锁怎么实现的？</h2><p>如果有客户端 1、客户端 2 等 N 个客户端争抢一个Zookeeper分布式锁。大致如下：</p><ol><li><p>大家都是上来直接创建一个锁节点下的一个接一个的临时有序节点</p></li><li><p>如果自己不是第一个节点，就对自己上一个节点加监听器</p></li><li><p>只要上一个节点释放锁，自己就排到前面去了，相当于是一个排队机制。</p></li></ol><p>而且用临时顺序节点的另外一个用意就是，如果某个客户端创建临时顺序节点之后，不小心自己宕机了也没关系, Zookeeper感知到那个客户端宕机，会自动删除对应的临时顺序节点，相当于自动释放锁，或者是自动取消自己的排队。</p><p>本地锁，可以用 JDK 实现，但是分布式锁就必须要用到分布式的组件。比如 ZooKeeper、Redis。网上代码一大段，面试一般也不要写，我这说一些关键点。</p><p>几个需要注意的地方如下。</p><ul><li>死锁问题：锁不能因为意外就变成死锁，所以要用 ZK 的临时节点，客户端连接失效了，锁就自动释放了。</li><li>锁等待问题：锁有排队的需求，所以要 ZK 的顺序节点。</li><li>锁管理问题：一个使用使用释放了锁，需要通知其他使用者，所以需要用到监听。</li><li>监听的羊群效应：比如有 1000 个锁竞争者，锁释放了，1000 个竞争者就得到了通知，然后判断，最终序号最小的那个拿到了锁。其它 999 个竞争者重新注册监听。这就是羊群效应，出点事，就会惊动整个羊群。应该每个竞争者只监听自己前面的那个节点。比如 2 号释放了锁，那么只有 3 号得到了通知。</li></ul><h2 id="_12、了解zookeeper的系统架构吗" tabindex="-1"><a class="header-anchor" href="#_12、了解zookeeper的系统架构吗" aria-hidden="true">#</a> 12、了解Zookeeper的系统架构吗？</h2><p>ZooKeeper 的架构图中我们需要了解和掌握的主要有：</p><ol><li>ZooKeeper 分为服务器端（Server） 和客户端（Client），客户端可以连接到整个ZooKeeper 服务的任意服务器上（除非 leaderServes 参数被显式设置, leader 不允许接受客户端连接）。</li><li>客户端使用并维护一个 TCP 连接，通过这个连接发送请求、接受响应、获取观察的事件以及发送心跳。如果这个 TCP 连接中断，客户端将自动尝试连接到另外的 ZooKeeper 服务器。客户端第一次连接到 ZooKeeper 服务时，接受这个连接的 ZooKeeper 服务器会为这个客户端建立一个会话。当这个客户端连接到另外的服务器时，这个会话会被新的服务器重新建立。</li><li>上图中每一个 Server 代表一个安装 Zookeeper 服务的机器，即是整个提供 Zookeeper 服务的集群(或者是由伪集群组成)</li><li>组成 ZooKeeper 服务的服务器必须彼此了解。它们维护一个内存中的状态图像，以及持久存储中的事务日志和快照, 只要大多数服务器可用，ZooKeeper 服务就可用</li><li>ZooKeeper 启动时，将从实例中选举一个 leader，Leader 负责处理数据更新等操作，一个更新操作成功的标志是当且仅当大多数 Server 在内存中成功修改数据。每个 Server 在内存中存储了一份数据。</li><li>Zookeeper 是可以集群复制的，集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性；</li><li>Zab 协议包含两个阶段：leader election 阶段和 Atomic Broadcast 阶段。 <ul><li>集群中将选举出一个 leader，其他的机器则称为 follower，所有的写操作都被传送给 leader，并通过 broadcast 将所有的更新告诉给 follower。</li><li>当 leader 崩溃或者 leader 失去大多数的 follower 时，需要重新选举出一个新的 leader，让所有的服务器都恢复到一个正确的状态。</li><li>当 leader 被选举出来，且大多数服务器完成了和 leader 的状态同步后，leadder election 的过程就结束了，就将会进入到 Atomic broadcast 的过程。</li><li>Atomic Broadcast 同步 leader 和 follower 之间的信息，保证 leader 和 follower 具有形同的系统状态。</li></ul></li></ol><h2 id="_13、zookeeper为什么要这么设计" tabindex="-1"><a class="header-anchor" href="#_13、zookeeper为什么要这么设计" aria-hidden="true">#</a> 13、Zookeeper为什么要这么设计？</h2><p>ZooKeeper 设计的目的是提供高性能、高可用、顺序一致性的分布式协调服务、保证数据最终一致性。 高性能（简单的数据模型）</p><ol><li><p>采用树形结构组织数据节点；</p></li><li><p>全量数据节点，都存储在内存中；</p></li><li><p>Follower 和 Observer 直接处理非事务请求； 高可用（构建集群）</p></li><li><p>半数以上机器存活，服务就能正常运行</p></li><li><p>自动进行 Leader 选举 顺序一致性（事务操作的顺序）</p></li><li><p>每个事务请求，都会转发给 Leader 处理</p></li><li><p>每个事务，会分配全局唯一的递增 id（zxid，64 位：epoch + 自增 id） 最终一致性</p></li><li><p>通过提议投票方式，保证事务提交的可靠性</p></li><li><p>提议投票方式，只能保证 Client 收到事务提交成功后，半数以上节点能够看到最新数据</p></li></ol><h2 id="_14、你知道zookeeper中有哪些角色" tabindex="-1"><a class="header-anchor" href="#_14、你知道zookeeper中有哪些角色" aria-hidden="true">#</a> 14、你知道Zookeeper中有哪些角色？</h2><p>系统模型：</p><p>// TODO image</p><ul><li><strong>领导者(leader)</strong> Leader 服务器为客户端提供读服务和写服务 。 负责进行投票的发起和决议 , 更新系统状态 。</li><li><strong>学习者(learner)</strong></li><li><strong>跟随者(follower)</strong> Follower 服务器为客户端提供读服务，参与 Leader 选举过程，参与写操 作“过半写成功”策略。</li><li><strong>观察者(observer)</strong> Observer 服务器为客户端提供读服务，不参与 Leader 选举过程，不参与 写操作“过半写成功”策略。用于在不影响写性能的前提下提升集群的读性能。</li><li><strong>客户端(client)</strong> ：服务请求发起方。</li></ul><h2 id="_15、你熟悉zookeeper节点znode和相关属性吗" tabindex="-1"><a class="header-anchor" href="#_15、你熟悉zookeeper节点znode和相关属性吗" aria-hidden="true">#</a> 15、你熟悉Zookeeper节点ZNode和相关属性吗？</h2><ul><li><p>节点</p><ul><li><p>Znode 两种类型 ：</p><ul><li>持久的（persistent）：客户端和服务器端断开连接后，创建的节点不删除（默认）。</li><li>短暂的（ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除。</li></ul></li><li><p>Znode 有四种形式 ：</p><ol><li>持久化目录节点（PERSISTENT）：客户端与 Zookeeper 断开连接后，该节点依旧存在持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）</li><li>客户端与 Zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号：临时目录节点（EPHEMERAL）</li><li>客户端与 Zookeeper 断开连接后，该节点被删除：临时顺序编号目录节点(EPHEMERAL_SEQUENTIAL)</li><li>客户端与 Zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号</li></ol></li></ul><p><strong>「注意」</strong>：创建 ZNode 时设置顺序标识，ZNode 名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。</p></li><li><p>节点属性</p><p>一个 znode 节点不仅可以存储数据，还有一些其他特别的属性。接下来我们创建一个/test 节点分析一下它各个属性的含义。</p></li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>  [zk: localhost:2181(CONNECTED) 6] get /test 456
  cZxid = 0x59ac //
  ctime = Mon Mar 30 15:20:08 CST 2020 mZxid = 0x59ad
  mtime = Mon Mar 30 15:22:25 CST 2020 pZxid = 0x59ac
  cversion = 0
  dataVersion = 2
  aclVersion = 0 ephemeralOwner = 0x0 dataLength = 3
  numChildren = 0
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>属性说明</p><table><thead><tr><th>节点属性</th><th>注解</th></tr></thead><tbody><tr><td>cZxid</td><td>该数据节点被创建时的事物 id</td></tr><tr><td>mZxid</td><td>该数据节点被修改时的最新事务 id</td></tr><tr><td>pZxid</td><td>当前节点的父级节点事物 id</td></tr><tr><td>ctime</td><td>该数据节点创建时间</td></tr><tr><td>mtime</td><td>该数据节点最后修改时间</td></tr><tr><td>dataVersion</td><td>当前节点版本号 (每修改一次值 +1 递增)</td></tr><tr><td>cversion</td><td>子节点版本号 (子节点修改次数，每修改一次值 +1 递增)</td></tr><tr><td>aclVersion</td><td>当前节点 acl 版本号 (节点被修改 acl 权限，每修改一次值 +1 递增)</td></tr><tr><td>ephemeralOwner</td><td>临时节点表示，当前节点如果时临时节点，则存储的创建者的会话 id (sessionId)，如果不是，值为0</td></tr><tr><td>dataLength</td><td>当前节点所存储的数据长度</td></tr><tr><td>numChildren</td><td>当前节点下子节点的个数</td></tr></tbody></table><h2 id="_16、请简述zookeeper的选主流程" tabindex="-1"><a class="header-anchor" href="#_16、请简述zookeeper的选主流程" aria-hidden="true">#</a> 16、请简述Zookeeper的选主流程</h2><p>Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。leader 选举是保证分布式数据一致性的关键。</p><p>出现选举主要是两种场景：初始化、leader 不可用。</p><p>当 zk 集群中的一台服务器出现以下两种情况之一时，就会开始 leader 选举。</p><ol><li>服务器初始化启动。</li><li>服务器运行期间无法和 leader 保持连接。</li></ol><p>而当一台机器进入 leader 选举流程时，当前集群也可能处于以下两种状态。</p><ol><li>集群中本来就已经存在一个 leader。</li><li>集群中确实不存在 leader。</li></ol><p>首先第一种情况，通常是集群中某一台机器启动比较晚，在它启动之前，集群已经正常工作，即已经存在一台 leader 服务器。当该机器试图去选举 leader 时，会被告知当前服务器的 leader 信息，它仅仅需要和 leader 机器建立连接，并进行状态同步即可。</p><p>重点是 leader 不可用了，此时的选主制度。</p><p>投票信息中包含两个最基本的信息。</p><ul><li>sid ：即 server id，用来标识该机器在集群中的机器序号。</li><li>zxid ：即 zookeeper 事务 id 号。</li></ul><p>ZooKeeper 状态的每一次改变, 都对应着一个递增的 Transaction id,，该 id 称为 zxid.，由于 zxid 的递增性质, 如果 zxid1 小于 zxid2,，那么 zxid1 肯定先于 zxid2 发生。创建任意节点，或者更新任意节点的数据, 或者删除任意节点，都会导致 Zookeeper 状态发生改变，从而导致 zxid 的值增加。</p><p>以（sid，zxid）的形式来标识一次投票信息。</p><p>例如：如果当前服务器要推举 sid 为 1，zxid 为 8 的服务器成为 leader，那么投票信息可以表示为 (1, 8)</p><p>集群中的每台机器发出自己的投票后，也会接受来自集群中其他机器的投票。每台机器都会根据一定的规则，来处理收到的其他机器的投票，以此来决定是否需要变更自己的投票。</p><p>规则如下 ：</p><ol><li>初始阶段，都会给自己投票。</li><li>当接收到来自其他服务器的投票时，都需要将别人的投票和自己的投票进行 pk，规则如下： 优先检查 zxid。zxid 比较大的服务器优先作为 leader。如果 zxid 相同的话，就比较 sid，sid 比较大的服务器作为 leader。</li></ol><p>所有服务启动时候的选举流程：</p><p>三台服务器 server1、server2、server3：</p><ol><li><p>server1 启动，一台机器不会选举。</p></li><li><p>server2 启动，server1 和 server2 的状态改为 looking，广播投票</p></li><li><p>server3 启动，状态改为 looking，加入广播投票。</p></li><li><p>初识状态，互不认识，大家都认为自己是王者，投票也投自己为 Leader。</p></li><li><p>投票信息说明，票信息本来为五元组，这里为了逻辑清晰，简化下表达。 初识 zxid = 0，sid 是每个节点的名字，这个 sid 在 zoo.cfg 中配置，不会重复。</p><table><thead><tr><th>节点</th><th>sid</th></tr></thead><tbody><tr><td>server1</td><td>1</td></tr><tr><td>server2</td><td>2</td></tr><tr><td>server3</td><td>3</td></tr></tbody></table></li><li><p>初始 zxid=0，server1 投票（1，0），server2 投票（2，0），server3 投票（3，0）</p></li><li><p>server1 收到投票（2，0）时，会先验证投票的合法性，然后自己的票进行 pk，pk 的逻辑是先比较 zxid，server1（zxid）=server2（zxid）=0，zxid 相等再比较 sid，server1（sid）&lt; server2(sid)，pk 结果为 server2 的投票获胜。server1 更新自己的投票为 （2，0），server1 重新投票。</p></li><li><p>TODO 这里最终是 2 还是 3，需要做实验确定。</p></li><li><p>server2 收到 server1 投票，会先验证投票的合法性，然后 pk，自己的票获胜，server 不用更新自己的票，pk 后，重新在发送一次投票。</p></li><li><p>统计投票，pk 后会统计投票，如果半数以上的节点投出相同的票，确定选出了 Leader。</p></li><li><p>选举结束，被选中节点的状态由 LOOKING 变成 LEADING，其他参加选举的节点由 LOOKING 变成 FOLLOWING。如果有 Observer 节点，如果 Observer 不参与选举，所以选举前后它的状态一直是 OBSERVING，没有变化。 简单地说 开始投票 -&gt; 节点状态变成 LOOKING -&gt; 每个节点选自己-&gt; 收到票进行 PK -&gt; sid 大的获胜 -&gt; 更新选票 -&gt; 再次投票 -&gt; 统计选票，选票过半数选举结果 -&gt; 节点状态更新为自己的角色状态。</p></li></ol><h2 id="_17、为什么zookeeper集群的数目-一般为奇数个" tabindex="-1"><a class="header-anchor" href="#_17、为什么zookeeper集群的数目-一般为奇数个" aria-hidden="true">#</a> 17、为什么Zookeeper集群的数目，一般为奇数个？</h2><p>首先需要明确 zookeeper 选举的规则 ：leader 选举 , 要求<strong>可用节点数量 &gt; 总节点数量/2</strong> 。</p><p>比如：标记一个写是否成功是要在超过一半节点发送写请求成功时才认为有效。同样，Zookeeper 选择领导者节点也是在超过一半节点同意时才有效。最后，Zookeeper 是否正常是要根据是否超过一半的节点正常才算正常。这是基于 CAP 的一致性原理。</p><p>zookeeper有这样一个特性：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的。</p><p>也就是说如果有 2 个 zookeeper，那么只要有 1 个死了 zookeeper 就不能用了，因为 1 没有过半，所以 2 个 zookeeper 的死亡容忍度为 0；</p><p>同理，要是有 3 个 zookeeper，一个死了，还剩下 2 个正常的，过半了，所以 3 个 zookeeper 的容忍度为 1；</p><p>同理：</p><ul><li>2-&gt;0；两个 zookeeper，最多 0 个 zookeeper 可以不可用。</li><li>3-&gt;1；三个 zookeeper，最多 1 个 zookeeper 可以不可用。</li><li>4-&gt;1；四个 zookeeper，最多 1 个 zookeeper 可以不可用。</li><li>5-&gt;2；五个 zookeeper，最多 2 个 zookeeper 可以不可用。</li><li>6-&gt;2；两个 zookeeper，最多 0 个 zookeeper 可以不可用。 ....</li></ul><p>会发现一个规律，2n 和 2n-1 的容忍度是一样的，都是 n-1，所以为了更加高效，何必增加那一个不必要的 zookeeper 呢。 zookeeper 的选举策略也是需要半数以上的节点同意才能当选 leader，如果是偶数节点可能导致票数相同的情况。</p><h2 id="_18、知道zookeeper监听器的原理吗" tabindex="-1"><a class="header-anchor" href="#_18、知道zookeeper监听器的原理吗" aria-hidden="true">#</a> 18、知道Zookeeper监听器的原理吗？</h2><ol><li>创建一个 Main()线程。</li><li>在 Main()线程中创建两个线程，一个负责网络连接通信（connect），一个负责监听 （listener）。</li><li>通过 connect 线程将注册的监听事件发送给 Zookeeper。</li><li>将注册的监听事件添加到 Zookeeper 的注册监听器列表中。</li><li>Zookeeper 监听到有数据或路径发生变化时，把这条消息发送给 Listener 线程。</li><li>Listener 线程内部调用 process()方法</li></ol><h2 id="_19、说说zookeeper中的acl-权限控制机制" tabindex="-1"><a class="header-anchor" href="#_19、说说zookeeper中的acl-权限控制机制" aria-hidden="true">#</a> 19、说说Zookeeper中的ACL 权限控制机制</h2><ul><li><p>UGO（User/Group/Others)</p><p>目前在 Linux/Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种粗粒度的文件系统权限控制模式。</p></li><li><p>ACL（Access Control List）访问控制列表包括三个方面：</p><ul><li><p>权限模式（Scheme）</p><ol><li>IP：从 IP 地址粒度进行权限控制</li><li>Digest：最常用，用类似于 username:password 的权限标识来进行权限配置，便于区分不同应用来进行权限控制</li><li>World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个权限标识“world:anyone”</li><li>Super：超级用户</li></ol></li><li><p>授权对象 授权对象指的是权限赋予的用户或一个指定实体，例如 IP 地址或是机器灯。</p></li><li><p>权限 Permission</p><ol><li>CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点</li><li>DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点</li><li>READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等</li><li>WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作</li><li>ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关设置操作</li></ol></li></ul></li></ul><h2 id="_20、zookeeper-有哪几种几种部署模式" tabindex="-1"><a class="header-anchor" href="#_20、zookeeper-有哪几种几种部署模式" aria-hidden="true">#</a> 20、Zookeeper 有哪几种几种部署模式？</h2><p>Zookeeper 有三种部署模式：</p><ol><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群运行；</li><li>伪集群部署：一台集群启动多个 Zookeeper 实例运行。</li></ol><h2 id="_21、zookeeper集群支持动态添加机器吗" tabindex="-1"><a class="header-anchor" href="#_21、zookeeper集群支持动态添加机器吗" aria-hidden="true">#</a> 21、Zookeeper集群支持动态添加机器吗？</h2><p>其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：</p><ul><li>全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的会话。</li><li>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。 3.5 版本开始支持动态扩容。</li></ul><h2 id="_22、描述一下-zab-协议" tabindex="-1"><a class="header-anchor" href="#_22、描述一下-zab-协议" aria-hidden="true">#</a> 22、描述一下 ZAB 协议</h2><p>ZAB 协议是 ZooKeeper 自己定义的协议，全名 ZooKeeper 原子广播协议。</p><p>ZAB 协议有两种模式：Leader 节点崩溃了如何恢复和消息如何广播到所有节点。</p><p>整个 ZooKeeper 集群没有 Leader 节点的时候，属于崩溃的情况。比如集群启动刚刚启动，这时节点们互相不认识。比如运作 Leader 节点宕机了，又或者网络问题，其他节点 Ping 不通 Leader 节点了。这时就需要 ZAB 中的节点崩溃协议，所有节点进入选举模式，选举出新的 Leader。整个选举过程就是通过广播来实现的。选举成功后，一切都需要以 Leader 的数据为准，那么就需要进行数据同步了。</p><h2 id="_23、zab-和-paxos-算法的联系与区别" tabindex="-1"><a class="header-anchor" href="#_23、zab-和-paxos-算法的联系与区别" aria-hidden="true">#</a> 23、ZAB 和 Paxos 算法的联系与区别？</h2><ul><li><p>相同点：</p><ol><li>两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行</li><li>Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交</li><li>ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader 周期，Paxos 中名字为 Ballot</li></ol></li><li><p>不同点：</p><p>ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建分布式一致性状态机系统。</p></li></ul><h2 id="_24、zookeeper-宕机如何处理" tabindex="-1"><a class="header-anchor" href="#_24、zookeeper-宕机如何处理" aria-hidden="true">#</a> 24、ZooKeeper 宕机如何处理？</h2><p>ZooKeeper 本身也是集群，推荐配置奇数个服务器。因为宕机就需要选举，选举需要半数 +1 票才能通过，为了避免打成平手。进来不用偶数个服务器。</p><p>如果是 Follower 宕机了，没关系不影响任何使用。用户无感知。如果 Leader 宕机，集群就得停止对外服务，开始选举，选举出一个 Leader 节点后，进行数据同步，保证所有节点数据和 Leader 统一，然后开始对外提供服务。 为啥投票需要半数 +1，如果半数就可以的话，网络的问题可能导致集群选举出来两个 Leader，各有一半的小弟支持，这样数据也就乱套了。</p><h2 id="_25、-描述一下-zookeeper-的-session-管理的思想" tabindex="-1"><a class="header-anchor" href="#_25、-描述一下-zookeeper-的-session-管理的思想" aria-hidden="true">#</a> 25、 描述一下 ZooKeeper 的 session 管理的思想？</h2><ul><li>分桶策略：</li></ul><p>简单地说，就是不同的会话过期可能都有时间间隔，比如 15 秒过期、15.1 秒过期、15.8 秒过期, ZooKeeper 统一让这些 session 16 秒过期。这样非常方便管理，看下面的公式，过期时间总是 ExpirationInterval 的整数倍。</p><ul><li><p>计算公式：</p><blockquote><p>ExpirationTime = currentTime + sessionTimeout</p><p>ExpirationTime = (ExpirationTime / ExpirationInrerval + 1) * ExpirationInterval</p></blockquote></li></ul><p>见图片：</p><p>默认配置的 session 超时时间是在 2<em>tickTime~20</em>tickTime。</p><h2 id="_26、zookeeper-负载均衡和-nginx-负载均衡有什么区别" tabindex="-1"><a class="header-anchor" href="#_26、zookeeper-负载均衡和-nginx-负载均衡有什么区别" aria-hidden="true">#</a> 26、ZooKeeper 负载均衡和 Nginx 负载均衡有什么区别？</h2><ul><li><p><strong>ZooKeeper</strong> ：</p><ol><li>不存在单点问题，zab 机制保证单点故障可重新选举一个 Leader</li><li>只负责服务的注册与发现，不负责转发，减少一次数据交换（消费方与服务方直接通信）</li><li>需要自己实现相应的负载均衡算法</li></ol></li><li><p><strong>Nginx</strong> ：</p><ol><li>存在单点问题，单点负载高数据量大，需要通过 KeepAlived 辅助实现高可用</li><li>每次负载，都充当一次中间人转发角色，本身是个反向代理服务器</li><li>自带负载均衡算法</li></ol></li></ul><h2 id="_27、说说zookeeper-的序列化" tabindex="-1"><a class="header-anchor" href="#_27、说说zookeeper-的序列化" aria-hidden="true">#</a> 27、说说ZooKeeper 的序列化</h2><p><strong>序列化</strong> ：</p><ol><li>内存数据，保存到硬盘需要序列化。</li><li>内存数据，通过网络传输到其他节点，需要序列化。</li></ol><p>ZK 使用的序列化协议是 Jute，Jute 提供了 Record 接口。接口提供了两个方法：</p><ol><li>serialize 序列化方法</li><li>deserialize 反序列化方法</li></ol><p>要系列化的方法，在这两个方法中存入到流对象中即可。</p><h2 id="_28-在zookeeper-中-zxid-是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#_28-在zookeeper-中-zxid-是什么-有什么作用" aria-hidden="true">#</a> 28，在Zookeeper 中 Zxid 是什么，有什么作用？</h2><ul><li><p><strong>Zxid</strong></p><p>也就是事务 id，为了保证事务的顺序一致性，ZooKeeper 采用了递增的事务 Zxid 来标识事务。proposal 都会加上了 Zxid。Zxid 是一个 64 位的数字，它高 32 位是 Epoch 用来标识朝代变化，比如每次选举 Epoch 都会加改变。低 32 位用于递增计数。</p></li><li><p><strong>Epoch</strong> ：</p><p>可以理解为当前集群所处的年代或者周期，每个 Leader 就像皇帝，都有自己的年号，所以每次改朝换代，Leader 变更之后，都会在前一个年代的基础上加 1。这样就算旧的 Leader 崩溃恢复之后，也没有人听它的了，因为 Follower 只听从当前年代的 Leader 的命令。</p></li></ul><h2 id="_29、讲解一下-zookeeper-的持久化机制" tabindex="-1"><a class="header-anchor" href="#_29、讲解一下-zookeeper-的持久化机制" aria-hidden="true">#</a> 29、讲解一下 ZooKeeper 的持久化机制</h2><ul><li><p>什么是持久化？</p><ol><li>数据，存到磁盘或者文件当中。</li><li>机器重启后，数据不会丢失。内存 -&gt; 磁盘的映射，和序列化有些像。</li></ol></li><li><p>ZooKeeper 的持久化：</p><ul><li>SnapShot 快照，记录内存中的全量数据</li><li>TxnLog 增量事务日志，记录每一条增删改记录（查不是事务日志，不会引起数据变化）</li></ul></li><li><p>为什么持久化这么麻烦，一个不可用吗？</p><p>快照的缺点，文件太大，而且快照文件不会是最新的数据。增量事务日志的缺点，运行时间长了，日志太多了，加载太慢。二者结合最好。</p><p>快照模式</p><ul><li>将 ZooKeeper 内存中以 DataTree 数据结构存储的数据定期存储到磁盘中。</li><li>由于快照文件是定期对数据的全量备份，所以快照文件中数据通常不是最新的。</li></ul><p>见图片：</p></li></ul><h2 id="_30、zookeeper选举中投票信息的五元组是什么" tabindex="-1"><a class="header-anchor" href="#_30、zookeeper选举中投票信息的五元组是什么" aria-hidden="true">#</a> 30、Zookeeper选举中投票信息的五元组是什么？</h2><ul><li>Leader：被选举的 Leader 的 SID</li><li>Zxid：被选举的 Leader 的事务 ID</li><li>Sid：当前服务器的 SID</li><li>electionEpoch：当前投票的轮次</li><li>peerEpoch：当前服务器的 Epoch</li></ul><p><strong>Epoch &gt;Zxid &gt; Sid</strong></p><p>Epoch，Zxid 都可能一致，但是 Sid 一定不一样，这样两张选票一定会 PK 出结果。</p><h2 id="_31、说说zookeeper中的脑裂" tabindex="-1"><a class="header-anchor" href="#_31、说说zookeeper中的脑裂" aria-hidden="true">#</a> 31、说说Zookeeper中的脑裂？</h2><p>简单点来说，脑裂(Split-Brain) 就是比如当你的 cluster 里面有两个节点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两个之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master，于是 cluster 里面就会有两个 master。</p><p>对于 Zookeeper 来说有一个很重要的问题，就是到底是根据一个什么样的情况来判断一个节点死亡 down 掉了？在分布式系统中这些都是有监控者来判断的，但是监控者也很难判定其他的节点的状态，唯一一个可靠的途径就是心跳，Zookeeper 也是使用心跳来判断客户端是否仍然活着。</p><p>使用 ZooKeeper 来做 Leader HA 基本都是同样的方式：每个节点都尝试注册一个象征 leader 的临时节点，其他没有注册成功的则成为 follower，并且通过 watch 机制监控着 leader 所创建的临时节点， Zookeeper 通过内部心跳机制来确定 leader 的状态，一旦 leader 出现意外 Zookeeper 能很快获悉并且通知其他的 follower，其他 ﬂower 在之后作出相关反应，这样就完成了一个切换，这种模式也是比较通用的模式，基本大部分都是这样实现的。但是这里面有个很严重的问题，如果注意不到会导致短暂的时间内系统出现脑裂，因为心跳出现超时可能是 leader 挂了，但是也可能是 zookeeper 节点之间网络出现了问题，导致 leader 假死的情况，leader 其实并未死掉，但是与 ZooKeeper 之间的网络出现问题导致 Zookeeper 认为其挂掉了然后通知其他节点进行切换，这样 follower 中就有一个成为了 leader，但是原本的 leader 并未死掉，这时候 client 也获得 leader 切换的消息，但是仍然会有一些延时，zookeeper 需要通讯需要一个一个通知，这时候整个系统就很混乱可能有一部分 client 已经通知到了连接到新的 leader 上去了，有的 client 仍然连接在老的 leader 上，如果同时有两个 client 需要对 leader 的同一个数据更新，并且刚好这两个 client 此刻分别连接在新老的 leader 上，就会出现很严重问题。</p><p>这里做下小总结：</p><ul><li><strong>假死</strong>：由于心跳超时（网络原因导致的）认为 leader 死了，但其实 leader 还存活着。</li><li><strong>脑裂</strong>：由于假死会发起新的 leader 选举，选举出一个新的 leader，但旧的 leader 网络又通了，导致出现了两个 leader ，有的客户端连接到老的 leader，而有的客户端则连接到新的 leader。</li></ul><h2 id="_32、zookeeper脑裂是什么原因导致的" tabindex="-1"><a class="header-anchor" href="#_32、zookeeper脑裂是什么原因导致的" aria-hidden="true">#</a> 32、Zookeeper脑裂是什么原因导致的？</h2><p>主要原因是 Zookeeper 集群和 Zookeeper client 判断超时并不能做到完全同步，也就是说可能一前一后，如果是集群先于 client 发现，那就会出现上面的情况。同时，在发现并切换后通知各个客户端也有先后快慢。一般出现这种情况的几率很小，需要 leader 节点与 Zookeeper 集群网络断开，但是与其他集群角色之间的网络没有问题，还要满足上面那些情况，但是一旦出现就会引起很严重的后果，数据不一致。</p><h2 id="_33、zookeeper-是如何解决脑裂问题的" tabindex="-1"><a class="header-anchor" href="#_33、zookeeper-是如何解决脑裂问题的" aria-hidden="true">#</a> 33、Zookeeper 是如何解决脑裂问题的？</h2><p>要解决 Split-Brain 脑裂的问题，一般有下面几种种方法： Quorums (法定人数) 方式: 比如 3 个节点的集群，Quorums = 2, 也就是说集群可以容忍 1 个节点失效，这时候还能选举出 1 个 lead，集群还可用。比如 4 个节点的集群，它的 Quorums = 3，Quorums 要超过 3，相当于集群的容忍度还是 1，如果 2 个节点失效，那么整个集群还是无效的。这是 zookeeper 防止&quot;脑裂&quot;默认采用的方法。</p><p>采用 Redundant communications (冗余通信)方式：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信。</p><p>Fencing (共享资源) 方式：比如能看到共享资源就表示在集群中，能够获得共享资源的锁的就是 Leader，看不到共享资源的，就不在集群中。</p><p>要想避免 zookeeper&quot;脑裂&quot;情况其实也很简单，在 follower 节点切换的时候不在检查到老的 leader 节点出现问题后马上切换，而是在休眠一段足够的时间，确保老的 leader 已经获知变更并且做了相关的 shutdown 清理工作了然后再注册成为 master 就能避免这类问题了，这个休眠时间一般定义为与 zookeeper 定义的超时时间就够了，但是这段时间内系统可能是不可用的，但是相对于数据不一致的后果来说还是值得的。</p><p>zooKeeper 默认采用了 Quorums 这种方式来防止&quot;脑裂&quot;现象。即只有集群中超过半数节点投票才能选举出 Leader。这样的方式可以确保 leader 的唯一性,要么选出唯一的一个 leader,要么选举失败。</p><p>在 zookeeper 中 Quorums 作用如下：</p><ul><li>集群中最少的节点数用来选举 leader 保证集群可用。</li><li>通知客户端数据已经安全保存前集群中最少数量的节点数已经保存了该数据。一旦这些节点保存了该数据，客户端将被通知已经安全保存了，可以继续其他任务。而集群中剩余的节点将会最终也保存了该数据。</li></ul><p>假设某个 leader 假死，其余的 followers 选举出了一个新的 leader。这时，旧的 leader 复活并且仍然认为自己是 leader，这个时候它向其他 followers 发出写请求也是会被拒绝的。因为每当新 leader 产生时，会生成一个 epoch 标号(标识当前属于那个 leader 的统治时期)，这个 epoch 是递增的， followers 如果确认了新的 leader 存在，知道其 epoch，就会拒绝 epoch 小于现任 leader epoch 的所有请求。那有没有 follower 不知道新的 leader 存在呢，有可能，但肯定不是大多数，否则新 leader 无法产生。Zookeeper 的写也遵循 quorum 机制，因此，得不到大多数支持的写是无效的，旧 leader 即使各种认为自己是 leader，依然没有什么作用。 zookeeper 除了可以采用上面默认的 Quorums 方式来避免出现&quot;脑裂&quot;，还可以可采用下面的预防措施：</p><ol><li>添加冗余的心跳线，例如双线条线，尽量减少“裂脑”发生机会。</li><li>启用磁盘锁。正在服务一方锁住共享磁盘，&quot;裂脑&quot;发生时，让对方完全&quot;抢不走&quot;共享磁盘资源。但使用锁磁盘也会有一个不小的问题，如果占用共享盘的一方不主动&quot;解锁&quot;，另一方就永远得不到共享磁盘。现实中假如服务节点突然死机或崩溃，就不可能执行解锁命令。后备节点也就接管不了共享资源和应用服务。于是有人在 HA 中设计了&quot;智能&quot;锁。即正在服务的一方只在发现心跳线全部断开（察觉不到对端）时才启用磁盘锁。平时就不上锁了。</li><li>设置仲裁机制。例如设置参考 IP（如网关 IP），当心跳线完全断开时，2 个节点都各自 ping 一下参考 IP，不通则表明断点就出在本端，不仅&quot;心跳&quot;、还兼对外&quot;服务&quot;的本端网络链路断了，即使启动（或继续）应用服务也没有用了，那就主动放弃竞争，让能够 ping 通参考 IP 的一端去起服务。更保险一些，ping 不通参考 IP 的一方干脆就自我重启，以彻底释放有可能还占用着的那些共享资源。</li></ol><h2 id="_34、说说-zookeeper-的-cap-问题上做的取舍" tabindex="-1"><a class="header-anchor" href="#_34、说说-zookeeper-的-cap-问题上做的取舍" aria-hidden="true">#</a> 34、说说 Zookeeper 的 CAP 问题上做的取舍？</h2><ul><li><p><strong>一致性 C</strong> ：Zookeeper 是强一致性系统，为了保证较强的可用性，“一半以上成功即成功”的数据同步方式可能会导致部分节点的数据不一致。所以 Zookeeper 还提供了 sync() 操作来做所有节点的数据同步，这就关于 C 和 A 的选择问题交给了用户，因为使用 sync()势必会延长同步时间，可用性会有一些损失。</p></li><li><p><strong>可用性 A</strong> ：Zookeeper 数据存储在内存中，且各个节点都可以相应读请求，具有好的响应性能。 Zookeeper 保证了数据总是可用的，没有锁。并且有一大半的节点所拥有的数据是最新的。</p></li><li><p><strong>分区容忍性 P</strong> ：Follower 节点过多会导致增大数据同步的延时（需要半数以上 follower 写完提 交）。同时选举过程的收敛速度会变慢，可用性降低。Zookeeper 通过引入 observer 节点缓解了这个问题，增加 observer 节点后集群可接受 client 请求的节点多了，而且 observer 不参与投票，可以提高可用性和扩展性，但是节点多数据同步总归是个问题，所以一致性会有所降低。</p></li></ul><h2 id="_35、watch-监听为什么是一次性的" tabindex="-1"><a class="header-anchor" href="#_35、watch-监听为什么是一次性的" aria-hidden="true">#</a> 35、watch 监听为什么是一次性的？</h2><p>如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。</p><p>一般是客户端执行getData(节点 A,true) ，如果节点 A 发生了变更或删除，客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没有设置 watch 事件，就不再给客户端发送。</p><p>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。</p><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/imdtf/blog/edit/main/docs/interview/zookeeper.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" aria-labelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/6/8 23:47:48</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: imdtf@qq.com">DTF</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/interview/linux.html" class="nav-link prev" aria-label="Linux 篇"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->Linux 篇</div></a><a href="/interview/Redis.html" class="nav-link next" aria-label="Redis 篇"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">Redis 篇<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2022 DTF</div></footer><!--]--></div><!--]--><!----><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewbox="0 0 1024 1024" aria-labelledby="close"><title id="close" lang="en">close icon</title><g fill="currentColor"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></g></svg></button><div class="logo"><!----><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!----><!----></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button class="install-button">安装<span></span></button><button class="cancel-button">取消</button></div></div></div></div><!--]--></div>
    <script type="module" src="/assets/app.597ce2f2.js" defer></script>
  </body>
</html>
