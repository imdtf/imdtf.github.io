<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.43" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-v2-demo.mrhope.site/language/java/on-java-8/03-Objects-Everywhere.html"><meta property="og:site_name" content="DTF's blog"><meta property="og:title" content="第三章 万物皆对象"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-05-07T12:20:31.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:modified_time" content="2022-05-07T12:20:31.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>第三章 万物皆对象 | DTF's blog</title><meta name="description" content="我的学习记录博客">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.af58f80f.css">
    <link rel="modulepreload" href="/assets/app.597ce2f2.js"><link rel="modulepreload" href="/assets/03-Objects-Everywhere.html.4da53003.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/03-Objects-Everywhere.html.bea55af9.js"><link rel="prefetch" href="/assets/index.html.e173ef83.js"><link rel="prefetch" href="/assets/ElasticSearch.html.279e5d7b.js"><link rel="prefetch" href="/assets/MQ.html.9d040945.js"><link rel="prefetch" href="/assets/MySQL.html.d1ae2d1e.js"><link rel="prefetch" href="/assets/Redis.html.b201ad05.js"><link rel="prefetch" href="/assets/design-patterns.html.733535fa.js"><link rel="prefetch" href="/assets/dubbo.html.c776d990.js"><link rel="prefetch" href="/assets/git.html.72b47aa0.js"><link rel="prefetch" href="/assets/java-base.html.db5311da.js"><link rel="prefetch" href="/assets/jvm.html.53d34a5d.js"><link rel="prefetch" href="/assets/linux.html.65017b81.js"><link rel="prefetch" href="/assets/maven.html.ceec6571.js"><link rel="prefetch" href="/assets/multi-thread.html.3652cc7f.js"><link rel="prefetch" href="/assets/mybatis.html.cb44fe5a.js"><link rel="prefetch" href="/assets/network.html.b1609fd9.js"><link rel="prefetch" href="/assets/nginx.html.9ca67d3a.js"><link rel="prefetch" href="/assets/soft-power.html.508fb44f.js"><link rel="prefetch" href="/assets/spring-boot.html.e888e4e7.js"><link rel="prefetch" href="/assets/spring-cloud.html.57c2b0d4.js"><link rel="prefetch" href="/assets/spring.html.94b261f5.js"><link rel="prefetch" href="/assets/tomcat.html.dc4aea03.js"><link rel="prefetch" href="/assets/zookeeper.html.75896320.js"><link rel="prefetch" href="/assets/分布式.html.6e369ff9.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.58f6dba8.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.04b85b76.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.116abb6a.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.1d83f138.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.40f6f1e4.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.900bda42.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.3492d336.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.dcc88998.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.7239f150.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.6199feb4.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.57624587.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.d99caa1b.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.cabd308f.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.c89015fe.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.6b8e9ff0.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.e1e4da4a.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.697b9a23.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.9000e742.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.4d12fb46.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.48d80708.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.da9eab5a.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.95150d1c.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.b9bda91b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.bb805e63.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.514eb232.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.4cfc99f3.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.1561ec1a.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.11ef8b3e.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.ef765715.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.50f4f1d6.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.60a1c908.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.b6c6ee60.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.0fa73bd5.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.bfe213be.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.e0558584.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.3087bc74.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.c5df5f6e.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.b9edc687.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.9906de00.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.4b8670c8.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.b78f67d4.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b762f081.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.e5ec66c1.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.f9b4c2c6.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.d4daa082.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.1f616fc4.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.25fe22f4.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.8bb53047.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.63f53d07.js"><link rel="prefetch" href="/assets/00-Introduction.html.aed5c856.js"><link rel="prefetch" href="/assets/00-Preface.html.feee9db3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.ab6ea8b6.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.0224a9bf.js"><link rel="prefetch" href="/assets/04-Operators.html.35525abf.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.c4cd86f5.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.b5c2b268.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.399ae58f.js"><link rel="prefetch" href="/assets/08-Reuse.html.0ab07e65.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.89443cf5.js"><link rel="prefetch" href="/assets/10-Interfaces.html.4948bb7b.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.b8f6a196.js"><link rel="prefetch" href="/assets/12-Collections.html.52f2a06b.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.db50a84d.js"><link rel="prefetch" href="/assets/14-Streams.html.9308751d.js"><link rel="prefetch" href="/assets/15-Exceptions.html.40e68d98.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.3edda5f0.js"><link rel="prefetch" href="/assets/17-Files.html.e87e7c99.js"><link rel="prefetch" href="/assets/18-Strings.html.a2842b17.js"><link rel="prefetch" href="/assets/19-Type-Information.html.12cc605b.js"><link rel="prefetch" href="/assets/20-Generics.html.3e4b17f6.js"><link rel="prefetch" href="/assets/21-Arrays.html.67720723.js"><link rel="prefetch" href="/assets/22-Enumerations.html.ab50f89b.js"><link rel="prefetch" href="/assets/23-Annotations.html.747faef3.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.5b9841aa.js"><link rel="prefetch" href="/assets/25-Patterns.html.10af6fe7.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.13f6de18.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.4774ac79.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.fec6d369.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.fe3a1870.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.35950f4f.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.54af4f5f.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.bb07240e.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.8f39ad15.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.39836314.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.ee52b83c.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.68302b50.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.9b5edd63.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.c8a5f6e1.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.34dcd815.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.8c0a6980.js"><link rel="prefetch" href="/assets/GLOSSARY.html.af317d6f.js"><link rel="prefetch" href="/assets/index.html.859506fe.js"><link rel="prefetch" href="/assets/404.html.61bcede7.js"><link rel="prefetch" href="/assets/index.html.6eefb2c9.js"><link rel="prefetch" href="/assets/index.html.276bb6b8.js"><link rel="prefetch" href="/assets/index.html.6c49b0c9.js"><link rel="prefetch" href="/assets/index.html.938faca6.js"><link rel="prefetch" href="/assets/index.html.234dfb8d.js"><link rel="prefetch" href="/assets/index.html.02cffa46.js"><link rel="prefetch" href="/assets/index.html.c70b19c7.js"><link rel="prefetch" href="/assets/index.html.e9ae5772.js"><link rel="prefetch" href="/assets/index.html.43ef8dd6.js"><link rel="prefetch" href="/assets/index.html.0319d1c3.js"><link rel="prefetch" href="/assets/ElasticSearch.html.1822d360.js"><link rel="prefetch" href="/assets/MQ.html.257a1eec.js"><link rel="prefetch" href="/assets/MySQL.html.12265bed.js"><link rel="prefetch" href="/assets/Redis.html.c5915ac6.js"><link rel="prefetch" href="/assets/design-patterns.html.4dff82bc.js"><link rel="prefetch" href="/assets/dubbo.html.70900b5c.js"><link rel="prefetch" href="/assets/git.html.9f0ce8a6.js"><link rel="prefetch" href="/assets/java-base.html.f9b49957.js"><link rel="prefetch" href="/assets/jvm.html.7b42d915.js"><link rel="prefetch" href="/assets/linux.html.9f1e7d55.js"><link rel="prefetch" href="/assets/maven.html.f848fc43.js"><link rel="prefetch" href="/assets/multi-thread.html.5d323dfe.js"><link rel="prefetch" href="/assets/mybatis.html.868f5463.js"><link rel="prefetch" href="/assets/network.html.347740e9.js"><link rel="prefetch" href="/assets/nginx.html.acf44958.js"><link rel="prefetch" href="/assets/soft-power.html.fa4cc2bb.js"><link rel="prefetch" href="/assets/spring-boot.html.eb446c44.js"><link rel="prefetch" href="/assets/spring-cloud.html.5a2e7953.js"><link rel="prefetch" href="/assets/spring.html.e5d334fa.js"><link rel="prefetch" href="/assets/tomcat.html.1edb1280.js"><link rel="prefetch" href="/assets/zookeeper.html.d47f6f3b.js"><link rel="prefetch" href="/assets/分布式.html.8362b544.js"><link rel="prefetch" href="/assets/java-basic-questions-01.html.e0b3e691.js"><link rel="prefetch" href="/assets/00 开篇词 这一次_ 让我们一起来搞懂MySQL.html.73dedd46.js"><link rel="prefetch" href="/assets/01 基础架构 一条SQL查询语句是如何执行的.html.a7a61510.js"><link rel="prefetch" href="/assets/02 日志系统 一条SQL更新语句是如何执行的.html.19af1cfc.js"><link rel="prefetch" href="/assets/03 事务隔离 为什么你改了我还看不见.html.078c9131.js"><link rel="prefetch" href="/assets/04 深入浅出索引（上）.html.3da35573.js"><link rel="prefetch" href="/assets/05 深入浅出索引（下）.html.ee1e2ba2.js"><link rel="prefetch" href="/assets/06 全局锁和表锁 给表加个字段怎么有这么多阻碍.html.5796a618.js"><link rel="prefetch" href="/assets/07 行锁功过 怎么减少行锁对性能的影响.html.26f3a028.js"><link rel="prefetch" href="/assets/08 事务到底是隔离的还是不隔离的.html.cbc4b5ad.js"><link rel="prefetch" href="/assets/09 普通索引和唯一索引_ 应该怎么选择.html.d79a5425.js"><link rel="prefetch" href="/assets/10 MySQL为什么有时候会选错索引.html.8dab2c77.js"><link rel="prefetch" href="/assets/11 怎么给字符串字段加索引.html.f8e03fcd.js"><link rel="prefetch" href="/assets/12 为什么我的MySQL会“抖”一下.html.f1c1f80f.js"><link rel="prefetch" href="/assets/13 为什么表数据删掉一半_ 表文件大小不变.html.a0b4da7e.js"><link rel="prefetch" href="/assets/14 count()这么慢_ 我该怎么办.html.8cf5825d.js"><link rel="prefetch" href="/assets/15 答疑文章（一） 日志和索引相关问题.html.63173a34.js"><link rel="prefetch" href="/assets/16 “order by”是怎么工作的.html.a51cc121.js"><link rel="prefetch" href="/assets/17 如何正确地显示随机消息.html.55632279.js"><link rel="prefetch" href="/assets/18 为什么这些SQL语句逻辑相同_ 性能却差异巨大.html.aa190da2.js"><link rel="prefetch" href="/assets/19 为什么我只查一行的语句_ 也执行这么慢.html.c311f962.js"><link rel="prefetch" href="/assets/20 幻读是什么_ 幻读有什么问题.html.bef20aad.js"><link rel="prefetch" href="/assets/21 为什么我只改一行的语句_ 锁这么多.html.54dcb84b.js"><link rel="prefetch" href="/assets/22.MySQL有哪些“饮鸩止渴”提高性能的方法.html.baae2fb3.js"><link rel="prefetch" href="/assets/23 MySQL是怎么保证数据不丢的.html.de07d445.js"><link rel="prefetch" href="/assets/24 MySQL是怎么保证主备一致的.html.d8703177.js"><link rel="prefetch" href="/assets/25 MySQL是怎么保证高可用的.html.93feb431.js"><link rel="prefetch" href="/assets/26 备库为什么会延迟好几个小时.html.14ad8743.js"><link rel="prefetch" href="/assets/27 主库出问题了_ 从库怎么办.html.2e4d7d89.js"><link rel="prefetch" href="/assets/28 读写分离有哪些坑.html.ebe6ec2f.js"><link rel="prefetch" href="/assets/29 如何判断一个数据库是不是出问题了.html.a1a0d482.js"><link rel="prefetch" href="/assets/30 答疑文章（二） 用动态的观点看加锁.html.7353d51d.js"><link rel="prefetch" href="/assets/31 误删数据后除了跑路_ 还能怎么办.html.b546fd0e.js"><link rel="prefetch" href="/assets/32 为什么还有kill不掉的语句.html.fa14f195.js"><link rel="prefetch" href="/assets/33 我查这么多数据_ 会不会把数据库内存打爆.html.ddaebd47.js"><link rel="prefetch" href="/assets/34 到底可不可以使用join.html.9f503937.js"><link rel="prefetch" href="/assets/35 join语句怎么优化.html.95f81089.js"><link rel="prefetch" href="/assets/36 为什么临时表可以重名.html.354471cd.js"><link rel="prefetch" href="/assets/37 什么时候会使用内部临时表.html.c9d4ab47.js"><link rel="prefetch" href="/assets/38 都说InnoDB好_ 那还要不要使用Memory引擎.html.9b369837.js"><link rel="prefetch" href="/assets/39 自增主键为什么不是连续的.html.93069f29.js"><link rel="prefetch" href="/assets/40 insert语句的锁为什么这么多.html.b6a68508.js"><link rel="prefetch" href="/assets/41 怎么最快地复制一张表.html.4cda471b.js"><link rel="prefetch" href="/assets/42 grant之后要跟着flush privileges吗.html.fec20cbf.js"><link rel="prefetch" href="/assets/43 要不要使用分区表.html.46eb93f8.js"><link rel="prefetch" href="/assets/44 答疑文章（三） 说一说这些好问题.html.70884000.js"><link rel="prefetch" href="/assets/45 自增id用完怎么办.html.16cc56b7.js"><link rel="prefetch" href="/assets/直播回顾 林晓斌 我的 MySQL 心路历程.html.0f6a9d34.js"><link rel="prefetch" href="/assets/结束语 点线网面_ 一起构建MySQL知识网络.html.ced5f781.js"><link rel="prefetch" href="/assets/00-Introduction.html.2b1f0852.js"><link rel="prefetch" href="/assets/00-Preface.html.e516d7c3.js"><link rel="prefetch" href="/assets/01-What-is-an-Object.html.86c4af1e.js"><link rel="prefetch" href="/assets/02-Installing-Java-and-the-Book-Examples.html.88cddd12.js"><link rel="prefetch" href="/assets/04-Operators.html.f9d313c6.js"><link rel="prefetch" href="/assets/05-Control-Flow.html.ecf81ffe.js"><link rel="prefetch" href="/assets/06-Housekeeping.html.c35ecf1b.js"><link rel="prefetch" href="/assets/07-Implementation-Hiding.html.396e0a6f.js"><link rel="prefetch" href="/assets/08-Reuse.html.8c7c4047.js"><link rel="prefetch" href="/assets/09-Polymorphism.html.2150cc57.js"><link rel="prefetch" href="/assets/10-Interfaces.html.6ee853fa.js"><link rel="prefetch" href="/assets/11-Inner-Classes.html.ae7b89c4.js"><link rel="prefetch" href="/assets/12-Collections.html.0483e4dd.js"><link rel="prefetch" href="/assets/13-Functional-Programming.html.63412e72.js"><link rel="prefetch" href="/assets/14-Streams.html.7e7cce42.js"><link rel="prefetch" href="/assets/15-Exceptions.html.c186f23a.js"><link rel="prefetch" href="/assets/16-Validating-Your-Code.html.b3313ffc.js"><link rel="prefetch" href="/assets/17-Files.html.7a9ad498.js"><link rel="prefetch" href="/assets/18-Strings.html.46e57539.js"><link rel="prefetch" href="/assets/19-Type-Information.html.b68894bf.js"><link rel="prefetch" href="/assets/20-Generics.html.3993804b.js"><link rel="prefetch" href="/assets/21-Arrays.html.4d150e5c.js"><link rel="prefetch" href="/assets/22-Enumerations.html.87d060f0.js"><link rel="prefetch" href="/assets/23-Annotations.html.0c455464.js"><link rel="prefetch" href="/assets/24-Concurrent-Programming.html.8485a02c.js"><link rel="prefetch" href="/assets/25-Patterns.html.4f5781b0.js"><link rel="prefetch" href="/assets/Appendix-Becoming-a-Programmer.html.4e7ecda3.js"><link rel="prefetch" href="/assets/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html.1a18282e.js"><link rel="prefetch" href="/assets/Appendix-Collection-Topics.html.ec4969df.js"><link rel="prefetch" href="/assets/Appendix-Data-Compression.html.c956724d.js"><link rel="prefetch" href="/assets/Appendix-IO-Streams.html.ac5ea88b.js"><link rel="prefetch" href="/assets/Appendix-Javadoc.html.26db6884.js"><link rel="prefetch" href="/assets/Appendix-Low-Level-Concurrency.html.80dbdde9.js"><link rel="prefetch" href="/assets/Appendix-New-IO.html.613e991c.js"><link rel="prefetch" href="/assets/Appendix-Object-Serialization.html.de90320b.js"><link rel="prefetch" href="/assets/Appendix-Passing-and-Returning-Objects.html.1f3841f2.js"><link rel="prefetch" href="/assets/Appendix-Programming-Guidelines.html.a3de1972.js"><link rel="prefetch" href="/assets/Appendix-Standard-IO.html.28579d58.js"><link rel="prefetch" href="/assets/Appendix-Supplements.html.aae5a747.js"><link rel="prefetch" href="/assets/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html.4bf49d65.js"><link rel="prefetch" href="/assets/Appendix-Understanding-equals-and-hashCode.html.9d9599c8.js"><link rel="prefetch" href="/assets/GLOSSARY.html.d812823c.js"><link rel="prefetch" href="/assets/index.html.d25b0535.js"><link rel="prefetch" href="/assets/404.html.0c8252b8.js"><link rel="prefetch" href="/assets/index.html.d5cc08ad.js"><link rel="prefetch" href="/assets/index.html.1331f6ca.js"><link rel="prefetch" href="/assets/index.html.da6c3a69.js"><link rel="prefetch" href="/assets/index.html.1174fbbd.js"><link rel="prefetch" href="/assets/index.html.c73d2264.js"><link rel="prefetch" href="/assets/index.html.1e315145.js"><link rel="prefetch" href="/assets/index.html.514b72a3.js"><link rel="prefetch" href="/assets/index.html.b19f5086.js"><link rel="prefetch" href="/assets/index.html.1ac6115e.js"><link rel="prefetch" href="/assets/404.3a5fd86b.js"><link rel="prefetch" href="/assets/Layout.42785ec5.js"><link rel="prefetch" href="/assets/Slide.5e14cdfb.js"><link rel="prefetch" href="/assets/Blog.f29d76d0.js"><link rel="prefetch" href="/assets/auto.esm.15d52109.js"><link rel="prefetch" href="/assets/index.1842ee54.js"><link rel="prefetch" href="/assets/mermaid.esm.min.f71f1464.js"><link rel="prefetch" href="/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/assets/photoswipe.esm.92018b73.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.png" alt="DTF&#39;s blog"><!----><span class="site-name hide-in-pad">DTF&#39;s blog</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/guide/" class="nav-link" aria-label="使用指南"><i class="icon iconfont icon-creative"></i>使用指南<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/imdtf/blog" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" aria-labelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewbox="0 0 1024 1024" aria-labelledby="outlook"><title id="outlook" lang="en">outlook icon</title><g fill="currentColor"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></g></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="博客主页"><i class="icon iconfont icon-home"></i>博客主页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-guide"></i><span class="title">语言</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-creative"></i><span class="title">Java</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><i class="icon iconfont icon-creative"></i><span class="title">OnJava8</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/language/java/on-java-8/00-Introduction.html" class="nav-link sidebar-link sidebar-page" aria-label="简介"><!---->简介<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/00-Preface.html" class="nav-link sidebar-link sidebar-page" aria-label="前言"><!---->前言<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/01-What-is-an-Object.html" class="nav-link sidebar-link sidebar-page" aria-label="第一章 对象的概念"><!---->第一章 对象的概念<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/02-Installing-Java-and-the-Book-Examples.html" class="nav-link sidebar-link sidebar-page" aria-label="第二章 安装 Java 和本书用例"><!---->第二章 安装 Java 和本书用例<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第三章 万物皆对象"><!---->第三章 万物皆对象<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#对象操纵" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象操纵"><!---->对象操纵<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#对象创建" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象创建"><!---->对象创建<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#数据存储" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="数据存储"><!---->数据存储<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#基本类型的存储" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="基本类型的存储"><!---->基本类型的存储<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#高精度数值" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="高精度数值"><!---->高精度数值<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#数组的存储" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="数组的存储"><!---->数组的存储<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#代码注释" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="代码注释"><!---->代码注释<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#对象清理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象清理"><!---->对象清理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#作用域" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="作用域"><!---->作用域<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#对象作用域" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="对象作用域"><!---->对象作用域<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#类的创建" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="类的创建"><!---->类的创建<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="类型"><!---->类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#字段" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="字段"><!---->字段<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#基本类型默认值" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="基本类型默认值"><!---->基本类型默认值<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#方法使用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="方法使用"><!---->方法使用<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#程序编写" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="程序编写"><!---->程序编写<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#命名可见性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="命名可见性"><!---->命名可见性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#使用其他组件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="使用其他组件"><!---->使用其他组件<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#static-关键字" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="static 关键字"><!---->static 关键字<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#小试牛刀" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="小试牛刀"><!---->小试牛刀<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#编译和运行" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="编译和运行"><!---->编译和运行<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#编码风格" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="编码风格"><!---->编码风格<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#本章小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="本章小结"><!---->本章小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/04-Operators.html" class="nav-link sidebar-link sidebar-page" aria-label="第四章 运算符"><!---->第四章 运算符<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/05-Control-Flow.html" class="nav-link sidebar-link sidebar-page" aria-label="第五章 控制流"><!---->第五章 控制流<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/06-Housekeeping.html" class="nav-link sidebar-link sidebar-page" aria-label="第六章 初始化和清理"><!---->第六章 初始化和清理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/07-Implementation-Hiding.html" class="nav-link sidebar-link sidebar-page" aria-label="第七章 封装"><!---->第七章 封装<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/08-Reuse.html" class="nav-link sidebar-link sidebar-page" aria-label="第八章 复用"><!---->第八章 复用<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/09-Polymorphism.html" class="nav-link sidebar-link sidebar-page" aria-label="第九章 多态"><!---->第九章 多态<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/10-Interfaces.html" class="nav-link sidebar-link sidebar-page" aria-label="第十章 接口"><!---->第十章 接口<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/11-Inner-Classes.html" class="nav-link sidebar-link sidebar-page" aria-label="第十一章 内部类"><!---->第十一章 内部类<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/12-Collections.html" class="nav-link sidebar-link sidebar-page" aria-label="第十二章 集合"><!---->第十二章 集合<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/13-Functional-Programming.html" class="nav-link sidebar-link sidebar-page" aria-label="第十三章 函数式编程"><!---->第十三章 函数式编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/14-Streams.html" class="nav-link sidebar-link sidebar-page" aria-label="第十四章 流式编程"><!---->第十四章 流式编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/15-Exceptions.html" class="nav-link sidebar-link sidebar-page" aria-label="第十五章 异常"><!---->第十五章 异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/16-Validating-Your-Code.html" class="nav-link sidebar-link sidebar-page" aria-label="第十六章 代码校验"><!---->第十六章 代码校验<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/17-Files.html" class="nav-link sidebar-link sidebar-page" aria-label="第十七章 文件"><!---->第十七章 文件<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/18-Strings.html" class="nav-link sidebar-link sidebar-page" aria-label="第十八章 字符串"><!---->第十八章 字符串<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/19-Type-Information.html" class="nav-link sidebar-link sidebar-page" aria-label="第十九章 类型信息"><!---->第十九章 类型信息<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/20-Generics.html" class="nav-link sidebar-link sidebar-page" aria-label="第二十章 泛型"><!---->第二十章 泛型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/21-Arrays.html" class="nav-link sidebar-link sidebar-page" aria-label="第二十一章 数组"><!---->第二十一章 数组<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/22-Enumerations.html" class="nav-link sidebar-link sidebar-page" aria-label="第二十二章 枚举"><!---->第二十二章 枚举<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/23-Annotations.html" class="nav-link sidebar-link sidebar-page" aria-label="第二十三章 注解"><!---->第二十三章 注解<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/24-Concurrent-Programming.html" class="nav-link sidebar-link sidebar-page" aria-label="第二十四章 并发编程"><!---->第二十四章 并发编程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/25-Patterns.html" class="nav-link sidebar-link sidebar-page" aria-label="第二十五章 设计模式"><!---->第二十五章 设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Becoming-a-Programmer.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:成为一名程序员"><!---->附录:成为一名程序员<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Benefits-and-Costs-of-Static-Type-Checking.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:静态语言类型检查"><!---->附录:静态语言类型检查<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Collection-Topics.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:集合主题"><!---->附录:集合主题<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Data-Compression.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:数据压缩"><!---->附录:数据压缩<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-IO-Streams.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:流式 IO"><!---->附录:流式 IO<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Javadoc.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:文档注释"><!---->附录:文档注释<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Low-Level-Concurrency.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:并发底层原理"><!---->附录:并发底层原理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-New-IO.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:新 IO"><!---->附录:新 IO<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Object-Serialization.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:对象序列化"><!---->附录:对象序列化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Passing-and-Returning-Objects.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:对象传递和返回"><!---->附录:对象传递和返回<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Programming-Guidelines.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:编程指南"><!---->附录:编程指南<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Standard-IO.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:标准 IO"><!---->附录:标准 IO<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Supplements.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:补充"><!---->附录:补充<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-The-Positive-Legacy-of-C-plus-plus-and-Java.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:C++和 Java 的优良传统"><!---->附录:C++和 Java 的优良传统<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/Appendix-Understanding-equals-and-hashCode.html" class="nav-link sidebar-link sidebar-page" aria-label="附录:理解 equals 和 hashCode 方法"><!---->附录:理解 equals 和 hashCode 方法<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/language/java/on-java-8/GLOSSARY.html" class="nav-link sidebar-link sidebar-page" aria-label="/language/java/on-java-8/GLOSSARY.md"><!---->/language/java/on-java-8/GLOSSARY.md<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-markdown"></i><span class="title">数据库</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><i class="icon iconfont icon-question"></i><span class="title">面试题</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第三章 万物皆对象</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" aria-labelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://github.com/imdtf" target="_blank" rel="noopener noreferrer">DTF</a></span><span property="author" content="DTF"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" aria-labelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年5月7日</span><meta property="datePublished" content="2022-05-07T12:20:31.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" aria-labelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 34 分钟</span><meta property="timeRequired" content="PT34M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#对象操纵" class="router-link-active router-link-exact-active toc-link level2">对象操纵</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#对象创建" class="router-link-active router-link-exact-active toc-link level2">对象创建</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#数据存储" class="router-link-active router-link-exact-active toc-link level3">数据存储</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#基本类型的存储" class="router-link-active router-link-exact-active toc-link level3">基本类型的存储</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#高精度数值" class="router-link-active router-link-exact-active toc-link level3">高精度数值</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#数组的存储" class="router-link-active router-link-exact-active toc-link level3">数组的存储</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#代码注释" class="router-link-active router-link-exact-active toc-link level2">代码注释</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#对象清理" class="router-link-active router-link-exact-active toc-link level2">对象清理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#作用域" class="router-link-active router-link-exact-active toc-link level3">作用域</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#对象作用域" class="router-link-active router-link-exact-active toc-link level3">对象作用域</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#类的创建" class="router-link-active router-link-exact-active toc-link level2">类的创建</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#类型" class="router-link-active router-link-exact-active toc-link level3">类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#字段" class="router-link-active router-link-exact-active toc-link level3">字段</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#基本类型默认值" class="router-link-active router-link-exact-active toc-link level3">基本类型默认值</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#方法使用" class="router-link-active router-link-exact-active toc-link level3">方法使用</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#程序编写" class="router-link-active router-link-exact-active toc-link level2">程序编写</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#命名可见性" class="router-link-active router-link-exact-active toc-link level3">命名可见性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#使用其他组件" class="router-link-active router-link-exact-active toc-link level3">使用其他组件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#static-关键字" class="router-link-active router-link-exact-active toc-link level3">static 关键字</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#小试牛刀" class="router-link-active router-link-exact-active toc-link level2">小试牛刀</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#编译和运行" class="router-link-active router-link-exact-active toc-link level3">编译和运行</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#编码风格" class="router-link-active router-link-exact-active toc-link level2">编码风格</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/language/java/on-java-8/03-Objects-Everywhere.html#本章小结" class="router-link-active router-link-exact-active toc-link level2">本章小结</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h1 id="第三章-万物皆对象" tabindex="-1"><a class="header-anchor" href="#第三章-万物皆对象" aria-hidden="true">#</a> 第三章 万物皆对象</h1><blockquote><p>如果我们说另外一种不同的语言，我们会发觉一个不同的世界！— Ludwig Wittgenstein (1889-1951)</p></blockquote><p>相比 C++ ，Java 是一种更纯粹的面向对象编程语言。虽然它们都是混合语言，但在 Java 中，设计者们认为混合的作用并非像在 C++ 中那般重要。混合语言允许多种编程风格，这也是 C++ 支持向后兼容 C 的原因。正因为 C++ 是 C 语言的超集，所以它也同时包含了许多 C 语言不具备的特性，这使得 C++ 在某些方面过于复杂。</p><p>Java 语言假设你只进行面向对象编程。开始学习之前，我们需要将思维置于面向对象的世界。本章你将了解到 Java 程序的基本组成，学习在 Java 中万物（几乎）皆对象的思想。</p><h2 id="对象操纵" tabindex="-1"><a class="header-anchor" href="#对象操纵" aria-hidden="true">#</a> 对象操纵</h2><p>“名字代表什么？玫瑰即使不叫玫瑰，也依旧芬芳”。（引用自 莎士比亚，《罗密欧与朱丽叶》）。</p><p>所有的编程语言都会操纵内存中的元素。有时程序员必须要有意识地直接或间接地操纵它们。在 C/C++ 中，对象的操纵是通过指针来完成的。</p><p>Java 利用万物皆对象的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的“引用” <sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>。 举例：我们可以用遥控器（引用）去操纵电视（对象）。只要拥有对象的“引用”，就可以操纵该“对象”。换句话说，我们无需直接接触电视，就可通过遥控器（引用）自由地控制电视（对象）的频道和音量。此外，没有电视，遥控器也可以单独存在。就是说，你仅仅有一个“引用”并不意味着你必然有一个与之关联的“对象”。</p><p>下面来创建一个 <strong>String</strong> 引用，用于保存单词或语句。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>    <span class="token class-name">String</span> s<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里我们只是创建了一个 <strong>String</strong> 对象的引用，而非对象。直接拿来使用会出现错误：因为此时你并没有给变量 <code>s</code> 赋值--指向任何对象。通常更安全的做法是：创建一个引用的同时进行初始化。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;asdf&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Java 语法允许我们使用带双引号的文本内容来初始化字符串。同样，其他类型的对象也有相应的初始化方式。</p><h2 id="对象创建" tabindex="-1"><a class="header-anchor" href="#对象创建" aria-hidden="true">#</a> 对象创建</h2><p>“引用”用来关联“对象”。在 Java 中，通常我们使用<code>new</code>操作符来创建一个新对象。<code>new</code> 关键字代表：创建一个新的对象实例。所以，我们也可以这样来表示前面的代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;asdf&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>以上展示了字符串对象的创建过程，以及如何初始化生成字符串。除了 <strong>String</strong> 类型以外，Java 本身自带了许多现成的数据类型。除此之外，我们还可以创建自己的数据类型。事实上，这是 Java 程序设计中的一项基本行为。在本书后面的学习中将会接触到。</p><h3 id="数据存储" tabindex="-1"><a class="header-anchor" href="#数据存储" aria-hidden="true">#</a> 数据存储</h3><p>那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有 5 个不同的地方可以存储数据：</p><ol><li><p><strong>寄存器</strong>（Registers）最快的存储区域，位于 CPU 内部 <sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）。</p></li><li><p><strong>栈内存</strong>（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java 系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据（如对象引用），但 Java 对象本身的数据却是保存在堆内存的。</p></li><li><p><strong>堆内存</strong>（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 <code>new</code> 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。</p></li><li><p><strong>常量存储</strong>（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中 <sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>。</p></li><li><p><strong>非 RAM 存储</strong>（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。</p></li></ol><h3 id="基本类型的存储" tabindex="-1"><a class="header-anchor" href="#基本类型的存储" aria-hidden="true">#</a> 基本类型的存储</h3><p>有一组类型在 Java 中使用频率很高，它们需要特殊对待，这就是 Java 的基本类型。之所以这么说，是因为它们的创建并不是通过 <code>new</code> 关键字来产生。通常 <code>new</code> 出来的对象都是保存在堆内存中的，以此方式创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java 使用了和 C/C++ 一样的策略。也就是说，不是使用 <code>new</code> 创建变量，而是使用一个“自动”变量。 这个变量直接存储&quot;值&quot;，并置于栈内存中，因此更加高效。</p><p>Java 确定了每种基本类型的内存占用大小。 这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是 Java 更具可移植性的一个原因。</p><table><thead><tr><th style="text-align:center;">基本类型</th><th style="text-align:center;">大小</th><th style="text-align:center;">最小值</th><th style="text-align:center;">最大值</th><th style="text-align:center;">包装类型</th></tr></thead><tbody><tr><td style="text-align:center;">boolean</td><td style="text-align:center;">—</td><td style="text-align:center;">—</td><td style="text-align:center;">—</td><td style="text-align:center;">Boolean</td></tr><tr><td style="text-align:center;">char</td><td style="text-align:center;">16 bits</td><td style="text-align:center;">Unicode 0</td><td style="text-align:center;">Unicode 2<sup>16</sup> -1</td><td style="text-align:center;">Character</td></tr><tr><td style="text-align:center;">byte</td><td style="text-align:center;">8 bits</td><td style="text-align:center;">-128</td><td style="text-align:center;">+127</td><td style="text-align:center;">Byte</td></tr><tr><td style="text-align:center;">short</td><td style="text-align:center;">16 bits</td><td style="text-align:center;">- 2<sup>15</sup></td><td style="text-align:center;">+ 2<sup>15</sup> -1</td><td style="text-align:center;">Short</td></tr><tr><td style="text-align:center;">int</td><td style="text-align:center;">32 bits</td><td style="text-align:center;">- 2<sup>31</sup></td><td style="text-align:center;">+ 2<sup>31</sup> -1</td><td style="text-align:center;">Integer</td></tr><tr><td style="text-align:center;">long</td><td style="text-align:center;">64 bits</td><td style="text-align:center;">- 2<sup>63</sup></td><td style="text-align:center;">+ 2<sup>63</sup> -1</td><td style="text-align:center;">Long</td></tr><tr><td style="text-align:center;">float</td><td style="text-align:center;">32 bits</td><td style="text-align:center;">IEEE754</td><td style="text-align:center;">IEEE754</td><td style="text-align:center;">Float</td></tr><tr><td style="text-align:center;">double</td><td style="text-align:center;">64 bits</td><td style="text-align:center;">IEEE754</td><td style="text-align:center;">IEEE754</td><td style="text-align:center;">Double</td></tr><tr><td style="text-align:center;">void</td><td style="text-align:center;">—</td><td style="text-align:center;">—</td><td style="text-align:center;">—</td><td style="text-align:center;">Void</td></tr></tbody></table><p>所有的数值类型都是有正/负符号的。布尔（boolean）类型的大小没有明确的规定，通常定义为取字面值 “true” 或 “false” 。基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">&#39;x&#39;</span><span class="token punctuation">;</span>
<span class="token class-name">Character</span> ch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>或者你也可以使用下面的形式：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Character</span> ch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span><span class="token char">&#39;x&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>基本类型自动转换成包装类型（自动装箱）</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Character</span> ch <span class="token operator">=</span> <span class="token char">&#39;x&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>相对的，包装类型转化为基本类型（自动拆箱）：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">char</span> c <span class="token operator">=</span> ch<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>个中原因将在以后的章节里解释。</p><h3 id="高精度数值" tabindex="-1"><a class="header-anchor" href="#高精度数值" aria-hidden="true">#</a> 高精度数值</h3><p>在 Java 中有两种类型的数据可用于高精度的计算。它们是 <code>BigInteger</code> 和 <code>BigDecimal</code>。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。</p><p>这两个类包含的方法提供的操作，与对基本类型执行的操作相似。也就是说，能对 int 或 float 做的运算，在 BigInteger 和 BigDecimal 这里也同样可以，只不过必须要通过调用它们的方法来实现而非运算符。此外，由于涉及到的计算量更多，所以运算速度会慢一些。诚然，我们牺牲了速度，但换来了精度。</p><p>BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。</p><p>关于这两个类的详细信息，请参考 JDK 官方文档。</p><h3 id="数组的存储" tabindex="-1"><a class="header-anchor" href="#数组的存储" aria-hidden="true">#</a> 数组的存储</h3><p>许多编程语言都支持数组类型。在 C 和 C++ 中使用数组是危险的，因为那些数组只是内存块。如果程序访问了内存块之外的数组或在初始化之前使用该段内存（常见编程错误），则结果是不可预测的。</p><p>Java 的设计主要目标之一是安全性，因此许多困扰 C 和 C++ 程序员的问题不会在 Java 中再现。在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。（并且 Java 经常可以优化这些操作）。</p><p>当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 <strong>null</strong> 。在使用该数组之前，我们必须为每个引用指定一个对象 。如果我们尝试使用为 <strong>null</strong> 的引用，则会在运行时报错。因此，在 Java 中就防止了数组操作的常规错误。</p><p>我们还可创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。本书稍后将详细介绍数组，特别是在数组章节中。</p><h2 id="代码注释" tabindex="-1"><a class="header-anchor" href="#代码注释" aria-hidden="true">#</a> 代码注释</h2><p>Java 中有两种类型的注释。第一种是传统的 C 风格的注释，以 <code>/*</code> 开头，可以跨越多行，到 <code>*/ </code> 结束。注意，许多程序员在多行注释的每一行开头添加 <code>*</code>，所以你经常会看到：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/* 这是
* 跨越多行的
* 注释
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>但请记住，<code>/*</code> 和 <code>*/</code> 之间的内容都是被忽略的。所以你将其改为下面这样也是没有区别的。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/* 这是跨越多
行的注释 */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>第二种注释形式来自 C++ 。它是单行注释，以 <code>//</code> 开头并一直持续到行结束。这种注释方便且常用，因为直观简单。所以你经常看到：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 这是单行注释</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="对象清理" tabindex="-1"><a class="header-anchor" href="#对象清理" aria-hidden="true">#</a> 对象清理</h2><p>在一些编程语言中，管理变量的生命周期需要大量的工作。一个变量需要存活多久？如果我们想销毁它，应该什么时候去做呢？变量生命周期的混乱会导致许多 bug，本小结向你介绍 Java 是如何通过释放存储来简化这个问题的。</p><h3 id="作用域" tabindex="-1"><a class="header-anchor" href="#作用域" aria-hidden="true">#</a> 作用域</h3><p>大多数程序语言都有作用域的概念。作用域决定了在该范围内定义的变量名的可见性和生存周期。在 C、 C++ 和 Java 中，作用域是由大括号 <code>{}</code> 的位置决定的。例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    <span class="token comment">// 仅 x 变量可用</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token number">96</span><span class="token punctuation">;</span>
        <span class="token comment">// x 和 q 变量皆可用</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 仅 x 变量可用</span>
    <span class="token comment">// 变量 q 不在作用域内</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Java 的变量只有在其作用域内才可用。缩进使得 Java 代码更易于阅读。由于 Java 是一种自由格式的语言，额外的空格、制表符和回车并不会影响程序的执行结果。在 Java 中，你不能执行以下操作，即使这在 C 和 C++ 中是合法的：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">96</span><span class="token punctuation">;</span> <span class="token comment">// Illegal</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上例中， Java 编译器会在提示变量 x 已经被定义过了。因此，在 C/C++ 中将一个较大作用域的变量&quot;隐藏&quot;起来的做法，在 Java 中是不被允许的。 因为 Java 的设计者认为这样做会导致程序混乱。</p><h3 id="对象作用域" tabindex="-1"><a class="header-anchor" href="#对象作用域" aria-hidden="true">#</a> 对象作用域</h3><p>Java 对象与基本类型具有不同的生命周期。当我们使用 <code>new</code> 关键字来创建 Java 对象时，它的生命周期将会超出作用域。因此，下面这段代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">{</span>
    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;a string&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 作用域终点</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上例中，引用 s 在作用域终点就结束了。但是，引用 s 指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用 s 已超出了作用域的范围。在后面的章节中，我们还会学习怎么在编程中传递和复制对象的引用。</p><p>只要你需要，<code>new</code> 出来的对象就会一直存活下去。 相比在 C++ 编码中操作内存可能会出现的诸多问题，这些困扰在 Java 中都不复存在了。在 C++ 中你不仅要确保对象的内存在你操作的范围内存在，还必须在使用完它们之后，将其销毁。</p><p>那么问题来了：我们在 Java 中并没有主动清理这些对象，那么它是如何避免 C++ 中出现的内存被填满从而阻塞程序的问题呢？答案是：Java 的垃圾收集器会检查所有 <code>new</code> 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄漏”问题。</p><h2 id="类的创建" tabindex="-1"><a class="header-anchor" href="#类的创建" aria-hidden="true">#</a> 类的创建</h2><h3 id="类型" tabindex="-1"><a class="header-anchor" href="#类型" aria-hidden="true">#</a> 类型</h3><p>如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型？你可能很自然地想到 <code>type</code> 关键字。但是，事实上大多数面向对象的语言都使用 <code>class</code> 关键字类来描述一种新的对象。 通常在 <code>class</code> 关键字的后面的紧跟类的的名称。如下代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">ATypeName</span> <span class="token punctuation">{</span>
 <span class="token comment">// 这里是类的内部</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在上例中，我们引入了一个新的类型，尽管这个类里只有一行注释。但是我们一样可以通过 <code>new</code> 关键字来创建一个这种类型的对象。如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ATypeName</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ATypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>到现在为止，我们还不能用这个对象来做什么事（即不能向它发送任何有意义的消息），除非我们在这个类里定义一些方法。</p><h3 id="字段" tabindex="-1"><a class="header-anchor" href="#字段" aria-hidden="true">#</a> 字段</h3><p>当我们创建好一个类之后，我们可以往类里存放两种类型的元素：方法（method）和字段（field）。类的字段可以是基本类型，也可以是引用类型。如果类的字段是对某个对象的引用，那么必须要初始化该引用将其关联到一个实际的对象上（通过之前介绍的创建对象的方法）。每个对象都有用来存储其字段的空间。通常，字段不在对象间共享。下面是一个具有某些字段的类的代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">DataOnly</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这个类除了存储数据之外什么也不能做。但是，我们仍然可以通过下面的代码来创建它的一个对象：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>    <span class="token class-name">DataOnly</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们必须通过这个对象的引用来指定字段值。格式：对象名称.方法名称或字段名称。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>    data<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">47</span><span class="token punctuation">;</span>
    data<span class="token punctuation">.</span>d <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">;</span>
    data<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果你想修改对象内部包含的另一个对象的数据，可以通过这样的格式修改。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>    myPlane<span class="token punctuation">.</span>leftTank<span class="token punctuation">.</span>capacity <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>你可以用这种方式嵌套许多对象（尽管这样的设计会带来混乱）。</p><h3 id="基本类型默认值" tabindex="-1"><a class="header-anchor" href="#基本类型默认值" aria-hidden="true">#</a> 基本类型默认值</h3><p>如果类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。</p><table><thead><tr><th style="text-align:center;">基本类型</th><th style="text-align:center;">初始值</th></tr></thead><tbody><tr><td style="text-align:center;">boolean</td><td style="text-align:center;">false</td></tr><tr><td style="text-align:center;">char</td><td style="text-align:center;">\u0000 (null)</td></tr><tr><td style="text-align:center;">byte</td><td style="text-align:center;">(byte) 0</td></tr><tr><td style="text-align:center;">short</td><td style="text-align:center;">(short) 0</td></tr><tr><td style="text-align:center;">int</td><td style="text-align:center;">0</td></tr><tr><td style="text-align:center;">long</td><td style="text-align:center;">0L</td></tr><tr><td style="text-align:center;">float</td><td style="text-align:center;">0.0f</td></tr><tr><td style="text-align:center;">double</td><td style="text-align:center;">0.0d</td></tr></tbody></table><p>这些默认值仅在 Java 初始化类的时候才会被赋予。这种方式确保了基本类型的字段始终能被初始化（在 C++ 中不会），从而减少了 bug 的来源。但是，这些初始值对于程序来说并不一定是合法或者正确的。 所以，为了安全，我们最好始终显式地初始化变量。</p><p>这种默认值的赋予并不适用于局部变量 —— 那些不属于类的字段的变量。 因此，若在方法中定义的基本类型数据，如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里的变量 x 不会自动初始化为 0，因而在使用变量 x 之前，程序员有责任主动地为其赋值（和 C 、C++ 一致）。如果我们忘记了这一步， Java 将会提示我们“编译时错误，该变量可能尚未被初始化”。 这一点做的比 C++ 更好，在后者中，编译器只是提示警告，而在 Java 中则直接报错。</p><h3 id="方法使用" tabindex="-1"><a class="header-anchor" href="#方法使用" aria-hidden="true">#</a> 方法使用</h3><p>在许多语言（如 C 和 C++）中，使用术语 <em>函数</em> (function) 用来命名子程序。在 Java 中，我们使用术语 <em>方法</em>（method）来表示“做某事的方式”。</p><p>在 Java 中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。格式如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code> <span class="token punctuation">[</span>返回类型<span class="token punctuation">]</span> <span class="token punctuation">[</span>方法名<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token comment">/*参数列表*/</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token comment">// 方法体</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="返回类型" tabindex="-1"><a class="header-anchor" href="#返回类型" aria-hidden="true">#</a> 返回类型</h4><p>方法的返回类型表明了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名和参数列表统称为<strong>方法签名</strong>（signature of the method）。签名作为方法的唯一标识。</p><p>Java 中的方法只能作为类的一部分创建。它只能被对象所调用 <sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>，并且该对象必须有权限来执行调用。若对象调用错误的方法，则程序将在编译时报错。</p><p>我们可以像下面这样调用一个对象的方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">[</span>对象引用<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span>方法名<span class="token punctuation">]</span><span class="token punctuation">(</span>参数<span class="token number">1</span><span class="token punctuation">,</span> 参数<span class="token number">2</span><span class="token punctuation">,</span> 参数<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>若方法不带参数，例如一个对象引用 <code>a</code> 的方法 <code>f</code> 不带参数并返回 <strong>int</strong> 型结果，我们可以如下表示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> x <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上例中方法 <code>f</code> 的返回值类型必须和变量 <code>x</code> 的类型兼容 。调用方法的行为有时被称为向对象发送消息。面向对象编程可以总结为：向对象发送消息。</p><h4 id="参数列表" tabindex="-1"><a class="header-anchor" href="#参数列表" aria-hidden="true">#</a> 参数列表</h4><p>方法参数列表指定了传递给方法的信息。正如你可能猜到的，这些信息就像 Java 中的其他所有信息 ，以对象的形式传递。参数列表必须指定每个对象的类型和名称。同样，我们并没有直接处理对象，而是在传递对象引用 <sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup> 。但是引用的类型必须是正确的。如果方法需要 String 参数，则必须传入 String，否则编译器将报错。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">storage</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>此方法计算并返回某个字符串所占的字节数。参数 <code>s</code> 的类型为 <strong>String</strong> 。将 s 传递给 <code>storage()</code> 后，我们可以把它看作和任何其他对象一样，可以向它发送消息。在这里，我们调用 <code>length()</code> 方法，它是一个 String 方法，返回字符串中的字符数。字符串中每个字符的大小为 16 位或 2 个字节。你还看到了 <strong>return</strong> 关键字，它执行两项操作。首先，它意味着“方法执行结束”。其次，如果方法有返回值，那么该值就紧跟 <strong>return</strong> 语句之后。这里，返回值是通过计算</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>产生的。在方法中，我们可以返回任何类型的数据。如果我们不想方法返回数据，则可以通过给方法标识 <code>void</code> 来表明这是一个无需返回值的方法。 代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">boolean</span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">double</span> <span class="token function">naturalLogBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2.718</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">nothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">nothing2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>当返回类型为 <strong>void</strong> 时， <strong>return</strong> 关键字仅用于退出方法，因此在方法结束处的 <strong>return</strong> 可被省略。我们可以随时从方法中返回，但若方法返回类型为非 <code>void</code>，则编译器会强制我们返回相应类型的值。</p><p>上面的描述可能会让你感觉程序只不过是一堆包含各种方法的对象，在这些方法中，将对象作为参数并发送消息给其他对象。大部分情况下确实如此。但在下一章的运算符中我们将会学习如何在方法中做出决策来完成更底层、详细的工作。对于本章，知道如何发送消息就够了。</p><h2 id="程序编写" tabindex="-1"><a class="header-anchor" href="#程序编写" aria-hidden="true">#</a> 程序编写</h2><p>在看到第一个 Java 程序之前，我们还必须理解其他几个问题。</p><h3 id="命名可见性" tabindex="-1"><a class="header-anchor" href="#命名可见性" aria-hidden="true">#</a> 命名可见性</h3><p>命名控制在任何一门编程语言中都是一个问题。如果你在两个模块中使用相同的命名，那么如何区分这两个名称，并防止两个名称发生“冲突”呢？在 C 语言编程中这是很具有挑战性的，因为程序通常是一个无法管理的名称海洋。C++ 将函数嵌套在类中，所以它们不会和嵌套在其他类中的函数名冲突。然而，C++ 还是允许全局数据和全局函数，因此仍有可能发生冲突。为了解决这个问题，C++ 使用附加的关键字引入了<em>命名空间</em>。</p><p>Java 采取了一种新的方法避免了以上这些问题：为一个类库生成一个明确的名称，Java 创建者希望我们反向使用自己的网络域名，因为域名通常是唯一的。因此我的域名是 MindviewInc.com，所以我将我的 foibles 类库命名为 com.mindviewinc.utility.foibles。反转域名后，<code>.</code> 用来代表子目录的划分。</p><p>在 Java 1.0 和 Java 1.1 中，域扩展名 com、 edu、 org 和 net 等按惯例大写，因此类库中会出现这样类似的名称：Com.mindviewinc.utility.foibles。然而，在 Java 2 的开发过程中，他们发现这会导致问题，所以现在整个包名都是小写的。此机制意味着所有文件都自动存在于自己的命名空间中，文件中的每个类都具有唯一标识符。这样，Java 语言可以防止名称冲突。</p><p>使用反向 URL 是一种新的命名空间方法，在此之前尚未有其他语言这么做过。Java 中有许多这些“创造性”地解决问题的方法。正如你想象，如果我们未经测试就添加一个功能并用于生产，那么在将来发现该功能的问题再想纠正，通常为时已晚（有些错误太严重了就得从语言中删除新功能。）</p><p>使用反向 URL 将命名空间与文件路径相关联不会导致 BUG，但它却给源代码管理带来麻烦。例如在 <code>com.mindviewinc.utility.foibles</code> 这样的目录结构中，我们创建了 <code>com</code> 和 <code>mindviewinc</code> 空目录。它们存在的唯一目的就是用来表示这个反向的 URL。</p><p>这种方式似乎为我们在编写 Java 程序中的某个问题打开了大门。空目录填充了深层次结构，它们不仅用于表示反向 URL，还用于捕获其他信息。这些长路径基本上用于存储有关目录中的内容的数据。如果你希望以最初设计的方式使用目录，这种方法可以从“令人沮丧”到“令人抓狂”，对于生产级的 Java 代码，你必须使用专门为此设计的 IDE 来管理代码。例如 NetBeans，Eclipse 或 IntelliJ IDEA。实际上，这些 IDE 都为我们管理和创建深层次空目录结构。</p><p>对于这本书中的例子，我不想让深层次结构给你的学习带来额外的麻烦，这实际上需要你在开始之前学习熟悉一种重量级的 IDE。所以，我们的每个章节的示例都位于一个浅的子目录中，以章节标题为名。这导致我偶尔会与遵循深层次方法的工具发生冲突。</p><h3 id="使用其他组件" tabindex="-1"><a class="header-anchor" href="#使用其他组件" aria-hidden="true">#</a> 使用其他组件</h3><p>无论何时在程序中使用预先定义好的类，编译器都必须找到该类。最简单的情况下，该类存在于被调用的源代码文件中。此时我们使用该类 —— 即使该类在文件的后面才会被定义（Java 消除了所谓的“前向引用”问题）。而如果一个类位于其他文件中，又会怎样呢？你可能认为编译器应该足够智能去找到它，但这样是有问题的。想象一下，假如你要使用某个类，但目录中存在多个同名的类（可能用途不同）。或者更糟糕的是，假设你正在编写程序，在构建过程中，你想将某个新类添加到类库中，但却与已有的类名称冲突。</p><p>要解决此问题，你必须通过使用 <strong>import</strong> 关键字来告诉 Java 编译器具体要使用的类。<strong>import</strong> 指示编译器导入一个包，也就是一个类库（在其他语言中，一个库不仅包含类，还可能包括函数和数据，但请记住 Java 中的所有代码都必须写在类里）。大多数时候，我们都在使用 Java 标准库中的组件。有了这些构件，你就不必写一长串的反转域名。例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上例可以告诉编译器使用位于标准库 <strong>util</strong> 下的 ArrayList 类。但是，<strong>util</strong> 中包含许多类，我们可以使用通配符 <code>*</code> 来导入其中部分类，而无需显式得逐一声明这些类。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>本书中的示例很小，为简单起见，我们通常会使用 <code>.*</code> 形式略过导入。然而，许多教程书籍都会要求程序员逐一导入每个类。</p><h3 id="static-关键字" tabindex="-1"><a class="header-anchor" href="#static-关键字" aria-hidden="true">#</a> static 关键字</h3><p>类是对象的外观及行为方式的描述。通常只有在使用 <code>new</code> 创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。</p><ol><li><p>有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。</p></li><li><p>创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。</p></li></ol><p><strong>static</strong> 关键字（从 C++ 采用）就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例 。 即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段。相反，对于普通的非静态字段和方法，我们必须要先创建一个对象并使用该对象来访问字段或方法，因为非静态字段和方法必须与特定对象关联 <sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup> 。</p><p>一些面向对象的语言使用类数据（class data）和类方法（class method），表示静态数据和方法只是作为类，而不是类的某个特定对象而存在的。有时 Java 文献也使用这些术语。</p><p>我们可以在类的字段或方法前添加 <code>static</code> 关键字来表示这是一个静态字段或静态方法。 代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">StaticTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">47</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>现在，即使你创建了两个 <code>StaticTest</code> 对象，但是静态变量 <code>i</code> 仍只占一份存储空间。两个对象都会共享相同的变量 <code>i</code>。 代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">StaticTest</span> st1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">StaticTest</span> st2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>st1.i</code> 和 <code>st2.i</code> 指向同一块存储空间，因此它们的值都是 47。引用静态变量有两种方法。在前面的示例中，我们通过一个对象来定位它，例如 <code>st2.i</code>。我们也可以通过类名直接引用它，这种方式对于非静态成员则不可行：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">StaticTest</span><span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>++</code> 运算符将会使变量结果 + 1。此时 <code>st1.i</code> 和 <code>st2.i</code> 的值都变成了 48。</p><p>使用类名直接引用静态变量是首选方法，因为它强调了变量的静态属性。类似的逻辑也适用于静态方法。我们可以通过对象引用静态方法，就像使用任何方法一样，也可以通过特殊的语法方式 <code>Classname.method()</code> 来直接调用静态字段或方法 <sup class="footnote-ref"><a href="#footnote7">[7]</a><a class="footnote-anchor" id="footnote-ref7"></a></sup>。 代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Incrementable</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">StaticTest</span><span class="token punctuation">.</span>i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上例中，<code>Incrementable</code> 的 <code>increment()</code> 方法通过 <code>++</code> 运算符将静态数据 <code>i</code> 加 1。我们依然可以先实例化对象再调用该方法。 代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Incrementable</span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Incrementable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sf<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当然了，首选的方法是直接通过类来调用它。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Incrementable</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>相比非静态的对象，<code>static</code> 属性改变了数据创建的方式。同样，当 <code>static</code> 关键字修饰方法时，它允许我们无需创建对象就可以直接通过类的引用来调用该方法。正如我们所知，<code>static</code> 关键字的这些特性对于应用程序入口点的 <code>main()</code> 方法尤为重要。</p><h2 id="小试牛刀" tabindex="-1"><a class="header-anchor" href="#小试牛刀" aria-hidden="true">#</a> 小试牛刀</h2><p>最后，我们开始编写第一个完整的程序。我们使用 Java 标准库中的 <strong>Date</strong> 类来展示一个字符串和日期。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>
<span class="token comment">// objects/HelloDate.java</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloDate</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, it&#39;s: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在本书中，所有代码示例的第一行都是注释行，其中包含文件的路径信息（比如本章的目录名是 <strong>objects</strong>），后跟文件名。我的工具可以根据这些信息自动提取和测试书籍的代码，你也可以通过参考第一行注释轻松地在 Github 库中找到对应的代码示例。</p><p>如果你想在代码中使用一些额外的类库，那么就必须在程序文件的开始处使用 <strong>import</strong> 关键字来导入它们。之所以说是额外的，因为有一些类库已经默认自动导入到每个文件里了。例如：<code>java.lang</code> 包。</p><p>现在打开你的浏览器在 <a href="https://www.oracle.com/" target="_blank" rel="noopener noreferrer">Oracle<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 上查看文档。如果你还没有从 <a href="https://www.oracle.com/" target="_blank" rel="noopener noreferrer">Oracle<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 网站上下载 JDK 文档，那现在就去 <sup class="footnote-ref"><a href="#footnote8">[8]</a><a class="footnote-anchor" id="footnote-ref8"></a></sup> 。查看包列表，你会看到 Java 附带的所有不同的类库。</p><p>选择 <code>java.lang</code>，你会看到该库中所有类的列表。由于 <code>java.lang</code> 隐式包含在每个 Java 代码文件中，因此这些类是自动可用的。<code>java.lang</code> 类库中没有 <strong>Date</strong> 类，所以我们必须导入其他的类库(即 Date 所在的类库)。如果你不清楚某个类所在的类库或者想查看类库中所有的类，那么可以在 Java 文档中选择 “Tree” 查看。</p><p>现在，我们可以找到 Java 附带的每个类。使用浏览器的“查找”功能查找 <strong>Date</strong>，搜索结果中将会列出 <strong>java.util.Date</strong>，我们就知道了 <strong>Date</strong> 在 <strong>util</strong> 库中，所以必须导入 <strong>java.util.*</strong> 才能使用 <strong>Date</strong>。</p><p>如果你在文档中选择 <strong>java.lang</strong>，然后选择 <strong>System</strong>，你会看到 <strong>System</strong> 类中有几个字段，如果你选择了 <strong>out</strong>，你会发现它是一个静态的 <strong>PrintStream</strong> 对象。 所以，即使我们不使用 <strong>new</strong> 创建， <strong>out</strong> 对象就已经存在并可以使用。 <strong>out</strong> 对象可以执行的操作取决于它的类型： <strong>PrintStream</strong> ，其在文档中是一个超链接，如果单击该链接，我们将可以看到 <strong>PrintStream</strong> 对应的方法列表（更多详情，将在本书后面介绍）。 现在我们重点说的是 <strong>println()</strong> 这个方法。 它的作用是 “将信息输出到控制台，并以换行符结束”。既然如此，我们可以这样编码来输出信息到控制台。 代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;A String of things&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>每个 java 源文件中允许有多个类。同时，源文件的名称必须要和其中一个类名相同，否则编译器将会报错。每个独立的程序应该包含一个 <code>main()</code> 方法作为程序运行的入口。其方法签名和返回类型如下。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>关键字 <strong>public</strong> 表示方法可以被外界访问到。（ 更多详情将在 <strong>隐藏实现</strong> 章节讲到） <strong>main()</strong> 方法的参数是一个 字符串（<strong>String</strong>） 数组。 参数 <strong>args</strong> 并没有在当前的程序中使用到，但是 Java 编译器强制要求必须要有， 这是因为它们被用于接收从命令行输入的参数。</p><p>下面我们来看一段有趣的代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面的示例中，我们创建了一个日期（<strong>Date</strong>）类型的对象并将其转化为字符串类型，输出到控制台中。 一旦这一行语句执行完毕，我们就不再需要该日期对象了。这时，Java 垃圾回收器就可以将其占用的内存回收，我们无需去主动清除它们。</p><p>查看 JDK 文档时，我们可以看到在 <strong>System</strong> 类下还有很多其他有用的方法（ Java 的牛逼之处还在于，它拥有一个庞大的标准库资源）。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// objects/ShowProperties.java</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShowProperties</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;user.name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;java.library.path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>输出结果(前 20 行):</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>java.runtime.name=Java(TM) SE Runtime Environment
sun.boot.library.path=C:\Program
Files\Java\jdk1.8.0_112\jr...
java.vm.version=25.112-b15
java.vm.vendor=Oracle Corporation
java.vendor.url=http://java.oracle.com/
path.separator=;
java.vm.name=Java HotSpot(TM) 64-Bit Server VM
file.encoding.pkg=sun.io
user.script=
user.country=US
sun.java.launcher=SUN_STANDARD
sun.os.patch.level=
java.vm.specification.name=Java Virtual Machine
Specification
user.dir=C:\Users\Bruce\Documents\GitHub\on-ja...
java.runtime.version=1.8.0_112-b15
java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment
java.endorsed.dirs=C:\Program
Files\Java\jdk1.8.0_112\jr...
os.arch=amd64
java.io.tmpdir=C:\Users\Bruce\AppData\Local\Temp\
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><code>main()</code> 方法中的第一行会输出所有的系统字段，也就是环境信息。 <strong>list()</strong> 方法将结果发送给它的参数 <strong>System.out</strong>。在本书的后面，我们还会接触到将结果输出到其他地方，例如文件中。另外，我们还可以请求特定的字段。该例中我们使用到了 <strong>user.name</strong> 和 <strong>java.library.path</strong>。</p><h3 id="编译和运行" tabindex="-1"><a class="header-anchor" href="#编译和运行" aria-hidden="true">#</a> 编译和运行</h3><p>要编译和运行本书中的代码示例，首先必须具有 Java 编程环境。 第二章的示例中描述了安装过程。如果你遵循这些说明，那么你将会在不受 Oracle 的限制的条件下用到 Java 开发工具包（JDK）。如果你使用其他开发系统，请查看该系统的文档以确定如何编译和运行程序。 第二章还介绍了如何安装本书的示例。</p><p>移动到子目录 <strong>objects</strong> 下并键入：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>javac HelloDate.java
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>此命令不应产生任何响应。如果我们收到任何类型的错误消息，则表示未正确安装 JDK，那就得检查这些问题。</p><p>若执行不报错的话，此时可以键入：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>java <span class="token class-name">HelloDate</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们将会得到正确的日期输出。这是我们编译和运行本书中每个程序（包含 <code>main()</code> 方法）的过程 <sup class="footnote-ref"><a href="#footnote9">[9]</a><a class="footnote-anchor" id="footnote-ref9"></a></sup>。此外，本书的源代码在根目录中也有一个名为 <strong>build.gradle</strong> 的文件，其中包含用于自动构建，测试和运行本书文件的 <strong>Gradle</strong> 配置。当你第一次运行 <code>gradlew</code> 命令时，<strong>Gradle</strong> 将自动安装（前提是已安装 Java）。</p><h2 id="编码风格" tabindex="-1"><a class="header-anchor" href="#编码风格" aria-hidden="true">#</a> 编码风格</h2><p>Java 编程语言编码规范（Code Conventions for the Java Programming Language）<sup class="footnote-ref"><a href="#footnote10">[10]</a><a class="footnote-anchor" id="footnote-ref10"></a></sup> 要求类名的首字母大写。 如果类名是由多个单词构成的，则每个单词的首字母都应大写（不采用下划线来分隔）例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">AllTheColorsOfTheRainbow</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>有时称这种命名风格叫“驼峰命名法”。对于几乎所有其他方法，字段（成员变量）和对象引用名都采用驼峰命名的方式，但是它们的首字母不需要大写。代码示例：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">AllTheColorsOfTheRainbow</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> anIntegerRepresentingColors<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">changeTheHueOfTheColor</span><span class="token punctuation">(</span><span class="token keyword">int</span> newHue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在 Oracle 的官方类库中，花括号的位置同样遵循和本书中上述示例相同的规范。</p><h2 id="本章小结" tabindex="-1"><a class="header-anchor" href="#本章小结" aria-hidden="true">#</a> 本章小结</h2><p>本章向你展示了简单的 Java 程序编写以及该语言相关的基本概念。到目前为止，我们的示例都只是些简单的顺序执行。在接下来的两章里，我们将会接触到 Java 的一些基本操作符，以及如何去控制程序执行的流程。</p><div style="page-break-after:always;"></div><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>这里可能有争议。有人说这是一个指针，但这假定了一个潜在的实现。此外，Java 引用的语法更类似于 C++ 引用而非指针。在 《Thinking in Java》 的第 1 版中，我发明了一个新术语叫“句柄”（handle），因为 C++ 引用和 Java 引用有一些重要的区别。作为一个从 C++ 的过来人，我不想混淆 Java 可能的最大受众 —— C++ 程序员。在《Thinking in Java》的第 2 版中，我认为“引用”（reference）是更常用的术语，从 C++ 转过来的人除了引用的术语之外，还有很多东西需要处理，所以他们不妨双脚都跳进去。但是，也有些人甚至不同意“引用”。在某书中我读到一个观点：Java 支持引用传递的说法是完全错误的，因为 Java 对象标识符（根据该作者）实际上是“对象引用”（object references），并且一切都是值传递。所以你不是通过引用传递，而是“通过值传递对象引用。人们可以质疑我的这种解释的准确性，但我认为我的方法简化了对概念的理解而又没对语言造成伤害（嗯，语言专家可能会说我骗你，但我会说我只是对此进行了适当的抽象。） <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>大多数微处理器芯片都有额外的高速缓冲存储器，但这是按照传统存储器而不是寄存器。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>一个例子是字符串常量池。所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中。 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>静态方法，我们很快就能接触到，它可以在没有对象的情况下直接被类调用。 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p>通常除了前面提到的“特殊”数据类型 boolean、 char、 byte、 short、 int、 long、 float 和 double。通常来说，传递对象就意味者传递对象的引用。 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li><li id="footnote6" class="footnote-item"><p>静态方法在使用之前不需要创建对象，因此它们不能直接调用非静态的成员或方法（因为非静态成员和方法必须要先实例化为对象才可以被使用）。 <a href="#footnote-ref6" class="footnote-backref">↩︎</a></p></li><li id="footnote7" class="footnote-item"><p>在某些情况下，它还为编译器提供了更好的优化可能。 <a href="#footnote-ref7" class="footnote-backref">↩︎</a></p></li><li id="footnote8" class="footnote-item"><p>请注意，此文档未包含在 JDK 中;你必须单独下载才能获得它。 <a href="#footnote-ref8" class="footnote-backref">↩︎</a></p></li><li id="footnote9" class="footnote-item"><p>对于本书中编译和运行命令行的每个程序，你可能还需要设置 CLASSPATH 。 <a href="#footnote-ref9" class="footnote-backref">↩︎</a></p></li><li id="footnote10" class="footnote-item"><p>为了保持本书的代码排版紧凑，我并没完全遵守规范，但我尽量会做到符合 Java 标准。 <a href="#footnote-ref10" class="footnote-backref">↩︎</a></p></li></ol></section><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/imdtf/blog/edit/main/docs/language/java/on-java-8/03-Objects-Everywhere.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" aria-labelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/5/7 20:20:31</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: imdtf@qq.com">DTF</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/language/java/on-java-8/02-Installing-Java-and-the-Book-Examples.html" class="nav-link prev" aria-label="第二章 安装 Java 和本书用例"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第二章 安装 Java 和本书用例</div></a><a href="/language/java/on-java-8/04-Operators.html" class="nav-link next" aria-label="第四章 运算符"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第四章 运算符<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2022 DTF</div></footer><!--]--></div><!--]--><!----><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewbox="0 0 1024 1024" aria-labelledby="close"><title id="close" lang="en">close icon</title><g fill="currentColor"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></g></svg></button><div class="logo"><!----><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!----><!----></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button class="install-button">安装<span></span></button><button class="cancel-button">取消</button></div></div></div></div><!--]--></div>
    <script type="module" src="/assets/app.597ce2f2.js" defer></script>
  </body>
</html>
